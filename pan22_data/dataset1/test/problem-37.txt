I think you're comparing apples and oranges here. Polymorphism isn't replaced by messaging at all. You would probably want events/messaging to connect loosely coupled components. Eg. to send a message from an entity when a collision occurs, to update the player score or maybe to trigger a sound-effect. So that these individual classes don't know the other classes and just send out and/or handle messages.
But your game is most likely going to have an update loop somewhere and since you have that update loop, it can easily be used to update all game entities that need to be updated every frame as well. This doesn't prevent you from using messaging though...
If you have some sort of structure where you add/remove game-entities, you can just as well include them in your update loop instead of dispatching an update message to them every frame. So why not call update on your game entities directly while you're using messaging to connect different sub-systems of your game? I also like the Signal/Slot concept (see qt example) for event-like systems.
Bottom line: There's no better approach, nor are they exclusive.
This started as a comment to bummzack's answer, but got long.
Unless you actually make it asynchronous (dispatch events on a new thread), your objects are still getting the memo synchronously. Assuming your event dispatcher uses a basic hash table with a linked list in a cell, the order will be the order in which objects were aded to that cell.
Further, unless you decide to use function pointers for some reason, you still are using virtual function calls since each object getting a message must implement IEventListener (or whatever you call it). Events are a high level abstraction that you build using polymorphism.
Use events where you find yourself having to call a laundry list of methods for various in-game happenings in order to synchronize different systems in the game or where various objects and systems' reaction so said happenings are not able to be clearly defined or you want to add more reactions to said happenings in the future.
They are a great tool, but like bummzack said, don't assume that polymorphism and events solve the same problem.