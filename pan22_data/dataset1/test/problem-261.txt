I've been prototyping a Match 3 game (Bejeweled clone) because I have an interesting concept for one, and because it is good practice.  One key aspect of my version is that the matches must contain one of the swapped orbs.  Therefore matches elsewhere on the board do not get destroyed (and for now there are no combos).
To solve this, I devised a special algorithm that searches for matches starting with the positions of the swapped orbs.
Since this is a naive implementation of Match 3, I am sure that there are lots of problems with the code and especially with the algorithm.
Here is the initial evaluation that happens when a player tries to swap two orbs:
And here is the board evaluator class. It is possible that all of this class should simply be in the GameBoard class, but I am unsure. Right now the Game class has both the GameBoard and the BoardEvaluator, and processes the moves of the game sent by the UI.
There is a bit of code duplication inside the BoardEval class in the methods that search for a match and the methods that mark the orbs that will be destroyed due to a match.  I could not figure out a good solution for this. I wanted the search for any match to return as soon as it found one, because any match will cause a swap to be valid.  It is only after the swap is valid that it needs to calculate all of the orbs that will be destroyed.  Part of the reason for this setup is that the UI will animate an attempted swap when a swap is invalid, and will otherwise animate the completed swap. However, my approach may not be the best way to approach the problem.
And instead, change the property declaration to look like this:
As this (notice I'm also renaming... "find matches" implies we'll return matches):
This is just a subsection of one of your methods, but it's a little confusing.  Let' see if we can clear it up and make it a little more efficient.
This pattern can be applied in 3 other places.  This pattern eliminates the otherColorFound variable and saves us a lot of iterations.  Consider if your row is say 20 orbs wide, and I move an orb into the 20th spot.  Your original implementation will iterate 20 times no matter what.  With this implementation, we stop as soon as we find a different .type or as soon as we find 3 in a row.