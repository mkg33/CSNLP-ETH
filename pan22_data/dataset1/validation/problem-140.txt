I'd like to design a settings class thread save. The settings have 2 attributes: String x and int y and should provide listener functionality to notify listener about changes. The problem is, how to make it thread safe.
x and y are acess controlled, becouse getX, getY uses the read lock and setX, setY uses the write lock.
The interesting part is the copyFrom method. It must be atomic, i. e. x and y must set atomically. To get it atomically, I've wrapped it in a lock-unlock call:
The problem is, that the listeners methods xChanged, yChanged are called so external code is executed. What about the listener call getY in xChanged?:
The write lock holds (from copyFrom), so the listener thread is blocked to aqquire the read lock (from getX). The result is a dead lock I think.
Another possible failure is, that the listener can throw an exception. When an exception is not handled, copyFrom returns abrupt without releasing the write lock. If is it handled (via try-catch), what should I do with this exception?
Are there best practices to handle such stateful classes with listener functionality (I have the same problem for a finite state machine etc.)?
Java isn't my first language, so bear with me if I confuse the syntax a bit. I agree that your copyFrom is not atomic in that the changes are externally visible before the copy is complete. I would also say that it isn't atomic because the origin is not locked and so could change while the copy occurs. Yes, I believe this is a possible point of deadlock - in general I believe it's best to always avoid firing events under a lock for this very reason. 
If you just want to ensure that copyFrom is atomic in that sense that no intermediate state of the copy is visible externally, then you could do like this:
In terms of exception safety, notice that I follow every lock operation with a try..finally and a single unlock in the finally. This makes the code clear, and exception safe with regards to unlocking. In terms of exception safety regarding the internal consistency of the combined state of X and Y (for example if Y is always meant to be the string representation of X or something), you would perform consistency checks before any mutations but after entering the lock.
A general tip from my experience is to keep locks as short and simple as possible, not too many calls and calculations, and very simple flow control. You want to get the information you need to perform the full mutation, then lock, perform the mutation leaving the object in a perfectly consistent state at the end, and unlock asap. You can follow the same pattern for pretty much anything.
The part where I said there could be "consistency checking here" would be important if the combination of input and previous state does not make a valid mutation. For example in the case of a state machine you may want to verify that the state transition is valid and, if it isn't, throw an exception or simply return false or something (which are both safe at that point in the code). You can't do that before the lock because your checks may be working with data that changes under your feet, and you can't do it after changing part of the combined state because then aborting the mutation part way will leave the object in an inconsistent state.
I would also urge you to think clearly about the reason for the copy being atomic. Specifically, are X and Y coupled to each other in such a way that the object would contain inconsistencies if only X or only the Y was copied or changed? Think about the following: