This code is, depending on your point of view, either over-engineered or just wrong.
The whole point of separating the interface from the implementation would be to make the interface independent of the implementation.  Yet, your interface mentions EngineerImpl.View, which defeats the whole purpose of that separation.
The fix, if you consider the code to be over-engineered, is to forget about splitting the interface and implementation, and just make an Engineer class.  If you don't intend to write any other implementations of the interface, that would be the way to go.  Alternatively, you could fix it by moving EngineerImpl.View to Engineer.View.
In addition, the EngineersFactory is in a weird place.  A factory could be useful if you want the caller not to instantiate objects directly — for example, if the caller doesn't know what class to instantiate.  Putting the factory as an inner class of EngineerImpl seems to suggest that the factory is meant to only produce EngineerImpl objects, though.
The naming of the methods in the factory is also off.  "Get" implies fetching an existing instance (like a singleton), not creating a new one.  For a factory, names like createEngineer(), makeEngineer(), newEngineer(), or just engineer(…) would be more appropriate.
Again, I'm not sure what value the factory adds.  The EngineerImpl(name, type) constructor is already public, as are the string constants for the types.  If you abandon the interface-implementation separation, then you would be better off eliminating the factory as well.  Alternatively, keep the factory, but make the EngineerImpl constructor private so that there is one right way to instantiate objects.
The makeOffer() method could be cleaned up. Since the shouldIAcceptNewOffer() and acceptOffer(), both are only used once for this single method it would make more sense to handle all the logic in one method.
This method saves passing through the parameters salary and employer again unnecessarily and is a more neater/conventional approach. 