In Expense, don't use attr_accessor if you are defining a writer method, use attr_reader instead. It doesn't cause any harm as you are simply redefining the writer methods down below, but it might confuse people expecting certain behaviors later.
Symbols are a common way to create identifiers instead of using full String objects. Some benefits are memory efficiency, but also communicating what you expect their role to be in the code.
While there are some use cases for class variables (@@ident), I've found they cause more harm then good. In the Expense class you seem to be using them in place of constants, which you do have in the global scope. You can put constants in class scope as well. If you're trying to avoid making the available outside the class, use a private method or inject an instance of another class that contains the configuration.
This is something that you'll find more troublesome as you work on larger and larger projects. Consider the responsibility of each class. Is the Expense class responsible for deciding whether to continue execution in an error state? Generally the top level "main" method can handle exceptional cases and decide how to proceed. This also becomes a requirement when you start writing tests for your code.
Maintainable code should be self-documenting. It's not clear to me what an InfoGainer does, exactly, by reading the code. After a few passes I was able to surmise that it finds Expenses based on criteria. It's a bit advanced, but take a look at the Repository Pattern.
Separate concerns: database parsing/updates vs. program logic.
You program does two main things: find Expenses by some logic, and add new Expenses. Ideally, each set of concerns is mapped in a layered architecture, such as:
In this way, you could even swap out your CSV file for a SQLite database or remote MySQL database, for example, since your "business logic" (making new expenses, computing reports) is completely separate from your persistence logic. This approach also allows you to test one core aspect of your program separate from the others.
Likewise, if you wrapped your user interaction logic you'd be able to build a GUI or web-service version of the application without touching the business logic on persistence layers.
I also think code needs more improvements besides these.