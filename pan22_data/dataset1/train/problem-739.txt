The burden does not lie with nginx. Proxy or FastCGI both pass information over a socket, that gets interpreted. FastCGI is not that much different, except there's a contract that specifies how information that is to be put in the CGI application is to be transmitted and processed. The SCRIPT_NAME is one of them.
If you wish to stick to proxy you need to teach starman hoe interpret certain headers and tell nginx to set them using proxy_set_header.
I have a perl catalyst application that i'm mounting on a specific url (vs mounting on a subdomain) and am having problems setting SCRIPT_NAME on the request to the backend. This affects the urls generated by the application. It needs to know where it is mounted so that it can properly generate the urls.
request => [ nginx, proxy_pass ] => [ starman:5000 ] => [ perl_app ]
When proxy_pass sends the request to starman, i'm expecting it to set SCRIPT_NAME. If I were using fastcgi, i would do fastcgi_param SCRIPT_NAME something or use fastcgi_split_path_info. At this point I'm ready to just flip over to fastcgi but i'm stubborn and want to figure out if this is possible. I've attempted to set fastcgi_params anyway just to see if it would affect the SCRIPT_NAME sent with proxy_pass but it doesn't as far as I can tell.
So the application is on example.com/ff and the should redirect to example.com/ff/login if you try to go to example.com/ff/home without being logged in. Instead when you make a request to example.com/ff/home PATH_INFO is set to /home (as expected) and SCRIPT_NAME is '', so the application generates a redirect to example.com/home instead of example.com/ff/home