You're possibly trying to over-use game object components.
The shield doesn't need to be a component. It's an equipped item. That might be handled entirely by the InventoryComponent (it doesn't have to be, but it's an option).
So far as damage, yet another option is to make sure that the HitPointComponent is aware of the states and things that alter damage taken and does the adjustment internally. This might be by querying the InventoryComponent.
Another option is for the shield to create a separate collision box in front of the character. If that collision box is hit then it takes the DamageMessage in a ShieldDamageReceiverComponent, halves the amount, and forwards it on to the main character object. This also gives you direction-based blocking. Larger, more complex characters in 3D games will often use their physics models for this purpose without necessarily needing separate game objects.
One of the nice things about components is that you can just use different components in different circumstances. e.g., you don't need a single HitPointComponent; you can have a HeroHitPointComponent that takes into account shields and such, an EnemyHitPointComponent that does not, and so on. Just be careful of walking into a design where you need to mix-and-match those behaviors, but don't avoid the setup out of hand.
Remember, component-based design is a collection of patterns, not a single solution. You can have a game object like your character made up of "components." Your ArmorComponent can then be made up of a dynamic set of ArmorModifier. That's a component that has components, basically. It might not be implemented with an actual set of sub-objects, but the general idea is the same. Your Engine can be a composite of Module components. Your resource objects can be composites of resource providers. etc.
Consider using Sub/Pub pattern, or Observer pattern as a messaging system. This will allow you to register as many event listener as you want, while keeping all the listener decoupled.  The basic idea is you keep a list of objects that want to get the message when an event happens. When the event does happen, you iterate through the list, sending the event message to every object registered to receive it. Each object will process the message however they need to. If a listener no longer needs to receive the message, you simply unregister it.