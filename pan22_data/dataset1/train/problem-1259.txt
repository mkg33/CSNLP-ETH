For a significant speedup: In the outer loop, you vary n from 1 to some large value, and in the inner loop you add up n values. 
Now in the next iteration of the outer loop, using n+1 instead of n, you run the inner loop again, this time adding up n+1 value. But just before that, in the previous loop, you already added up n values, so to get the sum of n+1 values, all you have to do is add value number n+1 to the sum that you already have. 
Have a variable n and a variable sum_n. sum_n will be the sum of the first n cubes. Initially n = 0 and sum_n = 0. Inside the outer loop, increase n by 1 then increase sum_n by nnn. 
For example, if n goes from 1 to 1000, you add up one value, then two, then three, and so on, and eventually you add up 1000 values. On average about 500. This change means you add only one value in each iteration of the outer loop. 
This is an improvement that works for any task where you calculate consecutive sums. In this particular case, you can find a formula to calculate the sum. That isn't helpful by itself, since calculating the formula is likely slower than calculating the sums. However, you can reverse the formula and calculate what n should be, and then you just have to verify this. So you just need a small fixed number of operations, independent of the size of the m that you were given. 
variable vol is declared as double that causes the condition vol == m hardly to be satisfied.
Next, you don't need the Math.Pow method, you could relace it with just n * n * n.
And your loops look a bit confusing. Why m / 3? Why do you need the inner loop?