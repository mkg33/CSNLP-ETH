Let the input size be $n$, with the first $n-1$ bits (call this string $x$) encoding a Turing machine $T_x$. Fix some function $f(n)$. Let the last bit of the string be $1$ iff the Turing machine $T_x$ halts in less than $f(n)$ steps. The problem is then to determine if $T_x$ halts in less than $f(n)$ steps and the parity of $x$ is even.
Thus, by making $n-1$ queries the problem can be solved in time $O(f(n))$, while by making $n$ queries, the problem can be solved in time $O(n)$.
Here's an attempt at creating an artificial function with the following property:
Let the input size be $n + \log n$. Let the first $\log n$ bits (let's call this string x) encode the input to a problem complete for EEXP. The next $n$ bits (let's call this string y) have the property that they are all zero if and only if x is a NO instance of the EEXP-complete problem.
In words, the first $\log n$ bits encode a hard problem, and the next $n$ bits give you a clue about the solution of the problem. However, to figure out the solution by looking at the $n$ bit string you make $\Omega(n)$ queries.
So this problem can be solved by either reading only the first $\log n$ bits and spending exp(n) time or by reading $n$ bits and using only linear time.
The same function goes through for quantum query complexity.. insert square root signs where necessary.