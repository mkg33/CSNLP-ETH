If you want to get right down to it, that's not the best approach from a theoretical perspective, because you're copying data around in your database that you really should be deriving. 
Done.  SELECT queries against this view work exactly the same as queries against either table individually, as long as every product has a pack type.  Queries against this view can still take advantage of the indexes on the base tables, and there's no overhead involved with copying the attributes from one table to another, which always has the potential for update anomalies.  
You might even be surprised to find that the columns in the view can actually be updated as if it were a table, with updates propagating down into the base tables.
I offer this suggestion because a well-designed database should be such that it is impossible to get two different answers to the same question.  For example, if a PACK_TYPES row is changed because an error is found, how do its new values propagate backwards into products?  
But if you really want to take the trigger approach, that looks something like this:
The <=> "spaceship" is the "null-safe equality operator" which constrains "NOT [possibly null] = [possibly null]" to always be either TRUE or FALSE; this is needed because [possibly null] != [possibly null] will never be true if either expression is NULL. This is the case because, logically, "NOT (FALSE)" is "TRUE" while "NOT (NULL)" is "NULL." 
I could have declared the variables at the beginning and avoided the inner BEGIN/END  but it seems optimal to avoid that work until we know we actually need to execute the inner logic in the first place, which is avoided whenever 'packaging_type' hasn't actually changed on a row for a given update query.  Within a block, declarations have to precede other statements, so delaying the declarations requires the addition of the inner BEGIN/END.
You would also want a similar trigger for BEFORE INSERT which would be identical except you'd remove the 4 lines starting with IF ... BEGIN ... END ... END IF from the body of the procedure, use a new trigger name, and change BEFORE UPDATE to BEFORE INSERT. 
It's BEFORE -- not AFTER -- in both cases, because the trigger fires BEFORE the newly-inserted or newly-updated row is written to the database.  
However, why storing the records in a duplicate way? That is not very normalised. Unless you have a really good reason, a better way to do this would be to convert packaging_type into a FOREIGN KEY of PACK_TYPES and perform a JOIN whenever the columns from both tables are required.