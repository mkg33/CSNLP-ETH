Backtracking algorithms (in which the knight is allowed to move as far as possible until it comes to a blind alley, at which point it backs up some number of steps and then tries a different path) can be used to find knight's tours, but such methods can be very slow.
Reason for that is, even for 8x8 board there are huge number of unique length 64 sequences, but only few result in Hamilton path. You can imagine the problem as graph:
To get better result faster you basically need to find a way to do less work. A way to do less work would be to make better decisions usually it is called choosing a heuristic function.
Warnsdorff (1823) proposed an algorithm that finds a path without any backtracking by computing ratings for "successor" steps at each position. Here, successors of a position are those squares that have not yet been visited and can be reached by a single move from the given position. The rating is highest for the successor whose number of successors is least. Here is C++ example implementation
If you want to do even better, then take a look at more optimized version. For 8x8 board starting at position 1;1 following would be an answer:
As a bonus, I generated answers for few more board sizes (up to 200 in dimension):
https://www.dropbox.com/sh/wkmcsnb0j7k1f0o/AACDbdLFveOVG1717LY3fX9la?dl=0
Backtracking doesn't mean blind. You still can exercise some heuristics: which order to inspect moves, for example (it is recommended to look for a move with the least possible continuations). 
An isSafe method could be simplified with a certain gain of performance if you surround the board with a thick border. Initialize the border cells to -2, and eliminate bound checking of row, col.
Another possible speedup would be to switch to iterative solution. You'd need to maintain the stack of moves manually.