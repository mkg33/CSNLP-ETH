To expand upon my earlier comment: For a 2D tile map, I don't usually see any need to stream the map into memory, or load it by chunks.  The easiest gains will come from simply not rendering any tiles that are off screen, and not updating any entities that are more than X screen size units away.  If the map is truly massive, to the point that you can't iterate through it to cull your off-screen draw calls without breaking your frame-rate, then and only then will you want to find a way to break the map into chunks.
Let's assume your camera is tracked as being at an (x,y) point, and that unless the player character is at the edge of the map, the camera position matches the player position.
The first thing you'll need to know is the screen size, which is language/library dependent, and also another question.
For the sake of example, you've determined the screen size is 1920x1080.  Having access to the tile assets, you know they're 16x16.  You can then determine that you need to draw 1920/16 x 1080/16 => 120 tiles horizontally, and 68 (67.5) tiles vertically.  Considering that the player/camera may not always be directly centered on a tile, you'll want to add a 1 tile buffer on either side in both dimensions.  In terms of tile size, your screen dimensions are 122x70.
You'll also need to know the relative position of that screen area within the tile array.  If the player/camera is at (4237, 5642), then your player is on tile (x.pos/tile.width, y.pos/tile.height) => (4237/16, 5642/16) => (264, 352).  Taking the screen size in tile units from above (122x70), halving it, and adding to / subtracting from the player tile in each direction, your on-screen tiles would therefore range from (203,317) to (325,387).  For later reference, I'll call these (xMinTile, yMinTile) and (xMaxTile, yMaxTile).
In your rendering function, where you determine which tiles to pass off to the video card, instead of sending the entire array of tiles you'll check against the min/max tile positions.
The 'j' for loop is inside the if check for x bounds to somewhat optimize the test. Similar to AABB collision testing, why check the Y dimension if we already know X is out of range?  This is important to getting as much mileage out of this approach as possible, as is sending your tiles in a draw batch (assuming your renderer supports that, which... it really should), before you have to start breaking the map into chunks.
You'll have to make changes for determining the on-screen tiles as the player approaches the edge of the map, whether it overflows and wraps around, or just caps to the edge tile so you don't see the neutral zone outside the map boundaries, but this should cover the general idea.
I created a tile-based rpg game in java, but it runs really really slow, the reason is the big tile-map that is stored in the buffer. Is there any way to programmatically load pieces of the map when needed and not the entire map at once, so that the buffer will remain small and the game will run fast? Any sort of useful tip would be helpful.