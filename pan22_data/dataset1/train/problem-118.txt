One advantage of using IComparer interface is the ability to use one routine for ascending or descending comparisons.  This mixed with Reflection allows you to use one routine to compare any of the 3 properties.  If you plan on more different types of properties this might not be too practical but should work for the class you've shown:
Searching by any property and returning the object could look something like this:
You can save yourself a lot of code here by using LINQ's OrderBy and OrderByDescending. These allow you to use a lambda to pull out a part of the object to order by, and the default IComparer for the type returned by the lambda is used. So for example:
Allowing you to completely remove your IComparers (they're also used in BinarySearch, but I'll go into that later)
There are a number of issues with how you create jobs:
So, let's put that all together and come up with an alternative version of the Job class:
For an example of how you might use some validation with this class, consider adding the rule that the salary must be non-negative. You can do this by altering the property like so:
This may or may not be something you actually want to do, but it's a good example of how a class like Job can add value through doing validation. And speaking of value:
Wrapping a collection in a class which serves as a gateway to making calls on that collection is relatively common, and often a good idea. But make sure there's good reason for it first.
The name JobList is the first indication that this may not be a case where you actually want to do this. Usually if a collection should have its own class, it's because that collection is its own conceptual entity. For example, a List<PlayingCard> might be wrapped in a Hand or Deck, or a List<Player> might be wrapped in a Team. These can all perform functions related to what they actually are which a simple List cannot. For example:
So those are just examples. It's not a hard and fast rule that you can't have a class called something like JobList that doesn't have a useful, sensible function in wrapping a collection, but it's a good starting point.
So in this case, let's go through what the JobList does and see if it adds value:
So if we removed this class, how would printing and searching be handled? Or is having them where they are valuable enough to justify the class's existence? 
In this example, I assume multiple jobs can match a category, so Where would probably be the best option if you want all of them. If you only want any one of them, then FirstOrDefault would probably fit. I'd also guess only one job can have a particular Title, so you'd probably want SingleOrDefault. In a case where you absolutely expect there to be a job matching your search criteria, then you'd want First or Single instead of FirstOrDefault or SingleOrDefault respectively.
Whichever of those LINQ methods you use, you want to pass the same thing to them: a lambda which returns true for an item matching the search criteria, and false otherwise. So for example:
With this method, there's now no longer any need for the Search methods, and so now there's no longer any method that needs to be on JobList and so you can remove the class, just using a List<Job> instead.
The above would be my suggestion, but it's based on certain assumptions. What if Print is called in multiple places? What if BinarySearch really does perform better and that performance is critical? What if there's some additional logic or validation which that class could usefully handle? In those cases, you may want to keep JobList. So instead of deleting it, here's how you could improve it: