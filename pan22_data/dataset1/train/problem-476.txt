Computers are designed to be fast.  That may include cheating.  For instance, when a computer is supposed to write data, computers might store data in RAM instead of writing it to a hard drive.  This is done because RAM is much faster.
Shutting down tells the computer to flush the buffers, meaning to stop storing stuff in RAM, and prepare for the system to lose electrical power.  If you actually lose electrical power before making sure that all such data is properly written, you may lose data.
Part of the details of the filesystem volume's structure are handled by the operating system's filesystem-handling code (sometimes called the filesystem driver).  Often, the filesystems use tables.  (Visually, you can think of these like charts.)  Imagine if you were writing out a multiplication table, and it said:
First of all, every column has just one row.  Multiplication problems are supposed to have three parts (two numbers that are multiplied (the multiplicand and multiplier) and an answer (the product)).  Here all we are seeing is a bunch of single numbers, so we don't even have one full example of a multiplication product.  What we have is useless.
Second, what we have is actually worse than useless.  Sometimes, the only thing worse than missing information (causing you to make no progress while you figure out the information you need) is trusted misleading information that causes you to spend resources to proceed in a useless, bad direction.  In this case, you have invalid data towards the end: a one instead of a 16.  (The idea here is that the chart stopped being updated suddenly, before the entire number "16" was noted properly.)  If you don't let the computer complete its charts correctly, then that can cause confusion.  (If the computer is told to update some data, and it should write to position number sixteen... you don't want it to write to position number one!)  The computer relies on tables quite similar in nature to this.  Shutting down tells the operating system to try to wrap things up neatly, instead of leaving jobs half-finished.
Another example is virtual memory.  If a computer runs out of RAM, it can use space on a hard drive to keep track of details.  For instance, maybe you have a fifty page document in a word processor.  The computer is keeping track of the fact that the word processor is open, and keeps track of the first 12 pages, but the remaining 38 pages are stored on the hard drive, in what is called "virtual memory".  When you shut down, the computer will go through the entire process of shutting down programs, which will free up some RAM, and eventually use the "virtual memory" to properly handle the word processor.  If you simply lost electrical power, then the word processor stops running (because everything stops).  Then, when the computer starts up, it sees the virtual memory has the data from the 38 pages of the document that was opened in a word processor.  The computer doesn't even know that the data was being used by a word processor.  Shutting down allows such things to be taken care of while the computer is able to keep track of these details.
Compared to Windows 95, MS-DOS was more resilient (less prone to problems) when it came to sudden power outages.  (Some of that increased vulnerability was because of Windows 95's abilities to multitask and handle virtual memory.)  So the computer's susceptibility to invalid shutdowns, or even if an official shutdown procedure is required at all, is based on which operating system is being used.  Most modern operating systems are designed to rely on requiring a proper shutdown, because operating systems are easier to design with such a requirement.  There's no reason that has to be the case, and in fact, some operating systems nanobsd do allow a person to just power it off.  As one example, a page on nanobsd says "Everything is read-only at run-time â€” It is safe to pull the power-plug."  As another example, resflash's home page has a bullet point saying "Power can be safely lost at any time."  So there is no reason why absolutely shutdowns have to be a requirement that operating system designers impose when they create the design of an operating system.  Shutting down is just simply a requirement that is quite common.
because if some descriptor file is open it can corrupt a important file and leave the OS dead