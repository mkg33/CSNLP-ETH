If performance is not an issue, you can just choose a point out of the set of points from which a path to the end exists.
Essentially it's like your second option, but after each step you check from which neighbours there's still a path to the end point, and choosing a random point out of the set of valid points.
One common way to solve this type of problem is to still use a shortest path algorithm like A* that takes into account traversal costs. We just lie to it about what's "shortest" ;)
Here we assign our costs for moving into each cell pseudorandomly — effectively making an invisible terrain of hills and valleys, fast roads and slow marshes for the algorithm to navigate. The path will meander to favour the low-cost cells and avoid crossing high-cost barriers, but since these obstacles exist only in the pathfinder, it looks to the player like it turned a corner for no reason.
By using a different seed for each pathfinding query, we can avoid each path settling into the same fast routes, and instead taking completely uncorrelated meanders.
This also lets you finely control the kinds of shapes you get from the paths, by tuning the scale and magnitudes of the pseudorandom cost features — getting big sweeping curves or little fractal zig-zags depending on how you choose to generate this imaginary landscape.