I would write a puzzle solver using Dijkstra's algorithm, which would find the optimal solution for the puzzle. This algorithm trivially returns two measures for the difficulty:
The higher the numbers, the harder the puzzle is. You need to experiment how to combine these values when calculating the difficulty.
In Djikstra's algorithm you need to implement a check to ensure that a node is not visited twice. Because of powerups and keys this check needs to be a little more complex. You need to record the state of the player (health and possessed keys) for each visited node and compare that as well. If the state of the player is better than previously, a node can be visited again.
This algorithm will take some time to run on more complex puzzles, but I believe it would be fast enough to be practical, as it only needs to run once.
If this is not sufficient, you could try optimizing it with A* or D* Lite. Neither of those would be very easy though in your situation because of the dynamic nature of the level.
Assuming that you have an online game with a non-trivial number of players.
Do note that the difficulty rating doesn't need to be fixed and unchangeable.
First, make any heuristic to roughly estimate the initial difficulty - any of your own simpler suggestions would work, don't put much time in it, anything that's somewhat sane would be enough.
Second, measure how your players behave on the existing levels (where you're sure of the difficulty rating) - what is the % of failures, time spent on the level.
Third, as soon as real, live players have played the new user-created puzzle a few times,  ditch the initial estimate and update the difficulty according to how they behaved on that new puzzle - if the time/failure%/whatever is similar to the existing 4-star puzzles, label it with 4 stars, etc.