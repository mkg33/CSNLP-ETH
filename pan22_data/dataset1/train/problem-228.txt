I have an idea that might work. We start with a generalized suffix tree for sequences $S$ and $T$. Each internal node with suffixes of both $S$ and $T$ in its subtree corresponds to some common substring of the sequences. Let us call such nodes non-trivial. The common substring is maximal, if the corresponding node has no non-trivial children. If node $v$ is non-trivial, we store the largest string-depth of a non-trivial node in its subtree as $lcs(v)$. If $r$ is the root, then $lcs(r)$ is the length of the longest common substring of $S$ and $T$.
Updating the tree after deleting a substring from one of the sequences should not be too hard. We first delete the leaves corresponding to the deleted suffixes, updating their ancestors when required. Then we start processing the suffixes preceding the deleted substring. Let $v$ be the lowest non-trivial ancestor of the current leaf. If the length of the suffix is $k$ (we are $k$ steps from the deletion) and $k < lcs(v)$, we have to move the suffix to its proper position in the tree, updating the ancestors when required. If $k \ge lcs(v)$, we are done, as we are not interested in subtrees with trivial roots.
The overall algorithm repeatedly finds the longest common substring of $S$ and $T$ and deletes one of its occurrences from both sequences, as long as the length of the LCS is large enough.
There are some technicalities, but the general idea should work.
Start with the concatenated text S$T, where $ occurs nowhere in * or T. Construct a suffix tree/array from this text. It's easy now to traverse this suffix data structure to collect all right maximal repeats. By examining the left context, filter out the non-left maximal repeats. This leftward filtering might be implemented using the Burrows-Wheeler table as in Abouelhoda et al, though I don't believe that this is necessary. Repeats occuring only in S or only in T should olso be eliminated at this point. Repeats that haven't been eliminated are then put on a priority queue, with priority defined by length. After the traversal, as recorded repeats are removed from the priority, the final filtering (for substring containment) can be carried out. Given the use of maximal phrases, however, I suspect that very little of this filtering would be necessary.
This algorithm is my own invention. I would not classify it as very clever, but it ought to work.