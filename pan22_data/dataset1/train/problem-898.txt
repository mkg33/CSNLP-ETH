If you will allow me a shameless plug, I'll give you an example from a real game I'm working on (YouTube video link).
The game has an infinite, procedurally generated world on a physics engine. It uses single-precision floating point. After a few hundred meters of game space, precision issues start to arise (and get progressively worse the further from the origin you get).
My solution? Every 200m or so I move the entire world back by 200m towards the origin (if you care to find and try one of the prototypes on my site, and bring up the [w]orld debug overlay, you can see this happen).
Why not use fixed point? Or double precision? Instead of single-precision? Because everything else is using single precision floating point!
The physics engine I'm using uses it, XNA uses it, the data that gets loaded onto the graphics card is formatted as single-precision floating point. Even the language itself is designed to work with floating point numbers -- writing and (more importantly) reading 0.5f is far easier than 0x80000000L.
It's simply a matter of what is easier in practice. And the clear winner is being aware of floating point precision issues and writing fairly simple "move-the-world-back-to-zero" functions (or implementing space partitioning or whatever suits your game).
And finally another example - Orbiter is game (simulation, really) that really needs to care about precision. Not just in space but also in time (time acceleration plus orbiting bodies - don't want them to fall out of the sky, now). It also uses floating point numbers and employs a hack to maintain stability.
In an FPS context, fixed-point values might actually be a liability. Close to zero floating-point is more accurate. It is only over large distances fixed-point becomes more preferable. The answer is simply that its dependent on context.
In something like a galaxy you can use frames of reference. Use a huge scale for the solar systems and then use the center of the Sun (or similar point) as the point of origin for anything inside the system. Using this system you can have your cake and eat it, so to speak, and its not difficult to envision.
IIRC, the dev on Infinity stated that he was continuously iterating around scale issues in one of his interviews.