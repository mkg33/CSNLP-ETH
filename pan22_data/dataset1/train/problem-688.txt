What you are trying to do is called pivoting. You essentially want the results grouped by code and action but re-arranged so that instead of one row per code and action you get one row per code only, all the distinct action values (well, just two in your case) forming separate columns.
Some SQL products support a dedicated PIVOT syntax. MySQL is not one of them, but you can use other ways.
One common way is conditional aggregation. You will group the rows by code only, because you want one row per code in the output. The aggregation by action will be achieved by introducing a conditional as the aggregate function's argument. This is how you code that in SQL:
Each SUM expression aggregates qte just for one of the action values, either 'IN' or 'OUT', using a CASE expression. As shown in the query, you need two SUM expressions, one per each value of action. If you had more, you would need to add more SUMs accordingly.
However, as there only two values here, it may make sense to try alternative methods. One such alternative is in Akina's answer. Here is another option:
As you can see, getting each of the two columns (IN and OUT) requires one outer join to a derived table containing the aggregated results for the corresponding action value. It is easy to see how this approach would not be a good idea if you needed to produce ten such columns. Not only would the query itself become cumbersome much more quickly than the conditional aggregation method, but the performance would deteriorate very soon too. However, for just two columns this option might be worth a shot.
Both suggestions presented in this answer can be found and played with at dbfiddle.uk (the setup was borrowed from Akina's fiddle):
Try this query, I think you might have the incorrect expected result. 