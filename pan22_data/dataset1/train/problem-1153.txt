This question comes up a lot in relation to the .obj model format, and the answer is that yes: you can only have a single index buffer, but it works with both interleaved and non-interleaved data.
For the non-interleaved case I'm assuming that you're thinking of a case where the data is fully de-duplicated (again, like .obj).  What's important to realise here is that this kind of case may be optimized for storage, but it's not optimized for rendering.
The solution is to re-introduce duplicate vertex attributes so that the single index buffer is capable of handling all streams.  Roundabout this time many people say "surely that's less efficient because it uses more memory?"  The answer to that one is "no".
Saving memory is not the be-all and end-all of performance.  Using an index buffer gives other advantages too, and both of these are more important for performance than saving memory:
It may be the case that future hardware will allow for multiple index buffers, or an extra level of index indirection, but there's no sign of that on the horizon.  The current approaches work more than well enough, and a little extra memory usage is a fair tradeoff for a lot of extra performance.
Multiple vertex buffers would be used when your data is non-interleaved.  If your data was interleaved then you'd put it all in one vertex buffer.  (You can also have vertex data partially interleaved and partially not.  For instance, all the positions could be in one buffer, and all the other attributes - normals, UVs, etc. - interleaved in another buffer.)
Regardless of the vertex layout, there's only one index buffer bound at a time, and the same index is used for all vertex buffers.  If the number 47 is found in the index buffer then the GPU will load the 47th element of the first vertex buffer, the 47th element of the second vertex buffer, etc.  The data from all bound vertex buffers will be available as inputs to the vertex shader.