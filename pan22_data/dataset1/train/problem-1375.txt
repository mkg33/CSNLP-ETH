The most time consuming part of the code is sieving prime numbers. And it is  important to realize that each time you sieve, you'd arrive to the same set. In other words, you may compute it once - for the largest n - and reuse the result for all the tests.
There is at most 10 test cases. Read them, find the largest n, sieve the relevant primes, and then loop over the cases.
The sieve code is correct. The results are correct.
When generating prime numbers with the sieve of Eratosthenes, you can treat 2 as a special case.  All other prime numbers are odd, so you can increment by 2:
When you find a prime number \$p\$, you have already eliminated all multiples of prime numbers below \$p\$.  This means starting at \$2p\$ and going up is eliminating already eliminated multiples.  You can start at \$p^2\$, and since you are only concerned with odd numbers, go up multiples of \$2p\$
When looping over the array for printing, you could again skip all even numbers, by going up by 2.  But make sure you start on an odd number!
If you reversed your sense of the flag array, so true means "not prime", you wouldn't have to loop through the array to set all elements to true at the start.  They would start off as false, which would mean "prime".
Marking all prime numbers on one pass, and then looping through your marked array printing out prime numbers is looping twice for possibly no reason.  You can simply print out the prime numbers as you find them, if it is inside the required range.  It would require some juggling, and optimization tricks to ensure you print out a number only when required, and only exactly once.
You generate the sieve 10 times, if you have 10 test cases.  Maybe you could examine all 10 test cases, find the largest end point, and generate the sieve once???