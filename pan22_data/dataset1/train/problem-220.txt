As others have already noted, it's probably better to use an inline function to do this job in C++.
Assuming a reasonably recent standard library, you can also carry out the rounding quite a bit more cleanly using the round function, to get code something like this:
As to efficiency: yes, this can be significantly faster (but, as always when dealing with performance, only testing will show for sure). The main reason for the speed improvement is that rounding is often handled as a mode of operation for the floating point unit. When you convert to int (by truncating) the compiler has to generate code to change the current mode to truncate the number, then convert to an int, and finally change the mode back to round (as it needs it while doing normal calculation). These mode changes tend to be quite expensive, so code like above that avoids them can be faster.
This does not reproduce the behavior of the macro in all respects. The macro produces undefined behavior if the number is too large to represent as an int. For example, MY_ROUND(1.23456e+30, 3) produces -2.1478e+06 on my machine (but it's undefined behavior, so don't be surprised if you get something different). For the same input, this function produces 1.23456e+30. That may not be what's desired (it still includes more digits than were specified) but at least it's not obviously wrong.
Neither this nor the original macro deals well with numbers less than 1.0. For example, if either this or your macro is asked to round 1.23456e-30 to 3 digits, both produce 0, rather than the 1.23e-30 that I'd hope for. For better or worse, however, your macro has defined behavior in this case, so I didn't feel as free to "fix" it to get the behavior I think is more desirable.
I'd go with an inline function, as @pacmaninbw said, instead of a macro. It's more readable and it's easier to notice things that you may want to optimize.
A couple of things that may speed this up a bit if you use a function: