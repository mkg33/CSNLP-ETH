I would reorganize the code somewhat in order to separate concerns a bit more. Right now, game rules, I/O, etc, are all mixed together.
This line should start every header file (the alternative is include guards; see Wikipedia's explanation.
All C++ code should go into a namespace; this is essentially a package name. It prevents naming conflicts with other libraries and has other benefits as well.
Functions that do not modify their class should be marked const.
OK, so you see a couple things -- one, Board is not responsible for reading and writing from console. It is the model in a Model-View-Presenter pattern. Two, we're not representing state as you did. There's nothing that says that you have to store data in the same format you receive it (e.g. a sequence of pair<int, int>). Instead, we transform it into something more useful - the actual board pattern. Here we use a two-dimensional array instead of a vector because we know that the size won't change.
You can imagine multiple implementations of BoardView; one for a console game, one for a Windows GUI, one for a Unix GUI, etc. But note that BoardView doesn't really need to know anything about the rules of the game - except possibly that coordinates should be between 1 and 3.
I'll leave the rest of the implementation as an exercise to the reader.
I would also structure the code quite differently, but there is at least one other answer already addressing that. Instead, I will focus mostly on implementation details.
To me, many of your comments are too verbose. In general, I'd want to read comments that explain "why", and not "what". For instance, it is absolutely clear from good naming, that a line like while (!mainBoard.GameWon()) executes the main loop. I think adding a comment emphasizing this in fact hurts readability. 
If you have a (member) function that takes no arguments, write it as void my_function();. That is, omit void from the argument list, it adds no information and likely only irritates a C++-programmer reading the code. Also, and this is important, mark every member function const that does not modify the state of the object. Typically, if you are printing information or something similar, you are not modifying the object. As a reader or a user of your interface, I fully expect such a member function to be const. In fact, all of your 4 member functions seem like they can be const, except for the one that advances the game. By the way, including array, string, and iterator seem totally unnecessary for the header file. Include them in the source file.
It's good that you are using const std::string to represent walls and such. I would probably wrap these two variables inside an anonymous namespace, thus restricting them to the particular source file only. There is no need to access them from the outside, after all. Similarly, why not make "X" and "O" constants as well? Maybe you'd like to change the symbols in the future.
You are testing for the emptiness of a container. This is not the most idiomatic way of doing it. Use always the most appropriate member function available. In this case, the line should be if(!locations.empty()). For a vector, this might not have any effect. But for say std::list, it might. Bottom line is that you should not make any assumptions as to how a container is actually implemented. It could be that empty() takes constant time, while querying for its size takes time linear in the number of elements in the container. So be careful, or face unexpected performance consequences :-)
Instead of constructing a std::pair like you do, you might want to be aware of std::make_pair. I would likely also write your FindLocation function so that it only consists of a single return-statement (by the way, you could also operate with const_iterators here, as you are not modifying anything. Moreover, you don't want to modify anything).