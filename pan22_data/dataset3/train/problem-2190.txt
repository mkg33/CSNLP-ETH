Please let me know if this is a really, really bad idea!
I also understand that Increasing is not equal to NonDecreasing, but typing and abbreviating the latter is a pain in the fingers.
I understand this is not sufficient to prove that a merge sort based on this merge function is indeed a sort, since a merge that, say, always returns an empty list or the first list, would still be provably mergeIsIncreasing, so another piece of the puzzle is proving that merge f xs ys is a permutation of xs ++ ys, but let's deal with non-decreasing part first.
I'm deliberately not using Dec or Decidable.Order (since they seem to make my proof more clumsy), delegating proving the necessary properties of the comparator to the calling code and just requiring Totality instead, which is essentially the assumption that the order is total.
The code below represents ordering criteria over type a as members of the Order a type.
Other than that, stylistic comments, proof idea comments, whatever else comments are welcome!
As a first step, I'm writing a function that merges two non-decreasing lists (this is easy) along with a proof that it produces a non-decreasing list (this is the hard part I'd like to have reviewed, along with the representation of non-decreasing lists).
I'm just starting to learn using both dependent types and proof assistants, and as an exercise I'm trying to write a provably correct merge sort.