Algebra (and algebraic geometry) has had a pretty big role to play in cryptography, with elliptic curve groups, (number-theoretic) lattices, and of course $\mathbb{Z}_p$ being the basis for nearly all modern cryptographic work.
Some classic results (e.g., the Yoneda lemma) happen to have computational content and utility.
Also, there is homotopy type theory, which interprets type theory in (sort-of) an algebraic topological setting.
Analyzing any problem with a lot of symmetry is facilitated by using group theory.
Recently, we explore (see our paper on springerlink: A formal series-based unification of the frequent itemset mining approaches) a unification attempt to pattern mining (a popular instance of data mining) approaches by mean of formal series and weighted automata.
An example would be to find algorithms for things like rubic's cube.
In functional programming, the most general and elegant abstractions for problems are often algebraic (or category-theoretic) in nature: monoids, semirings, functors, monads, F-algebras, F-coalgebras, etc.
Regarding your query about modules, neither monoid has an inverse in these applications, in general.
In both of these applications, individual values must be combined together in ways which lead naturally to a semiring structure, with associativity and the one semiring operation distributing over the other.
Although I do not know the details, I am sure that proving that God's number is 20 required some serious group theoretical pruning.
Here are two applications from a different part of TCS.
In a different context, practical solvers for graph isomorphism problem like nauty use the automorphism group of the graph.
Semirings are used for modelling annotations in databases (especially those needed for provenance), and often also for the valuation structures in valued constraint satisfaction.
These tools are based on mappings between monoids and semiring structures.