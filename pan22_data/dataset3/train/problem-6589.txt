The work done in Research & Development departments of the industry is by its definition mostly exploration and so it is not covered in any way by Adam Smith.
Any component developed in the stack has intricacies unlike physical components, and those intricacies have interactions beyond tangible measurement (height, weight, length, etc).
Full stack developers are not expected to do all of the work themselves (they're not intended to be a single pin maker), but they are expected to be capable of understanding all of the elements of the stack and how those elements interact.
At scale, collaboration between team members with different experiences in the same product team can balance context switching and complex interactions.
Adam Smith concerns himself wholly with exploitation and not at all with exploration.
First, the pin factory example (as far as I know) was merely hypothetical; although most modern manufacturing factories can trace their roots to this division of labor, I am unaware of any studies that have actually tested scientifically this hypothesis.
This is a critical part of any significant IT project.
In short, I don't think Adam Smith was wrong, but I do think there are some serious differences between his model of labor division in manufacturing and silos in software development.
At least about scrum and agile I have seen so many variations that the terms have run out of meaning.
Second, Smith was primarily concerned with manufacturing material goods; there are certain tangible outputs associated with material production that do not have similar analogs in software development.
In software development, the boundaries are never quite that clear.
I can do UI changes until some extent: write html, css (as a web developer) and in other hand in some extend provide data to the UI from database, provide it in a service etc.
I don't see full stack really that full as you mentioned, more like a fancy expression like agile or cloud that in certain conditions just have to be mentioned to attract people's attention and the real implementation may vary vastly.
This is important because tangible objects can be replicated through exact repetition; software development is never the same problem twice.
But we have seen that in later continuous improvement stages, which are partly exploitative work, the application of CI/CD can bring similar gains in productivity, which could in some way be probably traced down to Adam Smith by someone very imaginative.
A pin pointer doesn't care how the wire cutter works, as long as the wire gets cut according to spec.
Adam Smith did not need to consider passing of information from one stage to another.
I consider myself as a fullstack developer on the basis of the following combination of responsibilities:
Where I think Smith's work holds true in software development is in the area of context switching (or multitasking); if a single developer is responsible for all areas of development, it takes time to shift from responsibility to responsibility.
I leave testing, architecture and those aside, meeting customers may be added to the working description.
For more on the importance of information passing in IT projects see Fred Brook's Mythical Man Month.
Developers develop common methods to produce predictable results, but you never code the same problem twice.
For example, in pin making, physical dimensions are important as a functional requirement; there's no obvious comparison to that in software.
A full stack team should be comprised of T-shaped individuals who specialize in one or more areas, but understand the spectrum (and may be able to step in at some level).
So a fullstack developer has the significant advantages that:
The opposite for my point of view would be strict roles of UI guys and back end guys.