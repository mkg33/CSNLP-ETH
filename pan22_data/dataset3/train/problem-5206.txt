This allows for incredible leaps forward in testability, allowing for automation frameworks to handle large swathes of regression testing without requiring legions of testers to replay the same levels over and over again just to find out if a systemic change has broken previously working assets.
This really comes into its own when you are suffering from a hard to reproduce problem, you can record simulation inputs and save them to allow automated tests to continually play through your game, over and over, exercising all those same parts that the user does.
Develop your game simulation as a model, and you can swap out a user input device controller for an automated, repeatable testing harness.
It also allows you to measure metrics associated with your game - memory usage, framerate, etc.
It better allows you to alter your View code, safe in the knowledge that changing the rendering timings probably won't lead to gameplay changes.
Separating model from view and controller is invaluable in one very specific aspect of game development often overlooked when not developing at scale: testing.