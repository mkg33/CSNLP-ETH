So... teach objects first and unless you work hard at it, the kids will tend to use an OOP hammer on every problem regardlessof appropriateness.
On your question about "how would you restructure a class"
In COBOL, you might embed the entity and attributes in a copybook, then the methods in nested programs (the lack of scope in COBOL sucks).
The solution seems to be Apprenticeship, which I read that many large companies have adopted, as positions go unfilled and even college graduates do not have enough experience to start work.
Sure, we are creative beings, but there is only one set of traffic laws, and to get around in the world one must follow them.
Understand I'm not a teacher with a class full of kids, so this may be too esoteric of a way to look at the question.
Those who were in classes where OO programming is taught first took longer to produce their first working application, but when there was a working application it was far in advance of what their peers in a functional programming first class are doing.
Objects can be more intuitive than procedural programming for children.
I have seen and built OO programs in BASIC (as in "10 let x=1", not the modern Visual BASIC which is a blending of BASIC and PASCAL).
No one says that you make thesis papers in English by creating your own English: there is a level of "The Given" and then there is the level of "Your Ideas".
Students latch on to the familiar which is usually what they're introduced to first.
The first topic in any course should be History, to answer the "Well, how did we get here?"
We have made a hash of this and constructed a tower of Babel with the many high level languages, tools, frameworks, operating systems, and so on.
1: Computers work because they are deterministic machines.
However I have worked with students at different times from different types of backgrounds.
This started as a comment, but got too long, and I realized I was moving well into answer land.
This completely mixes up syntax and semantics and will boggle most people's minds.
Personally, the challenge I've had with object-late is the side effect of telling the computer how to do tasks: you get used to the idea of telling the computer exactly what to do.
I have seen OO programs written in COBOL (not OO COBOL, which is neither OO nor COBOL).
The mental models which are built around telling the computer exactly what to do are tricky unless you're willing to take the time to push all the way down to the transistor level.
Think about the huge success that MIT's Scratch has had in introducing programming concepts at all ages.
As has been mentioned, people have a wide range of ability to do abstract reasoning, and this ability grows if it is cultivated, but, like the light bulb in the therapy joke, the person has to want to change, to learn to "think different".
In C, it might be a struct in a .h file and a function library.
My first Java teacher started by telling us about how we could create a Frog in Java.
question, which is just simple respect for thinking beings.
My experience is that people do best when given concrete scenarios with understandable steps to take to solve a problem.
I admit I learned functional programming first, then progressed to OO programming later, but that was because in 1975 there were not many OO languages available to a high school student using the school's teletype.
I built OO frameworks in K&R C, back when C++ was mostly an academic novelty.
There is the entity, its attributes, and methods for it to interact with the outside world.
Some ways of thinking are easier to grasp than others.
Perhaps beautiful inside, most people really do not care.
When I was a small child (over 4 decades ago) my persistent questions about computers were:
Xerox had decided that Smalltalk was cute but had no commercial value, so the paradigm appeared dead.
I apparently have an extremely reductive attitude towards learning.
The Justification is simple: this is how programming is largely done these days.
He talked about keeping track of where the Frog is in space, and then adding methods that allow the Frog to jump to other places.
Essentially he seemed to be saying: "Here are your parentheses, now go forth, be fruitful and multiply."
Teach procedural / language constructs first and the kids will tend to write HUGE main functions and static methods if left to their own devices (assuming Java).
You can then add language constructs in your classes.
So I think that instruction should answer these questions conclusively.
They do math and store and retrieve data, basically.
Show that a complex method means that the solution is either housed at the wrong level or not clearly borken out.
If they are taught this from the beginning, a lot of issues that require retraining can be avoided.
Mike is definitely right about the "one size fits all" hammer problem, although I'm not sure when an OOP solution isn't appropriate.
OO is a powerful way to ignore the how until you need it.
At some point you have to admit that you're just telling the computer what to do and you trust that it knows how to do it.
To pick up the basics, all you need is an understanding that "if I tell the sprite to move, it will move; if I tell it to speak, it will speak; if I tell a second sprite to move, the first one won't."
If I hadn't already learned APL, Fortran, some varieties of Assembler, and several BASICs (in reverse order) I would have been lost, and most of these students were lost, and many quit.
Teach to build the logic in the entity's method, and keep the methods very simple.
As a result, anyone learning in an objects-early approach is going to struggle unless there's some benefit to learning to think this way.
Then he talked about creating a Frog named Kermit who has 2 legs, and a Frog named Bob who has 4 legs (assumably Bob is not an anthropomorphic Frog).
Explain to some level of depth about how that is so and how it was developed.
Then you can add an instance variable, constructor, setters etc.
Students need to see what is actually used, how it is used in production in scenarios where they might possibly get jobs.
(We still have these questions and they apply to people as well.)
Everything that people learn should be practical, something that exists outside the classroom.
Whatever the students are taught should be something that they can use in many situations, and as others have said, should not have to be unlearned in order to learn something else.
Thank Heaven that we finally decided to go back to an approach that has worked for 100,000 years!
I'm not a teacher, but my experience is that OO (and other related encapsulation techniques) teach you to write what you want the computer to do, while procedural coding teaches you to write how you want the computer to do it.
We slowly built up the idea that an object can have state, identity, and behavior, without having to resort to hardly any procedural code.
2: Computers are used to solve [these types of] problems in a business context.
This works for people and they can write programs on that basis.
In OO languages, use the languages natural paradigm.
If your course starts with several helpful libraries (like perhaps a sprite-manipulation library), it could benefit from object-early (or any form of early encapsulation).
But giving them a constructed world is not setting them up to succeed after they leave the course.
He then went on to tell us that we could give the Frog a variable so that we knew how many legs the Frog had.
When I've done objects first, start with a simple object - maybe a "greeter" that returns as string that says hello:
You don't need an OO language to write OO programs.
It's actually pretty easy to teach this way, as long as you remember that you haven't taught things like variables and flow of control, and you don't assume the students know more than you've taught them.
Start with the understanding that Object Oriented Programming is a way of analyzing and structuring problems, and is not tied to any language.
They perform useful processes to free humans of drudgery.
When I first learned a fairly pure form of Lisp in college, the professor seemed pretty excited and/or smug that one could create anything at all out of Lisp.
Objects-early teaches you that lesson from day one.
One thing that will vex them is to confuse levels.