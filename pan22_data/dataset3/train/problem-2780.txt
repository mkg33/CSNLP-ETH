Imagine these operators were functions with a return value, and furthermore that these functions were able to modify the value of their arguments in a way that these changes persisted even if you leave the function again.
You could also make it into a separate .CSS file, so if you added more documents it would be reused.
They are compiled into (or in case of JavaScript interpreted as) statements what to do with the variable value.
  <h1>Enter any amount of numbers separated by a comma:</h1>
parseInt only allows integers and truncates all decimal entries, so entering .5,.5 throws a NaN, and 0.5,0.5 returns 0 instead of 1.
That means, on execution, you need one to find a space in the RAM to store the old value (var oldValue), and then copy the old value to that memory spot (= i), on top of everything that ++i has to do as well.
      var nums = document.getElementById("nums").value.split(",");
The reason is actually a bit tricky to explain for people not yet deeply into programming, especially in JavaScript, since it's lacking the call by reference concept that'd come in handy for the explaination.
  <input id="nums" type="text" required="required" />
This would make it where it would look more similar across browsers/platforms.
Either modify your instructions to tell the user you only accept integers or (even better) change to parseFloat to allow non-integer numbers.
There are things you can do to improve your header.
As you can see, the i++ statement needs to store the original value of i so it can return the old value in spite of i having its new value assigned to it already when leaving the function.
Since the third part of a for loop is executed after the loop's body was run, and you're not using the return value of the ++ operator (you want i to be incremented, you don't care what the ++ statement itself returns since you don't use its return value), you're basically wasting memory and run time if you use i++ instead of ++i.
      return Number(accumulator) + Number(current);
      document.getElementById("sum").innerHTML = sumofnums;
The reduce method would be best in this situation:
Because I hope to motivate you to always look under the hood of programming, and it's never wrong to know exactly what you do and why.
Now, with this concept, we can have a look at how the unary operators would look like.
If you go very deep into details of programming with all finesse, amongst all the things that the others have mentioned, always use ++i over i++ if it's the third argument of for loops.
You could use some CSS to improve/customize how your documented is presented.
While ++i increases the value and then uses the new value of i, i++ first uses the value of i but then increases it afterwards.
Comments w.r.t the algo and not the javascript practises: