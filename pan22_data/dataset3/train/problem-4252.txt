There was no material that they had learned up until that point at all - everything consisted of standalone activities that they would learn during the exam itself from texts I provided.
Sure, I could probably come up with 75 or 100 multiple choice tracing questions.
How do you create a final exam that is a valid assessment of an entire year or computer science, but can still be completed in a couple of hours?
(I chose regular expressions, a teensy bit of functional programming in ML, and coding in Java for memory efficiency, but you could do any topics that you want them to learn about as long as you can create or find a good explanatory text)
All things that demonstrate some subset of their skills, but don't require writing a complete program.
I had a rather odd solution to this back when I taught at a school that had no material beyond AP.
Ideally I think a large-ish scale project would be the best assessment of where the kids are.
The advantages for me: no complaining, no review sessions, and they could work on their projects until the end of the terms.
To do that you'd probably have a few of the upper students finishing in 15 minutes.
So, there would be a long explanatory text of some concept in CS that they hadn't learned, and then some simple problems.
In my 2nd and 3rd year courses I normally do a take home project, but I don't think that would work as well in my first year AP-A course.
I figured that they worked their butts off for the AP test, and (especially juniors and seniors) were often burnt out.
A multiple choice section that should take about half the period and a couple of simple coding questions for the other half.
The only questions I would answer were clarifying questions about the exam itself.
They were allowed to ask each other questoins about understanding the text I provided, but not about the questions they had to answer, and they were not allowed to refer to the internet.
The advantages for them: no studying, and they learned a bunch of material in a highly focused 2-hour session.
Teams might make a program, but each coder only does a part.
This semester I only had one student that had to stop because time was up, although a few stopped themselves early because they knew that had done well enough for the average they wanted.
Make sure there are some recursive tracings and it could easily hit 2 hours.
The scope of each problem is small enough that you can grade them, collectively, faster than trying to evaluate an entire program, which will of necessity contain lots of standard code that's really boiler plate - such as the includes.
The other side though is coming up with a coding assignment that is doable in 2 hours.
Problems for you: You have to decide what concepts to test where, and you have to create new questions every term that still test the same concepts.
Rather than doing one large full-on project, do several smaller, focused coding segments that are not complete programs.
Sort of the same issue as the discussion we had a few days ago on students finishing labs quickly.
Use the stated course objectives as a guide and create problems designed to show mastery of the listed points.
Bonus for them: If they choose a career in code, is that they'll find a lot of their professional time is spent doing similar tasks.
Bonuses for you: You can see what concepts seem to have been the hardest to implement and can adjust your syllabus for the next term.
I normally do a hybrid of the two, and it works okay.
I'm not a fan of throwing 2 hours worth of multiple choice questions at students.
I probably should have asked this last week since we just finished up finals today.
So, if their average for the year to date was 85%, and they scored a 50% on the exam (a relatively high score), they would receive a final grade on the exam of 92.5%.
The grading worked like this: whatever their grade average was for the year in my class was theor 0% on this exam as long as they clearly made an effort to complete the exam.
Then, whatever their % on the exam was would be added to their 0 score.