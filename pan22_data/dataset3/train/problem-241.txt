I didn't do this - instead I only merge voxel faces that are exactly equal, including lighting data - but it might be possible.
I put together a greedy meshing implementation for voxel data which includes various attributes (https://www.youtube.com/watch?v=0OZxZZCea8I).
The problem, I would think, would be that you'd be increasing the size of your vertex buffers, thus losing some of the gains of greedy meshing in the first place - and, of course, adding calculation to your shaders.
I understand you're looking to merge voxel faces even when they aren't the same voxel type - but it would seem that the only way to do that is to send the set of voxel types represented by the quad into the shader and then work out the texture coordinates for each point on the fragments by referring to this data and offsetting read from the texture atlas.
Also, if you do need to light the mesh using any kind of baked ambient occlusion, you might also find that splitting up the quads by lighting values is necessary in any case.