Here's a couple recent games that stand out in my mind for having good indicators of tapping.
If the player started tapping the button then stopped before the action was complete, Batman would either stop or, in the case of pulling down a wall, would slowly lose progress on the action.
I think that in "golden days" where were little to none in-game instructions.
Madworld (Wii): Okay, it's not actually tapping but one category of attacks could be repeated a certain number of times by shaking the controller.
When Batman was ready to perform the action, the camera would change to focus on the action and an animated "A" button would show up as a prompt.
A graphical indicator that is reinforced by the game itself works better than the word "TAP" and an arrow.
Kind of random example, but Power Rangers for SNES had a flashing GO with an arrow whenever you cleared an area to direct you to the next area.
To indicate this, the designers put a picture of shaking controller on screen, complete with movement, and highlighted it with "action spikes" (for lack of a proper term, think classic "BAM!"
Here's an example I came across with a bit of Googling that gets the point across quite well, in my opinion.
As mentioned in other answers, older games didn't necessarily have any indicators for this sort of gesture.
The already mentioned flashing "GO" is one of those rare examples.
I'd suggest community wiki for this question, since it's not going to have a definitive right answer
You can add zoom animation on TAP, or make TAP move with the arrow, it's a matter of personal taste I think.
Just because your game is 2D doesn't mean you can't draw from the entire history of gaming to find a solution.
Batman: Arkham Asylum (360): Many actions like removing a vent grate used tapping.
Either way, the game provided direct feedback in response to tapping.
Either this, or just have the finger or a bouncing arrow and an outward-expanding target.
So, I'm not really sure if there is some established patterns for such animations back then.
I think your current implementation is pretty good.