And even the pre and post-conditions are precisely defined.
However, each statement in the language (even the empty statement skip) was carefully defined using pre and post-conditions so that the effect of the statement and resulting programs were precisely defined.
This isn't inherent in using pseudo-code, but the instructor needs to be careful about the use so that complexity doesn't overwhelm understanding.
So, like I said, this heavily depends on the environment and the goal of the course.
The problem is that by teaching algorithms through an actual programming language, you are also teaching the language itself.
Where pseudo code still makes sense is in a scenario where you need a formalised but more abstract language - for example the architectural definition of an instruction set.
Those concepts might be more simply explainable using a pseudo-code that does not require the clutter of a lot of syntactic sugar or other gymnastics.
It is even possible to write a compiler for Dijkstra's language (I've done so, actually), making execution possible.
Something which you want to be able to write a formal parser for, and still retain human readability.
Perhaps students should be required to at least learn to read pseudo-code.
However, the pseudocode needs a firm definition or else it can lead to sloppy thinking.
For example have them write a pseudo code for each other to use a vending machine (1: select beverage, 2: press button, 3: insert coin, 4: repeat until credit=price etc.).
Complex programs have long statements with lots of structure.
Pseudo-code feels like one of those things invented before I learnt to code, as a response to the complexity of reading and to a lesser extent writing code in assembler (or even machine code).
If you are teaching kids at elementary/middle schools, then pseudo code is just not rewarding enough.
Now, code can be written using drag-and-drop templates, or in fairly readable readable language (with beginner friendly error handling) so there is really no need to introduce pseudo-code.
If a student is permitted to make "statements" in the pseudocode that imply, for instance that P=NP, then the statement isn't worth much, nor is the "algorithm" so expressed.
But it isn't a lot easier than using a "real" language.
It is possible to teach algorithms in particular, and a lot about programming in general using a pseudocode.
I'll note that Edsger Dijkstra wrote most of his papers in pseudocode, but it was carefully defined.
This language (pseudo-laguage) can be fairly easily translated into other imperative languages, but it is harder to take advantage of the features of other paradigms such as functional or object-oriented.
David Gries wrote his famous book The Science of Programming using this same pseudocode.
At university level, with years of programming to come, you should use pseudo code - they will need to learn it anyway, and they need to understand the theory without strongly connecting it to one programming language - mostly because all programming languages have their unique idiocy, and it is hard for a beginner to distinguish between the language being weird or the algorithm being complicated.
However, the reason for the language wasn't execution, but precise clarity of expression of algorithms with precise semantics.
The method, if not carefully used, seems to de-emphasize building complex things out of small interacting parts.
When it was impossible to explain a program without recourse to explaining every single term (starting with 'every line needs a number, start off with increments of 10 so you can add more in later'), it made sense to start the explanations with a less formally structured code.
Some algorithms or concept are unsuited for clear expression in some languages (e.g.
Perhaps they should be allowed pseudo-code for exam or quiz questions in those areas as well.
One possible problem with learning algorithms this way, however, is the the resulting pseudo-programs tend to be rather monolithic.