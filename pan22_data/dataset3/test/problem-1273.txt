Even professionally, programmers have to make a snap decision about speed versus robustness, and there are often times that speed is critical and you can come back for robustness.
Using Java as an example (given my handle, you can guess why, but equivalent practices work in almost any programming language), you can design in javadoc and interfaces, then implement the interfaces.
This allows you to follow a complete waterfall methodology (ugh!)
with documentation, yet still code at turbo speed and produce robust code.
Any student that wrote their own heapsort in the middle of a time constrained project should lose marks unless it can be demonstrated that it required less time to build and gave a better result than the facility built into the language.
Unless you have Dijkstra Version 2.0 in your class, I would not expect this to be an issue (but leave the door open for appeal just in case).
Schedules are driven by a number of factors - company cashflow, legal requirements, changing business environment - which have non-negotiable time constraints.