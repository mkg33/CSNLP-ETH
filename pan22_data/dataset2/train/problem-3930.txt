So I'm thinking that maybe I'm using the wrong UVs coordinates. Right now I'm really just parsing the coordinates, and then applying them in the order they come. For example, I have 482 vertices and 559 UV coordiantes, so I just match them in the order they come (Vertex 1 gets UV 1, Vertex 2 gets UV 2...) and then the remaining 77 coordinates are unusued (I assume, I just load them in the buffer and let WebGL do its thing really). 
Consider a cube. A cube has 8 positions but for correct normals it needs either 3 normals per position since each face of the cube needs a different normal. Similarly imagine you had a texture atlas with 6 different images, one for each face of the cube. You'd need different UV coordinate for every vertex per face or 24 UV coordinates.
So I thought maybe I should use those later coordinates instead of the early ones. Like, if I have a vertex with two or more sets of coordinates, use the last one I find while parsing the file. Or maybe I'm just plain wrong, can you give me some help? Thank you
That eliminates the need to create "proper" indices at the cost of more memory usage and some performance.
If you want you can reindex the vertices. As you make each vertex (position & UV & normal) you look in your array of already created vertices. If all three (position & UV & normal) match then you just use the index of that vertex. If they don't match you add the new vertex to the end of the vertices.
You can then draw triangles without indices or create indices in ascending order starting from 0 (0,1,2,3,4 .... Nr of vertices)
What you usually do when you load a .obj file is load all the positions, load all the UVs, load all the normals, Then when you read the faces you need to generate new vertices where each vertex is a position, a UV, and a normal.
I have a simple sphere exported from 3DS Max in .obj format. I noticed that I have more UVs than vertices. I parsed the file with a simple program I wrote and then I put the various vertices and UVs coordinates and indeces in WebGL buffers. The result is that the texture is mapped to the sphere, but it is highly distorted. I tried using differend UV unwrap methods, but there still is a lot of distortion, all over the model.
Easier way to bypass the different (position,uv, normal) count is to take all triangles and to generate 3 individual (position,uv,normal) vertices.
To create proper indices for this you need to find unique shared vertices. This case has none and the vertex buffer will look something like this: