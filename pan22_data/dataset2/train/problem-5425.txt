You can avoid the busy wait by using a flag.  This can be a simple one-row, one-column table.  This flag is checked and set by both jobs like this: each job reads the flag.  If it is set the other job has finished and step A8b can process.  If it is not set, set it and end.  Job A will need a new step at A7b to do this; job B will do this as its last step.  If the flag is set job B can start A8b by using sp_start_job.  You'll have to fiddle with A7's statements and "On success" / "on failure" actions to get it to work.  You will need a new step at the start of the whole thing (A0) to ensure the flag's correctly set for each run.
A simple approach would be to split Job A's step 8 (let's call them A8a and A8b).  A8a checks B's status from the msdb tables and does a waitfor delay if B has not completed, or stops if B has errored.  This gets a bit tricky in restart scenarios, or if history gets purged from the tables before A8a runs.
So, my requirement is, i want to add one step before step 8 in that i want to check the status of job'B' when job'B' is completed then step 8 should start else it should not start and it should wait till job'B' completed
Effectively you've split your stream into 4 by doing this: A1-3, A4-7, B* and A8-10.  It would be cleaner to set each up as a separate job, have A3 kick off both A4-7 and B* and then do the "is the flag set" thing at the tail of each of these parallel jobs before starting A8-10.
If you are looking for something more robust there's a product called  Tidal enterprise Job scheduler from Cisco. It has a lot of features integrates with sql, db2, oracle, windows,unix, etc.
Of course the real solution is to get a decent scheduler.  Other posters have listed some 3rd party ones.