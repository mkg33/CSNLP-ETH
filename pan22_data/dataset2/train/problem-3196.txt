There is a difference between <> and "" in #include. First one searches in default places, e.g. include folder for standard library, stuff specified to compiler by build system, etc. The latter relies file system. Now programmer is dealing with it directly. After learning cmake I never write those. So this point serves double duty to point at using <> and having a CMake or similar build script always.
Never write using namespace ... in a header. You're forcing users of your library to do something they almost certainly don't want to do.
Don't pass strings by value. Pass them by const reference (to avoid making copies) or pass them as std::(C++17) (or boost::) string_view. This also doesn't force the caller to use an actual std::string, a string_view being easily constructed even from a char buffer.
Storing inputs and outputs is not that efficient in my opinion. I believe std::array<> or std::vector<> would be good. Though for shunting yard probably none of those will be useful, since probably the algorithm will operate on a string.
std::endl is not a portable way to print a newline (it doesn't only print a newline). It can incur detrimental performance drop if used in a tight loop, since it is equivalent to << '\n' << std::flush. Optimal flushing is important because it is usually very slow (between ABI boundaries, to the hard drive, etc).
I think this design is very fragile. I'd write something like infix to postfix notation converter and evaluate the result (aka perform shunting yard algorithm). 
Personally, I would ditch the class. May be other component might need to be made class, but this one doesn't seem to be so.
Don't mix responsibilities, separate user input from the rest of the code. Using std::cout in your class quickly becomes wrong when you change the user interface to a graphical one, or if the code ends up in a server application that only responds to network requests.