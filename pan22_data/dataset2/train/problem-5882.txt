(I tried flushing the plan in Instance Two and running the query again and got the same plan as before. I don't have another instance with such an anemic configuration. However, I looked at a third instance, and it got the better plan but has more cores and RAM than these two, so I don't know that means anything.)
Plan (Instance One, 27792 rows in sysjobhistory, https://www.brentozar.com/pastetheplan/?id=ryKHl2Bwm:
In terms of the data, the two instances have the same jobs, job steps, and schedules, but one of the jobs is disabled on Instance One, so it has fewer rows in sysjobhistory. There is a significant difference in stats and execution plan for the query, with the instance with less data getting a worse plan:
I executed the following locally in SSMS for each of two instances of SQL Server 2012 SP4-OD (11.0.7469.6) that live in separate Azure VMs and get very different execution plans:
Why does Instance One get the hash match instead of the more efficient nested loops in Instance Two, when both plans are using the same indexes? Is there a way to force Instance One to use a different plan without changing the query?
This is by design. You can get a different plan due to hardware differences, stats differences, data differences, configuration differences, and so on. Suppose you upgraded your server to have 1.6 TB of RAM instead of 16 GB. It would be disappointing if SQL Server used the exact same query plans with the new hardware as it did with 16 GB of RAM, right?
Sure, you can use a plan guide if you refuse to change the query. With that said, when I see an elapsed time that's 50X-80X greater than CPU time I don't immediately think that there's a query plan problem. To me, that looks like a problem with hardware or with the load on the server. What do your wait stats look like while these queries are executing? For the query with the "good plan", does it really take 17 second to spill 383 pages to disk? Frankly, those queries are doing a tiny amount of work and it's crazy that they're taking 17-90 seconds to finish.
They seem to both be identically configured in ways that the optimizer cares about: Standard A2m v2: 2 vcpus, 16 GB memory.
Plan (Instance Two, 38391 rows in sysjobhistory, https://www.brentozar.com/pastetheplan/?id=rklbW3Hw7
Instance one either did not consider the nested loop plan during optimization or there's something different about the hardware/stats/etc that gives the nested loop plan a higher cost than the hash match plan. When I have questions like this I use query hints to force the plan that I think SQL Server should have picked and compare the overall costs and the costs of individual operators. That usually provides a lot of clues as to why the query optimizer picked one plan over the other.
However, MaxMem is 12000 for Instance One (it is only using 2726 currently according to the Processes tab in SentryOne) and only 4915 for Instance Two (using 4991). The instance using more memory gets the better plan, but the other one has more memory available. The disk setup on Instance Two is better, so ignore the elapsed times and just look at the CPU times and Logical Reads counts.