The point here is that there are many methods of handling the exchange of data between different components, but believe me when I say that if you can keep your components as decoupled as possible, the ability to maintain and mold your game from iteration to iteration into something bigger and better will be far easier for you. 
Is there any reason that your solid implementations of these concepts cannot inherit from both of them ? Say for example, you had a Ball entity. It would be both a ISpriteEntity and a IPhysicsEntity. The Ball could then be acted upon by both a physics engine, and a rendering engine, for example PhysicsEngine.Update(IPhysicsEntity) and RenderingEngine.Draw(ISpriteEntity). This would separate the concerns nicely.
How two components (what you call SpriteEntity/PhysicsEntity) is often something that drastically varies between implementations.  Some developers prefer the message/event approach to keep everything absolutely decoupled and not aware of the world outside it's purview of purpose.  Others often decide to expose each other through carefully well defined interface classes to minimize the exposure of one component to another.  But component systems always face this same problem of shared data exchange.
What I dislike here is that the SpriteSystem which manages my SpriteComponent objects now has complete knowledge of the PhysicsComponents.  It also implies that there is most likely some dynamic_cast<> going on under the hood because you probably have a simple hetergenious list storing your components which isn't ideal for performance.  It's obviously a pre-optimization no no but dynamic_cast<> are often things I avoid particularly if it's in code that will be executed often in a loop.
The above example demonstrates reactive updates.  If you would have rather done proactive updates instead, possibility minimizing the number of sprites to update each pass and the number of physics system calls, you could easily have your physics system check whether a physics component's position changed since the last frame.  If it did, send an event/message indicating the entity id and new position.  The sprite system could cache those events for when it updates and it would have looked like this:
My preference has always been to separate data and logic when it comes to systems like this.  A very trivial example based on your two components would be:
Neither of these objects should inform each other at all, from a purist perspective. What should happen is probably something like this:
You want text to collide as well ? Well your text objects would also implement IPhysicsEntity and contain information about its size and position. The physics engine would update all IPhysicsEntitys irrespective of what concrete class they actually are.
This is a clear separation of concerns. The physics don't care how the data is displayed on the screen, and the display doesn't care how the object being displayed interacts. 
In this example, I am deriving the two components from a parent class but nothing in dictates that this is necessary.  It makes it convenient if you wanted to store these two components in a hetrogenious container but also allows a means to store common API methods between two different component types too.
The great part of this design is that you can clearly see the system dependencies because we use constructor injection to represent them.  This helps knowing how to order these systems in the update loop so that all your state changes remain consistent in each iterative loop.  
Some may be fine with such a solution, but now if that PhysicsComponent's interface changes, I impact the SpriteSystem.  One could argue that you cuold abstract that away and subclass PhysicsComponent from a IPhysicsComponent to avoid that probability, but it still doesn't hide the fact that my sprite system is directly dependent on the existing and exposed API of the physics component itself.
You should keep them separate, yes, a sprite has nothing to do with physics, even if your physics get information like size from the sprite. You could have a CollisionComponent with that information, or maybe a SizeComponent that both sprite and collision can access. I would recommend the CollisionComponent having the size on itself, so you don't actually need a Sprite at all. You will still need to share the position, which brings to the next point: Sharing the data.
The Ball itself would contain the information about its size (height, width etc) rather than relying on the sprite to determine its size. The sprite is just a visual representation of the data behind it, it should not be the data itself. You wouldn't base an objects behavior on the sound it creates, so why do so for the vision it creates ?
It would also allow your game to 'work' without having a rendering device, say for example if you were running a dedicated server (where there is no need to render anything), the Ball would still have its position and velocity updated.
Now if you wanted to get the position from a physics component, you could do it like the following by using your entity class as the mediator to lookup the needed component reference:
I would say that separating out the physics from the sprite is the best way to go. It would otherwise violate the single responsibility principle of the class.
I think using systems is a much better approach, but there's nothing wrong with a direct pointer or messages, it's a matter of what makes more sense to you.
Sharing the data is a really difficult question, to which I say it depends. In my code I have systems, they are the ones with logic and they can access more than one component, so a physics system could access the SpriteComponent and get the size (probably with no need for a PhysicsComponent if every object is going to act the same.) In your case, since you didn't mention systems, I'm assuming your components have a pointer to their owner entity, you can simply do something like:
Which is fine for a simple game, you can also make a message system, so your components don't actually depend on other components, they can simply receive and react to generic messages.
If we were to consider some slight changes, where entity doesn't actually exist as a class but rather an identifier that categorizes a subset of components across systems and we make a rule in the sand that systems talk to systems and components talk to systems, we've now added that layer of indirection.  Combine that with well defined interfaces and you could get something like: