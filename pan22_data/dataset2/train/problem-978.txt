So they are tackling a front-end programming assignment in a way that reflects the reality of the majority of front-end programming. Getting this stuff right or wrong can make the difference to the viability of a product.
For your dilemma, I think the solution is for  you to provide the view and at least a framework for the controllers (event handlers). Then, if you want your students to learn programming in general, and not just making things pretty, then have them supply the model so that it fits within your framework. 
One way to provide the entire framework is to imagine some empty model that the controllers talk to via accessor methods (to get info to be displayed) and mutators (to update the model when something changes). These can provide default information in your framework and be updated by the students along with their model. Your View won't show much that is interesting until the students provide the backbone, of course, but it will force them to focus their efforts there. It will also give them good habits of separating concerns in programming which is a valuable skill even outside MVC. 
This way you shouldn't have CSS questions beyond 'what class to use for a large button?', which can be answered from the documentation, and it won't be very far from what happens in the real world.
In a "Programming Languages" course I used to teach we had a generic rubric for programs: so much for correct answers for the examples provided with the homework, so much for other test data. Then general criteria like reasonable split into functions, good use of language facilities (use a dictionary and not a list if you want to search for a datum), reasonable naming, enough (not excessive, informative) comments, ... This was published beforehand.
The correct way to program in such a system is to rigidly separate the three kinds of components so that a model has no knowledge of how it might be viewed. 
On the other hand, user interface design is a very important topic, but its implementation and thought processes are quite different from what it takes to do model building. But it also takes a study of things like Psychology, so may be best to isolate it from an early course. 
I'll have to admit to not actually using Windows Forms Programming, but MS seems to indicate that it is a variation on Model-View-Controller (MVC), in which an underlying model is viewed by one or more Views and controlled by one or more Controllers that connect the Model to the Views. Other systems, such as most of early Java GUI programming fit the same model. 
I feel that there is a little bias at play here. In addition to all the answers above, I'd like to mention that you feel that tweaking UI is a waste of time. That's because you inherently feel that such tweaking is off-topic as far as your course is concerned. 
Answer because I am not registered to make a comment (and am not going to so please do not implore) Yes, we did actually teach months of fundamentals, beginning with Console mode programs, before reaching Windows Forms and then ASP.Net (Web Forms).
I agree with the recent answer that says that people want (even unconsciously) to distinguish themselves. Fair enough. But there are more programmatic changes that can be made, instead of only colors and sizes on the screen. Just getting the bare Bootstrap to render properly is actually difficult, and an achievement in itself. In the "real world" (hopefully not like the "real world" that Morpheus showed Neo) someone else will probably be doing the visual design, and programmers have their hands full just getting that to render correctly, on everything from a phone to a wall-sized screen, using only Bootstrap (or whatever).
But, having been a programming student for decades, a Teaching Assistant grading the code of novices, and a professional programmer working with colleagues, I can assert positively that everyone's code will look very different, and two programmers will write quite different solutions, even if they function and look identical.
As a possible solution, how about tasking them with manipulating the UI so many times, and with such complication that the changes begin to become difficult for them to tweak manually. That is when you show them the beauty of doing things programmatically, and by that logic, how back-end operations work.
One effective way is to state beforehand exactly what will be graded, perhaps give an example of bare-bones "enough" solution. You might go so far as to announce that "bells and whistles" will be penalized.
If you are concentrating on some programming technique/data structure, use the idea used e.g by ACM-ICPC: Data are standard input, spartan format, no validation required; output is standard output, simple, rigid format. A nice plus is that the running on sample test data for validation is much simplified (no TA clicking madly and typing the same junk over and over into dozens of programs).
However, isn't software development all about the complete package? While everyone from your course may not go on to become full stack developers, what they are striving for now - perfection - is actually something that will help them out later.
Yes, it does. Front-end detail is time consuming. For our (commercial, not pedagogical) projects, we have a project-wide CSS style based of a company wide SASS styles merged in with bootstrap or other frameworks. That saves us a lot of time and makes our various sub-sites consistent.
As a simple example, you would think that Morse Code going out over radio would be the most machine-like and identical thing, but it is not. Every human being sending Morse Code with a hand key will sound recognizably different (speaking from long experience). Even different semi-automatic keys of the exact same design will sound different, and further, many electronic means of generating 'perfect' code will sound recognizably different! I have participated in contests and known from just a couple letters that I had already contacted someone that I could hear again later on, so different was the sound.
I'd suggest you create a CSS for your students, and tell them to use only classes defined in it, and no other styling. I'd base it off a bootstrap theme, which can be configured using something like https://pikock.github.io/bootstrap-magic/app/index.html#!/editor .
One example that still makes me cringe was a database homework asking for a simple query to a preexisting database under IBM VM/CMS. Doing the query was a few minutes, students spent literally days tweaking the UI in the bletcherous environment offered by the text-only terminals.
Alternate solution would be to link the algorithms that you're teaching, ergo, programming concepts, into UI. 
There are lots of ways to distinguish oneself, and to me as an Instructor, the style of students' code, their idioms, how clear and understandable it is... are all as obvious and unique as the nose on your face. No need for applying makeup to your screens.