the context of the assigned namespace - so they won't appear if you run a naked ip link as this is run in the context of the default namespace.
Anyhow, I found this post searching for how to do this, thanks for the Q&A guys, and hope this helps anyone else finding this post in the future.
I think one should also look at network namespaces, done with iproute2's "ip netns". This also takes some extra interface and routing magic, so might not even be less complex than the massive iptables hoopla in the other answers.
Now use iperf to test throughput. Bind to the correct IPs, and be certain which IP you're contacting (the other end's fake address):
Unfortunately, the iptables approach was non-intuitive and fraught with issues.  After a few frustrating hours, I abandoned this plan of attack. Inspired by Thomas's suggestion, I did a little homework on Linux IP Namespaces and began to appreciate the simplicity and elegance of this solution. 
I had a similar situation: a single machine with two enet interfaces. My plan was to use one interface as a server (receiver) and the other as a client (sender). Each interface would be attached to the router and iperf would drive the traffic through the router to measure throughput, PPS, delay, etc.
Comments definitely welcome if anyone found something useful with these - the how, the what, the where about your implementation.
I successfully used the following on Linux to test throughput on a new dual-port 10Gbps card in "loopback" mode, that is, one port plugged directly into the other. This is all just a bit of voodoo just to force packets out the wire, but if you don't, Linux will just short-circuit the traffic through the kernel (hence the OP's question). In Casey's answer above, I'm not sure if it was really necessary to have an external router or not above, but the following is completely self-contained. The two interfaces are eth2 and eth3.
Check this article. Here the detailed steps is mentioned for enabling internet access to a virtualbox vm using NAT forwarding.
The interfaces will be reassigned to the default namespace and all configuration done within the namespace disappears (e.g. no need to delete assigned IP addresses). 
A lot of stuff to go through here, so I can't totally guarantee my accuracy, but the original question seems to be looking for what's known as "send to self" technique. Linked search shows what I think is the best maintained kernel patch as top link + discussions and patches with other approaches on various mailing lists, esp. LKML.
As always - I'm a little late - but nowadays one could use network namespaces to isolate the interfaces and prevent any local forwarding (and fiddling with iptables :)). 
Now tell the system how to get to each fake network, and prepopulate the arp entries (be sure to substitute your MAC addresses, don't use mine):
goes out eth2, the source IP 10.50.0.1 gets NATted to 10.60.0.1, and as it comes into eth3 the destination 10.60.1.1 gets NATted to 10.50.1.1. And the reply takes a similar journey.
Next we'll set up a double NAT scenario: two new fake networks used to reach the other. On the way out, source NAT to your fake network. On the way in, fix the destination. And vice versa for the other network:
Below is a list of the exact commands that I used to configure my Fedora FC26 to serve in this capacity. The two interfaces are enp1s0 and enp3s0. The router has two interfaces with addresses 192.168.2.112 and 172.16.16.2. Each FC26 ENET connector is directly cabled to the corresponding router interface.
The traffic will now be send via the  physical interfaces as the whole networkstack, interface, routing ... is isolated by the namespaces so the kernel is not able to match the addresses used within the traffic with local (available) interfaces.