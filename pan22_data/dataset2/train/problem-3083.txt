I want to post an answer. I decided to go for a flexible solution to achieve the following features:
What I did: Abstract calls to d3d11 immediate context by a DrawCall struct that acts as a gpu command recorder. A call to DrawCall.SetIndexBuffer will create a c# Action that will issue a call on the ImmediateContext upon invoke call. The DrawCall internal gpu command list is sorted the following way: set shaders, set constantbuffers, set blendstate, set stencilstate, set vertexbuffers.... I am using sharpdx and c#.
Should I implement a chained gpu command for multipass rendering or are there better ways to handle such effects?
The goal: issue least calls to d3d11 ImmediateContext and render advanced effects like toon / outline / anything that requires rendering the same vertex buffers with at least two different vertex shader and pixel shader programs efficiently by sorting opaque drawcalls front to back and transparent drawcalls back to front.
My problem: I use a 64bit sortkey for my gpu commands. When rendering complex effects like outline or anything that requires state changes to outputmerger the whole idea with sorting doesn't seem right... example: I render opaque objects first and then transparent objects... I want to render an object opaque with a diffuse shader and it should have a red transparent outline. For this effect I have to modify stencil and blend states in between drawindexed calls. According to my sortkey those gpu commands are on different draw loops opaque<>transparent but the stencilstate requires both drawindexed calls to be one after another.
So far it works great and I can make quiet some effects with it. For my intended use I only use immediate rendering with basic lighting and no multithreaded drawcall collecting, because my scenes are well below 2k objects. Another bonus I do is sort my drawcalls also by distance. for opaque objects I use front to back sorting by camera distance to reduce overdraw aka running the fragment shader unneccessary for objects that will be overdrawn later. For transparent objects I sort back to front to achieve maximum overdraw, otherwise transparency with additive blending doesnt work. there is a good nvidia article on blending and in khronos group wiki also (tldr: transparency cant be achieved exact in realtime, thats why we do it approx by sorting objects back to front).