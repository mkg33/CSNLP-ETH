If you keep all objects on origin, and instead you reassign the VERTEX POSITIONS to new positions, all the vertices in the graphics card will be the same because no different roundings from different obj positions: all obj positions and mesh positions to the graphics will be the same and there will be no errors. 
You may want to reconsider the use of terms like 'mistakes' and 'imprecise'. They do exactly what they're told, and floating point arithmetic rules are deterministic. Misuse, operation ordering or misspecification of what you tolerate is what causes problems, not spurious cosmic rays that mutate results.
When it comes to the XZ grid of terrain chunks, you can often organize your computation of grid positions such that they perfectly agree when you move chunks around. When transitioning between LoD levels, most techniques apply skirts or a spreading-out pattern along the edges to avoid T-junctions and the interpolation differences those have.
Fabien Giesen mentions one of these rules in his article series on the graphics pipeline, cited here:
This requires that your vertices (and thus edges) are exactly coinciding which is not a problem inside individual meshes and terrain chunks.
Because the further an object is from origin, the bigger mistakes occur in single precision floating point maths, obj positions are rounded and sent to graphics card, and their vertices are different in graphics card, even if they are whole numers and mathematically and logically the same...
Modern graphics APIs are very careful about specifying how rasterization of triangles that share edges will be done in order to avoid overlapping fragments and missing fragments.