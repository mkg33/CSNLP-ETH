You could alternatively use a perma-temp table.  That is a real table, but your process empties it each time it uses it.  Again, that table is visible to other instances of your process, so you may have to tag the data appropriately.
Alternative approach for pre-SQL2008 is to use a CSV splitter. Jeff Moden has carried out exhaustive testing of various approaches to this.
http://weblogs.asp.net/jgalloway/archive/2007/02/16/passing-lists-to-sql-server-2005-with-xml-parameters.aspx
If you aren't using SQL 2008 or higher then you'll want to pass in the values as an XML document, then use xquery or OPENXML to parse the XML document and put the values into a temp table (or table variable depending on how many values you expect).  Then use the temp table as part of an IN within the WHERE clause.
You could populate a temp table prior to calling the proc, and reference the temp table from inside the stored proc.  Temp tables are persisted as long as the database connection from your process is open.
If you are using SQL 2008 or higher you can use a table valued parameter which would allow you to pass in what is basically an array from the .NET side then use the table variable as an in clause an Nick has said.
If connection pooling is causing issues, you could try creating a global temp table (e.g. ##MyTable).  The caveat with that is the table is available to all other processes, so you need to make the name unique to your connection if more than one process will be using it concurrently.
Getting table valued variables into sprocs from client libraries wasn't possible the last time I looked, although that was quite a long time ago and may have changed.  You can write a splitter that takes a string and splits it up, populating a table variable with each item in the list.  Then join the table variable against whatever it is that you're querying.