Your "script" component might be useful on its own, either to implement this player control or do handle other one-off or game-specific logic that doesn't deserve its own system or module or component or whatever you're using. 
Not everything in your game must be based on the ECS pattern you're using and the game logic might be a good candidate not to.  
Whichever way you implement the game logic, it has to be aware of the ECS: it has to identify (for instance) the player entity (by either a unique-id assigned to it, or by looking for entities with a dedicated Player component as you propose) and most of the logic will result in setting some component properties or calling ES methods to obtain the desired behavior.
I usually represent the player as a thing that gets a reference to some controlled entity, and recieves actions representing the (human) player's requests from the input system. It interprets those actions according to whatever logic the game needs and makes the appropriate changes to the referenced entity. It's not a "system." It's just what it is. There is one of them (usually), and it just sits in the main Game class the whole time.
Or, as you mention, you can implement the logic as a system not to "pollute" your main loop with different classes: this game_logic_system, during its update phase, could callback on script(s) or implement the logic in a more hard-coded way, or via plugin, configuration file, etc... 
You could just as well implement it as a component you attach to entities, owned by a "system" that collects player input and feeds it to every component. Letting the player drive multiple entities, if that's what you really want. 
You don't have to (and should not) try to shove everything into the "entity component" model. That just creates the same basic shape of problem you have when you shove everything into the "inherit all the things" model: you've just swung the pendulum the other way.