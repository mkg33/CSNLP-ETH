Therefore, you are going to want to compute the rotation yourself, not delegate it to OpenGL. My recommendation would be to actually change the configuration of the cubes — that is, change xPos, yPos, and zPos according to the rotation. Since you are only doing 90° rotations, this is especially simple. This means your collision tests do not have to think about rotations.
What you aren't showing is how the cubes' falling translation is applied. From your description of the effects, it is occurring after the rotation; so you are either translating in ->draw() or updating the yPos etc. coordinates. The "graphics" fix to your problem is to apply the falling motion before your glRotate.
(If this does not seem to be an appropriate answer, then please update your question with details of how you are animating the falling.)
However, this would be setting yourself up for bigger problems. You are eventually going to want to collide your cubes against the rest of the objects in the playfield so as to know when to stop them and remove rows etc. Just rotating in the rendering isn't sufficient to handle that.