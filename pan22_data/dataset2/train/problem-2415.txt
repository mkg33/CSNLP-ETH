Lastly, you probably shouldn't print the output as a bunch of headings. That doesn't really make sense, semantically speaking; they're not headings. A list, however, would be a good fit. Better yet, an ol list will automatically be numbered from 1 and up, so you only need to print the fizz/buzz text.
Since any function creates a local scope for your variables and functions,  you can have your own Element. It'll still shadow the global, built-in one, but it won't walk all over it.
The mapping will return either a name or undefined. And undefined values become empty strings when joining. So if there are no matches, you'll end up with an array full of nuthin' that'll join to an empty string, and it'll fall back to i instead.
Then again for something this simple - basically a container to two variables - you could just get away with an object literal:
The element and fizzBuzz constructors should, by convention, be named with PascalCase. So it should be FizzBuzz and Element - except that Element is a native constructor. And redefining a native constructor will only lead to trouble.
          <input type="number" class="form-control" placeholder="How often {{item.word}} appears" ng-model="item.frequency">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet" />
You could handle the list expanding/contracting without regenerating all the elements, but.. eh'. Simply adding and removing input directly is more direct.
There's a lot of it though, making it a hard to skim. To get a good look I copied it to my editor, and basically add more whitespace to separate things. In general, you seem to skimp on whitespace (both in markup and JavaScript) a little too much for my tastes.
Finally, while I don't know Angular, I have a feeling that fizzBuzzCount should be a property on the model, not the controller.
Then there's the main event, generateFizzBuzz. I'd consider working on a copy of $scope.model.elements; when you sort it directly, you also end up sorting the UI used to create the elements. There's no real need for that, and maybe a user would be confused by the input having been swapped around. So you could instead do:
You can sort of get around that by putting your constructors inside the function used to define the model and controller, like so:
Very nice. I can't really see any major issues here, just some nits to pick. Note, though, that my knowledge of Angular is near-nil, so perhaps there's something there that someone else will be better equipped to comment on.
Still, it'd probably help your readers (and you), to add comments by major close tags. This isn't something I usually do myself, but in this case the structure is so dense (that's Bootstrap for ya) that it makes sense.
          <input type="number" min="1" class="form-control" placeholder="Number of iterations" ng-model="model.count">
Also, I noticed you've got an id attribute on an element that gets repeated by Angular (inputElementFrequency). So, in turn, you end up with duplicate IDs. IDs are meant to be unique across the page, but it's up to you to maintain that uniqueness; it's not enforced by browsers. However, the expectation/assumption of uniqueness is very real, and duplicates can cause all manner of confusion.
I've tried some stuff below. I've skipped the accordion panels, just to keep it simple, and the thing will stretch to 100% wide (didn't bother with columns).
This isn't about the code itself, really, but I'd probably prefer a solution where I can simply click to add or remove an "element", instead of having to regenerate a fixed number of inputs. When the list is regenerated, it also removes whatever's already been typed, so it's a hassle having to re-input everything.
In practice the result is the same as your current new element("Fizz", 3): You get an object with a name and a frequency property. And you can do the same for fizzBuzz of course.
          <input type="text" class="form-control" placeholder="A word to print" ng-model="item.word">
By the way, you don't need to muck around with toString; a number will end up as a string anyway. Besides, the way your fizzBuzz constructor worked, you didn't need the anyMatches check; your constructor handled that for you.