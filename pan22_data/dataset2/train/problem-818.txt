On Linux, I've used fabric (fabfile.org) and capistrano (capify.org) which are automation tools to assist in remote SSH and SCP commands.  If you have Cygwin installed on your windows hosts, you should be able to reuse these as deployment tools.
When the deploymenet went off, the self-extracting zip file was transfered to the server where it was launched. All of the files were extracted into the correct directories and the DBA ran the stored procs on the prodcution database. 
I agree with Scott that this can be very complicated and easily overlooked. Deployment strategy is very application specific as well. If your app is completely self contained in one folder it might be easier than an app that references the GAC. Which in turn might be easier still than a server that needs to maintain multiple versions of an app that references multiple versions of assemblies the GAC. We don't want to get started talking about policy files here :).
On the day of deployment for a project, we would use an nAnt script to pull the projects from SVN, do a custom build of the projects and pulling any dependences that these projects needed. Once the nAnt script was run it was packaged into a self-extracting zip file. Stored procs that were associated with this deployment were checked into the source control and an excel spreed sheet was updated with the scripts to run and in which order.
Personally where I work we just do an xcopy-style deployment, but I'd eventually like to just hand a package over to the server group, giving them the control in when and how it is deployed. (I think this might also makes it easier to do mass deploys using something like group-policy, but I'm not too familiar with that)
Having said all that combining the Microsoft Web Deployment Tool with Application Request Routing is one good option. In IIS7, it's possible to create install packages using the tool. It is also possible to point the tool to a web application and backup the entire app into an application archive folder. You can then deploy from this archive folder to an IIS6 or an IIS7 web server (IIS5 not supported). I would use application request routing like Scott suggested to separate live from test websites. Once you've verified the newly published website is good, you might set ARR to route to the new version.
On a typical deployment using this system, we went from a five to six hour deployment to under an hour or less.
All of our source code and stored procedures were stored in SVN. Each night, a database job run and pull the production stored procs and slip them into a directory on SVN so that there was always a most current version in the source control. 
The other answers covering your larger question are good. I'd also add that you should look at several open source web application projects and copy the build process you like most.
This basically creates an MSI installer for your .NET application. This example is for VS2005, but I have VS2010 and the project type is still there. This can give you a lot of customization if you need it, or just the basic installation if you don't.
"Publishing" a web application in Visual Studio can be run from the commandline as msbuild "C:\proj\yourprojectpathandfilename.csproj" /deploydir:"C:\some\deploy\dir". The destination directory is a deployable web application.