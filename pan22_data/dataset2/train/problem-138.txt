The solution is very simple, wrap both your Channel and the Message together in an immutable object and place it in a ConcurrentLinkedQueue. This will solve both of the aforementioned problems. The way I see it being implemented:
My problem is multiple producers and single consumer where multiple producer threads will call add method to populate my CHM map. And then I have a single background thread which is my consumer which will read data from this map and work on multiple channels in parallel.
From what I understand, you are creating a lookup table (cache) that creates new entries if they do not already exist. This isn't necessarily a problem here, but I think that you have needlessly created a complicated tree of entries that can be vastly simplified and in fact not have to create a new linked queue that might be thrown away if the method loses the race.
For each Channel, I will have list of Message object and I want to process all these channels in parallel. And that is why I am using thread safe data structures ConcurrentHashMap and ConcurrentLinkedQueue. Here Channel is an enum in my code.
As I have interpreted your code, you seem to want to discard the current current hashmap and populate an empty one every time you send all the messages. However, the problem is that whenever you decide to sendAll, you must iterate over the entry set of a map that will be discarded. You may still maintain a reference of the discarded map whilst you are iterating over the weakly consistent entry set view. This means that you could have discarded the old map while still adding entries to it, and your iterator may not see those entries because it is weakly consistent.
In the same class, I have a background thread which runs every 30 seconds and it calls sendAll method which processes multiple channels in parallel so basically idea is I want to send every 30 seconds whatever is there in the map.
I have a below class in which add method will be called by multiple threads to populate messageByChannelReference concurrent hash map in a thread safe way.
Is this the right way to execute multiple channels in parallel? Let me know if I have missed any thread safety or any race conditions in my code.
I don't need to block in my case, if queue is empty, I will return back and start again after 30 seconds. Right now I have a Void on callable but I will change that to Boolean in future.
Side note: I embarrassingly became confused due to the lack of computeIfAbsent before I realized that you needed to use Java 7.