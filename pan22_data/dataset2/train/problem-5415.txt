You should multiply the normal with the inverse - transpose Model matrix since if your Model Matrix is not an orthonormal matrix you would get incorrect results if you multiply him with the normal. Also the code will work only if your bufferMatrix contains only translation information and not rotation or scaling.
I think I realize what I need to do mathematically, which is getting the dot-product of the vertex-normal on to the view-to-vertex vector. That is mathematically speaking, another is to do it in GLSL with matrices etc.
I am bad at debugging GLSL code, but right now the lightColor is always 0, no matter where I look at the model from.
The base is copied code from a 'phong' shader - that works!.. I have tried everything I could think of, as well as searched google for quite some time.
Keep in mind that a direction in a 3D space is defined by X,Y,Z components, so it is better to have the W component as zero when you normalize or calculating the length of the normal ( or not use it at all as in the code above ), otherwise you will get incorrect results.
The easiest think to do is to pass as a uniform the position of the camera in World-Space and calculate the direction from the vertex to the camera and then calculate the dot product between that direction and the vertex normal.
This is my vertex shader so far, the fragment shader is simple as it just multiplies the lightColor with the texture: