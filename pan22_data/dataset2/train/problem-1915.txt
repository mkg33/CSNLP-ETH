            filter = $"{suggestedFileExtensionName ?? string.Empty}|*{suggestedFileExtension}|" + filter;
Now we wrapped MS code in interfaces that we want to test.  For unit test you can now have a mock of both ISaveFileDialog and IWriteFile.  
    public bool Save(string content, string suggestedFileExtension = null, string suggestedFileExtensionName = null, string suggestedFileName = null)
While this works, I'm struggling to refactor this class to allow for unit testing as currently there's no way to mock/stub the Microsoft.Win32.SaveFileDialog - have I missed a trick here? Or is there genuinely no nice way to unit test this and I should be relying on integration tests?
But I would like to keep them the way that they are because I would like to avoid catching all exceptions and I'm using a Visual Studio plugin to help me manage exceptions and it complains when using the second option.
I think you are unit testing the wrong code.  You should be looking to unit test your code and not Microsofts code.  It's a good place to write interfaces around their code for testing so you can switch out MS code with your own test implementation.  You didn't show what your interface looked like but I would suggest that if you want to replace SaveFileDialog then you should have an interface just for that and not also have SaveFileDialog also write the file. 
The following class is a wrapper for Microsoft.Win32.SaveFileDialog. I've implemented the usage of Microsoft.Win32.SaveFileDialog this way because I'm using the ISaveFileDialog interface as a dependency throughout my code base.