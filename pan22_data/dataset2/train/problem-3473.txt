Nested virtual machines are possible with VMs that are purly emulated (e.g. Bochs), but Virtual PC and and VMware use some hardware support that is not designed for nesting.  
The VMXON instruction that "turns on" the CPU virtualization will not work when the CPU is "in" a virtual machine.  If this happens, a "VM exit" occurs - meaning control is passed back to the hypervisor - and the host OS must now decide what to do (typically emulating an "illegal instruction" exception).  It's possible for the host OS to emulate this instruction and the rest of the CPU virtualization behavior if desired (it would be difficult and slower).
Simplifying a bit, x86 CPUs for a long time have had generally two privilege levels, user mode and supervisor, or kernel mode.  Hardware virtualization support adds a privilege level higher than supervisor, i.e. hypervisor.  An example of a difference is that the MMU that a CPU's OS uses to manage memory pages is extended to allow hypervisors to work with it.  This makes it easier for a hypervisor to allocate and isolate memory for a specific VM.  IOMMU is also a hardware feature that also provides a lot of facilities that make virtualization more efficient.
While reading different materials on different subjects every now and then I come back upon the question: How virtual really is virtualization? With "virtualization" I mean things like Virtual PC and VMWare, which allow you to run an guest OS. In particular, what I don't understand is:
See my first point.  Paravirtualized drivers for VMWare and other hypervisors exist.  The core OS itself doesn't really have to change unless A) it's something tightly coupled to specific hardware such as DOS and B) it's decided that changing the OS is better than emulating the hardware it expects.
Hardware-based virtualization uses a special mode in the processor designed to pass control to a Hypervisor and set an additional level of page tables.
If you ignore "hypervisor call escape hatches, dummy hardware component names", all other different are consider bugs.
PC operating systems have been decoupled from most hardware for a long time now.  Windows and Linux both employ drivers that are the proxy for hardware access.  Because of this, it's possible to provide "paravirtualized" drivers that are a proxy to work in a virtual environment, making things a lot easier to implement than emulation - where you'd have to design programs that 100% replicate all the weird and sometimes undocumented behavior of CPUs and hardware.  
We got OS before virtual machine. Virtual machine adapt for OS, not the another way round.  (there are some exception, e.g. old version of Xen. But this is exceptions)
Virtual machines attempt to provide environment that is good enough to run the guest OS and applications.  It is virtually impossible to provider environemnt that is indistinguishable from physical since there are timing effects that are very hard to hide (at least in a VM that runs efficiently)
Software-based virtualization emulates every CPU instruction (sometimes software based solutions use Ring-1 to natively run Ring-0 code as an optimization and this trick cannot be nested).   