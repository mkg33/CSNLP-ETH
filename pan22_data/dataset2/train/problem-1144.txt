When encoding a vector of numbers, you can in some cases (e.g. integers, enums, etc.) use a variable-byte encoding for the individual elements, and in some of these cases you can further reduce the amount of data that each element needs if you store it as either running sums, or as the minimum value and the difference between each value and that minimum.
Now, let's say you have a JSON object that stores all your element vectors. This object is syncronized between your server and your client. Instead of deciding "did so and so move?" you can just generate your next game tick in a JSON object, make a diff tick100.json tick101.json and send that diff. On the client side, you apply the diff to your current tick's vector and you're all set. 
What kind of attributes?  Without having to think too hard, in a networked game these might include:
Suppose you have 100 elements in your scene, but only 1 of them moved. If you send 100 element vectors, 99 of them are wasted. You really only need to send 1.
It's also worth noting that compression algorithms do their job better on the diff. As other answers mention either most of your elements stay the same between 2 states, or the values change by a small fraction. In both these cases applying a compression algorithm to the difference of your vector of numbers gives you significant savings. Even if you don't apply any extra logic to your vector like removing the 0 elements.
For example, if you want to encode the vector {68923, 69012, 69013, 69015} then you could delta-encode that as {68923, 89, 1, 2}. Using a trivial variable-byte encoding where you store 7 bits of data per byte and use one bit to indicate that there's another byte coming, each of the individual elements in the array would require 3 bytes to transmit it, but the delta-encoded version would only require 3 bytes for the first element and 1 byte for the remaining elements; depending on the sorts of data you're serializing this can lead to some pretty impressive savings.
While most answers talk about how delta encoding is about only sending the changes to state as a whole, there is another thing called "delta encoding" that can be used as a filter for reducing the amount of data you need to compress in the full state update as well, which may be where the confusion comes from in the question as asked.
Model doesn't change?  Without delta compression, it must be retransmitted anyway.  With delta compresion it needn't be.
However, this is more of a serialization optimization and is not what is generally meant when we talk about "delta encoding" when it comes to streaming arbitrary data as part of game state (or video or the like); other answers already do an adequate job of explaining that.
You have the wrong delta. You're looking at the delta of the individual elements. You need to think of the delta of the entire scene.
Doing this you leverage the decades of expertise in detecting differences in text (or binary!) and don't have to worry about missing anything yourself. Now ideally you also use a library that does this behind the scenes for you to make it even easier on you as a developer.
If you pick each of these in isolation, you can certainly make the case that if in any given frame it needs to change, then it must be retransmitted in full.
Position and orientation are two cases which are more interesting, commonly being composed of 3 floats each.  Between any given two frames, there is a possibility that only 1 or 2 of each set of 3 floats may change.  Moving in a straight line?  Not rotating?  No jumping?  These are all cases where without delta compression you must retransmit in full, but with delta compression you need only retransmit that which changes.
If your position are stored in vector3 but the actual entity can only move a few integer at a time. Then send it's delta in bytes would be better than sending it in integer.