Your loop is pretty well written. The only thing that sticks out to me is your use of a constant in the while loop and manually breaking.  I also prefer to use a slightly different version of CompareTo, but it doesn't make much difference:
You might also be looking for a solution that's just easier to read or shorter. Are you familiar with LINQ? This is one possibility for how your function might look.
That's because (lower + upper) / 2 can overflow.  Of course, in the 32-bit world, this is no longer very likely to happen.
The linq soution proposed in another answer does not meet your requirement of "needs to run as quickly as possible."  Linq will do a linear search rather than a binary search.
I think there's also no point in adding or subtracting 1.  I once long ago did an analysis that showed that this doesn't improve the efficiency of the algorithm.  You reduce the search range by 1 on each step, but you lose that because of the division by two.  I'm not certain of this, however; it was a long time ago.
You can get rid of the searching variable (note that you assign it at the very end of the loop body, after all):