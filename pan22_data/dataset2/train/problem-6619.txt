Let's take a step back and see what you're trying to achieve: Finding the greatest element in a vector. To do that, iterate over the vector, tracking the currently greatest element:
That sounds good, but why make a copy of the (entire) vector? Better take it by const reference, you don't plan to modify it in that function:
With the above, you always search to the entire vector of currently known persons to find the wealthiest of them. In the worst case, e.g. when all N persons enter, and then the king comes to see M people beheaded, you're basically searching M times through the whole vector, thus you have O(M * N).
As this is a rather useful concept, there's of course a function for it: std::max_element. Though this does not return the value, but rather an iterator (index) to the element with the greatest value. But ...
You call your (expensive) findGreatest function twice. Don't. Also you don't stick to the output format specified in the problem statement.
To improve on that: Nothing states that the persons must stay in the order in which they entered the room. Whenever a new person enters the room, let it stand so that all persons in front of it are wealthier, and all persons behind it are less wealthy. When the king comes, behead the first (as it has no one in front, there's no wealthier person). Basically, keep the collection of citizens sorted according to their wealth.