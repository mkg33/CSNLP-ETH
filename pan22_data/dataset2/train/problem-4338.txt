But at the end of the day, SQL Server was not written to support these kind of check constraints.  I feel they are better avoided altogether.
In a SQl server trigger, you need to be careful not to try to handle only one record at atime. Triggers operate on the entier set of data so make sure to write your trigger to do so as well. A 1,000,000 records might be changed in one update, you don't want to lock up your system while it gores through row by row. So no cursors and no scalar functions and no correlated subqueries.
A trigger is the proper way to do this. We have a simliar process and when someone sets the value to 1, any existing records that are set to 1 are reset to 0. WHen someone deletes the one that is set to 1, it goes through a chain of rules to determine which remaining record to set to 1 (we must always have one and one one record set to 1). This process is more complicated than a check constraint to handle, thus it is in a trigger (this is the main purpose for triggers even existing). 
Apart from that, most engines disallow referencing tables in CHECK constraints.  It's hopelessly annoying, but there is a very good reason for it !!!.  That reason is that the CHECK constraint should also be checked in the event of an update occurring to the referenced table, that somehow impacts the result of this CHECK constraint for some row of the table in which it is declared.
Engines typically do not know how to do this efficiently.  So they impose that limitation upon the users so that at least the integrity of the data is not compromised.  Do not make the mistake of thinking that you are smart when you discover that a UDF with some SELECT can circumvent the limitation.  You're only deluding yourself.  And a couple of months later, you'll just be the next one to ask yet another "CHECK constraint not working" question.
Note that check constraints like this would not catch an update to the LastAssignment column.  See for example this blog post.  You can work around that by passing @LastAssignment as a parameter:
I have a feeling it is something silly I am missing but I don't know.  Any help would be greatly appreciated
I have a table that has a flag that can be set to 0 or 1.  I need to make sure for every claim record in that table that the flag is only set 1 once.  So in other words I may have multiple records for one claim and all but one should be set to 0. Below is the table
You might want to look up in some reliable resource (e.g. the f... manual, or in the SQL standard), when exactly CHECK constraints are verified.  And if it turns out to be "after the INSERT has been processed", then you might try to figure out how the count of existing matching rows can ever be zero.
Here is the Constraint - It should check to see that there are no current records for that claim that have LastAssignment=1 when it inserts into the table: