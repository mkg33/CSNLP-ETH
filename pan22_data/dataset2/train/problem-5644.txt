Another example is if we wanted 0 to occur 1% of the time and 1 to occur 99% of the time, then we could pick one element from [0, 1, ..., 1] where there are 99 1's. The 100 elements comes from (1 + 99 (sum of weights))/ 1 (divisor, or gcd to be precise) = 100.
I would have preferred to see the nums and prob specified as a list of valueâ€“probability pairs rather than as two separate parameters.  That forces the caller to ensure that the number of values and probabilities match up.  The caller's code will probably be more readable as well.  Furthermore, it prettifies your next_val() slightly by removing the use of list indexes.
Equality comparisons of floating-point numbers is usually a bad idea.  Here is an example of how it can fail:
Lets say you build something like this: weighted_choices = [(0, 30), (1, 40), (2, 30)], where the 0, 1, 2 are the values and 30, 40, 30 are the percentage weights.
An object like this should be written as an iterator.  All you have to do is rename next_val() to next(), and provide a trivial __iter__() method.
In this case, you want 0 to be generated 30% of the time, 1 to be generated 40% of the time and 2 to be generated 30% of the time. Rather than checking intervals, it is much easier to generate a sequence that has elements that correspond to the probabilities.
Now assuming that all your probabilities are integral percentages (1%, 2%, ... 100%). Then you can always use 100 elements. Then for 5% you repeat the element 5x, 12x for 12% and so on.
For example, we could replicate the probabilities needed by having a 10-element list like so: [0, 0, 0, 1, 1, 1, 1, 2, 2, 2] and then pick 1 random element from it. How did I get 10? 10 is the minimal number of elements that evenly divides 30, 40 and 30 (the probabilities) multiplied by the sum of the weights (30 + 40 + 30)/10 = 10.
There is no reason for next_val() to fail validation, as it takes no input.  For that matter, validation and the building of the accumulate array should have been done in the constructor, so that it doesn't have to do that work repeatedly.