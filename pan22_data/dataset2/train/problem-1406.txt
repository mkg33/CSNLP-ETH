It sounds like you're looking for framerate-independent animation. If you're using a faster machine and your animations hang around for a certain number of frames, they'll appear to be moving faster. If your animations however are set to last for a certain number of milliseconds (framerate independent) then everything should appear the same on each machine.
One thing I didn't do was apply this to movement :-/ where you have the same issue. Things flying around the screen on chrome but lagging on iOS. Will add that in next release.
Docs are still a little rough, but there are some usable/runnable examples. The Sprite.js and Frame.js classes might serve as good examples.
For many games I recommend implementing game logic that updates in fixed time intervals. When updating your game, measure how much time has elapsed and then run as many game ticks as needed to update your game state to the current time.
This framerate independent approach should be applied to all other concepts in the game as well such as character movement. Consider your standard walking speed to be in terms of pixels (at the current resolution) per second rather than pixels per frame.
In: http://github.com/j03m/trafficcone (an html5 game engine I wrote) the way I approached was to use requestAnimationFrame but then also allow each sprite frame to have a speed attached to it in milliseconds. So, what you can do there is defined frame by frame the speed (so, if certain movements were to seem explosive and then slow down you can do that as well). From there, the engine tracks the last time the frame changed and handles it accordingly and uniformly.
The game that I have been working on runs far quicker in Google Chrome than in other browsers such as Firefox, Opera, or IE9.  To be honest, it kind of reminds me of running a game from the early 90's on a brand new machine.
Some searching revealed this example. Of note is the prototype for the Animation class, where the update function takes a time delta since the previous frame.
Is there a good (accepted) method for "fixing" the cycle time within an HTML5 canvas game implementation?
There are exceptions to this, such as if the machine is very slow and the cycle time is longer than the expected duration of more than one frame in the animation, you may need to skip frames which can make things look not so nice.