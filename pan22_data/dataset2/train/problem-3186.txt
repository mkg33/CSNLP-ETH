values[0], values[1], values[2], etc. are meaningless. It would be far better to convert each line into a class with properly named properties.
You assign d, a name that conveys absolutely nothing, only to use that to execute var row = d.Replace("\n", "");. Why not do that in one line?
Everything inside if (values.Length >= 2) should be moved to a separate method; matter of fact make that everything inside if (values[2] != null && values[2] != ""). Also, don't you know about string.IsNullOrEmpty()?
WRT your question: consider converting countries to a Dictionary<string, string>, e.g. var countryCodeByIso2 = countries.ToDictionary(x => x.ISO2Code, x => x.Country_Code); and then use TryGetValue(). But please, first refactor your code.
can basically be replaced by match = existingList.Any(x => x.ContactNumber.ToString() == contactno);.
Your loop is close to 200 lines, that's waaaay too long. That's long for a full class, let alone one method, let alone part of one method.
Why do you use for (int i = 1; i < count - 1; i++) when you don't do anything with i? Why not use foreach(var line in lines)? Oh wait, I see, you've called your collection line -- a bad name, since this doesn't tell me it is a collection of lines.
Then suddenly we encounter if (model.NumberFormat == 1), yet model is nowhere defined. I assume this comes from outside the for loop? If so, then why is this code located here?
At that point I'm not even halfway through and I have to give up. You need to seriously refactor this code. Each property you need to retrieve should have its own method, and in 99% of those cases there shouldn't be an empty try...catch block.