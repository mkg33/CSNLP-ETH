This looks like a test wrapper rather than the "main" code. It would be nice to offset it in a separate file. There's also a good case to be made for writing unit tests before you write a TUI test wrapper, and I think you would find reviews of unit tests more useful than reviews of a TUI test wrapper.
That's not necessarily a prime. Was it intended to say num = num + 1 to allow the subsequent loop to just go through odd numbers?
Java has an interface java.util.Map<K, V> for maps. If you implement the interface, your class becomes a lot more useful. (This does also prompt the question: why are you reinventing-the-wheel? Is it just for the sake of it, or do you want to improve on java.util.HashMap<K, V> in some specific metric? If the latter, it may make sense to extend java.util.AbstractMap<K, V>).
Some OO purists would argue that you should ask an object to do something for you rather than to return data to you, but most Java practitioners are not such purists. I would expect to see an override of toString() rather than a print() method.
I don't entirely agree with Janos' comment on the initial size of the array, although I do agree that it should expand. The point of the capacity parameter is as a hint for the initial capacity, not as a hard limit beyond which performance may suffer. That said, what's going on with nextPrime?
(Also, for preference, I would follow java.util.Map<K, V>'s convention for the toString() of a map).
Also, I think there's a risk that if you create a lot of maps with a large initial capacity that this could become a bottleneck. There's no obvious reason for requiring the next prime: I suggest that an alternative would be to have an array of pre-calculated primes which are just less than a power of two, starting with 7. Then it's nice and fast to find a suitable size, and it's convenient for when you extend the code to resize the array of buckets if the chains start getting too long. As a bonus, you don't even need to calculate them yourself: the Primes Pages include primes just smaller than a power of two. The other reason for choosing just smaller rather than just larger than a power of two is that it might interact better with whatever memory allocator is being used under the hood.