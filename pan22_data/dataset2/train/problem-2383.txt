This redirects the standard output to /dev/null and then redirects the standard error to standard output.
Your particular question about time builtin has been answered, but there are some commands that don't write either to stdout or to stderr.  A classic example is the Unix command crypt.  crypt with no arguments encrypts standard input stdin and writes it to standard output stdout.  It prompts the user for a password using getpass(), which by defaults outputs a prompt to /dev/tty.  /dev/tty is the current terminal device.  Writing to /dev/tty has the effect of writing to the current terminal (if there is one, see isatty()).
Then the standard error will be redirected to the standard output and after that all the standard output (containing the standard error) will be redirected to /dev/null.
time sleep 1 > /dev/null 2>&1 # redirects "sleep's" output do null. Then, "time" writes its own output, with no redirection. It is like "time (sleep 1 > /dev/null 2>&1)".
The reason crypt can't write to stdout is because it writes encrypted output to stdout.  Also, it's better to prompt to /dev/tty instead of writing to stderr so that if a user redirects stdout and stderr, the prompt is still seen.  (For the same reason, crypt can't read the password from stdin, since it's being used to read the data to encrypt.)