Here is how I would rewrite your function.  Note that this function assumes that the input array is already sorted:
The actual loop iteration limit should be exactly \$\lceil log_2(n+1) \rceil\$. Your code is expecting the iteration limit to be \$\lceil\sqrt n\rceil\$, but for small values of \$n\$, this limit is too low.
The alteration is that instead of setting right = middle or left = middle, you instead set right = middle - 1 or left = middle + 1.  By doing that, you will never have the case where left, right, and middle remain the same from one iteration to the next.
Actually, your code doesn't need the previously mentioned loop.  It also doesn't need leftLast, middleLast, and rightLast.  The reason those variables exist is to ensure that progress is made between iterations.  But if you make one small alteration to your loop, then you could guarantee progress without needing all that complication.
As written, your SimpleBisect() function has a worst case time complexity of \$O(n)\$.  The worst case is an array such as { 1, 2, 2, 2, 2, ... , 2 } when searching for 1.  This is because you have a loop that moves the right end past duplicate values one by one:
The time complexity of a binary search is \$O(\log n)\$ and not \$O(\sqrt n)\$ as stated in the question.  Each iteration of the main loop reduces the problem by half and so the time complexity is logarithmic.  For an array of 65535 elements, for example, a binary search should take at most 16 iterations and not 256 iterations.
The term that I see more commonly used for what you are doing is "binary search".  I'm sure that "bisection" is a synonym but bisection can also refer to a class of algorithms for finding roots of a polynomial.