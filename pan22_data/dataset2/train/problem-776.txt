Best practices are not creating in vaccum. Despite some cargo cult, in general best practices are there for a good reason.
So... Is your game running slow? You are better of devoting time to figure out the bottleneck and fixing that, instead of speculating what could it be. You can rest assured that the compiler will do plenty of optimizations, because of that, chances are you are looking at the wrong problem.
But my impression is that in game development, unless you have a reason to do otherwise, everything should be nearly as fast as possible. My impression from things I've read is that Unity 3D is not sure to inline access via properties, so using a property will result in an extra function call.
You are right to be aware that premature optimisation is bad but that is only half the story (see the full quote below).  Even in game development, not everything needs to be as fast as possible.
"The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming."  Donald Knuth, 1974.
First make it work.  Only then, optimise the bits that need it.  That's not to say that the first draft can be messy or needlessly inefficient but that optimisation is not a priority at this stage.
Structs and naked fields will ease interoperability with some not managed APIs. Often you will find that the low level API wants to access the values by reference, which is good for performance (as we avoid an unnecessary copy). Using properties is an obstacle to that, and often times the wrapper libraries will do copies for ease of use, and sometimes for security. 
Because of that, you will often get better performance having vector and matrix types that do not have properties but naked fields.
It is very easy for the .net runtime to inline simple properties, and often it does.     But, this inlining is normally disabled by profilers, hence it is easy to be misled and think that changing a public property to a public field will speed up software.
I have been saying client code. That means code that calls into yours. If you are not making a library (or even making library but using internal instead of public), you can usually get away with it and some good discipline. In that situation the best practice of using properties is there to prevent you from shooting yourself in the foot. Furthermore, it is much easier to reason about code if you can see all the places where a field can change in a single file, instead of having to worry on whatever or not it is being modified somewhere else. In fact, properties are also good to put breakpoints when you are figuring out what went wrong.
Yes, of course, there could be optimizations that you could do by using structs with naked fields. For example, you access them with pointers Span<T>, or similar. They are also compact on memory, making them easy to serialize to send over the network or put in permanent storage (and yes those are copies).
I'm aware that premature optimization is bad, but as I said, in game development you don't make something slow when a similar effort could make it fast.
Yes, there is value is seeing what is being done int industry. However, do you have a motivation to go against the best practices? or are you just going against the best practices – making the code harder to reason about – just because somebody else did it? Ah, by the way, "others do it" is how you start a cargo cult.
The primary reason I used properties in my 10 years as a professional C# programmer was to stop other programmers telling me I was not keeping to the coding standard.   This was a good tradeoff, as hardly ever was there a good reason not to use a property.
In code that is called by other code that will not be recompiled when your code is recompiled there is a good case for using properties, as changing from a field to a property is a breaking change.   But for most code, other than being able to set a breakpoint on the get/set, I have never seen benefits in using a simple property compared to a public field.
Am I right to constantly ignore Visual Studio's suggestions to not use public fields? (Note that we do use int Foo { get; private set; } where there is an advantage in showing the intended usage.)
On the flip side, if you are deciding what to do to begin with, you should worry about what algorithms and data structures first, instead of worrying about smaller details such as fields vs properties.
Now, have you picked the right algorithms and structures, if they turn out to be a bottleneck, then you decide what is the best way to fix it... that could be structs with naked fields or not. You will be able to worry about that if and when it happens. Meanwhile you can worry about more important matters such as making a good or fun game worth playing.
For the particulars of you case (Unity and Mono for Android), does Unity takes values by reference? If it doesn't, it will copy the values anyway, no performance gain there.
If it does, if you are passing this data to an API that takes ref. Does it make sense to make the field public, or you could make the type able to call the API directly?
For basic stuff like that, the C# optimizer's going to get it right anyway. If you worry about it (and if you worry about it for more than 1% of your code, you're doing it wrong) an attribute was created for you. The attribute [MethodImpl(MethodImplOptions.AggressiveInlining)] greatly increases the chance a method will be inlined (property getters and setters are methods).