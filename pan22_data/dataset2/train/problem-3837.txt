This simply loops through all the connections of some object, checks their type, and if they match, adds the connected object to the result set (which also always contains the clicked object). You can replace the "connections" loop with a loop that checks adjacent grid X, Y positions if you are using a grid instead; the idea is the same.
This is the kind of thing like lends itself to a recursive solution. In the most basic case, a click occurs on an object and you want to check all the connected objects, in C#-like pseudo-code (which should be easily translatable):
It sounds like your objects are stored in a grid, but really it doesn't matter so long as you have a list of connections between any given object (which it certainly sounds like you do). 
Remember also that any recursive solution can be written as an iterative one, and iterative solutions can be better in some cases because they do not have stack recursion limits. Although I feel the problem is more naturally explained as a recursive solution, in practice I'd suggest trying your hand at converting it to an iterative one to avoid any limitations you can run into due to stack depth, et cetera. Remember also that the above was pseudocode meant to provide a basic idea of the algorithm and certainly could be more optimally constructed in your specific language
Now the next step is to do this exact same thing for every connected object that matches. We can adjust the function as so:
But there is a caveat: consider a graph of connected objects like (A -> B -> C -> A) or, on a grid, a 2x2 block of objects of the same type. Because the above solution does not consider if an object has already been seen, it can recurse forever in such a case. So you need to track that:
That should provide you a basic starting platform. Note that for API usability, I'd recommend making the above function a private implementation detail and instead exposing a cleaner public method: