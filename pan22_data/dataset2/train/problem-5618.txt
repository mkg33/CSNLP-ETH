If you are using a hardware or OpenGL surface, there's also the pygame.DOUBLEBUF which uses hardware double buffering, meaning that your drawing functions will draw to one of the two buffers and flip() will swap which buffer is visible.
Does anyone know of any graphics/display options I need to set in pygame to make this faster? Or is this just something that I have to live with since I've chosen pygame?
It's correct that Pygame does not use the 3D acceleration capabilities of your video card. This is because it is based on SDL which has the same limitation. One alternative is to rewrite your game in a system like pyglet which does natively support OpenGL accelerated sprites, to find a similar library for graphics only, or to write the OpenGL code yourself for this.
By profiling my game, I see that the vast majority of the execution time of my hobby game is between the blit and the flip calls. Currently, it's only running at around 13fps. My video card is fairly decent, so my guess is that pygame is not using it.
If you're running in full-screen mode, you can use the pygame.HWSURFACE flag when you initialise the display to tell pygame to try to use a hardware surface. I believe that if a hardware surface can't be used, pygame will silently use a software surface.
Comment out any test console output you have. This can drastically reduce framerate, especially if you are outputting between rotation and scaling, as Cody said above.
One bottleneck in pygame is actually font rendering. You should not render the same text (with the same font/color) more than once but rather cache the surfaces once rendered and reuse them. Take this into acount if you're using Font.render() alot.
If you're not using a hardware surface, consider using pygame.display.update(rectangle) rather than pygame.display.flip(). This will only update the given rectangle rather than the whole display, which can increase your performance quite a bit unless your game actually needs to update the whole display.