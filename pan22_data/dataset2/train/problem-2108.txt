Side Rant: I believe with the advent of social login emailed/texted access tokens for granting access to other sites/apps will be the way to go. Nobody wants to remember all these passwords so they use the same one and we blame them, which is stupid because it's simply human nature. Then we make up password holders which you need a password to which is just 1 password holding all your other passwords and we think that's a good solution...The safest thing you can do is change passwords often and make them complicated but because we have to have so many nobody does this. We don't want to spend our lives changing passwords. Ideally we'd have the 1 password to say our email and everything goes through there for step 1 auth, then phone for step 2. People would be more willing to change their ONE password more often knowing it was just 1 and used to get access tokens that grant them access to all other apps/sites.
That Thread.Sleep(1) is a real problem, especially if you're going to use this to generate thousands or millions of coupons at a time. The only reason you need it is because you're creating a new instance of Random for each coupon and seeding that instance with the current time. The default constructor of Random already handles time-based seeding; if you make the instance static, you only need to construct it once and thus avoid the duplication issue.
A singleton instance of @Guffa's implementation to avoid recreating StringBuilder and Random objects; less GC and a bit faster. Also @Gilles' implementation of GenerateUId beneath in case a crypto version is necessary.
Also, you should use StringBuilder when building a string chunk by chunk. Resolve it into a string when you've finished building it.
Slight modification to Berrly's answer. Gives alphanumberic with casing and makes sure there are no duplicates created. I'm going to start using this for access tokens that get emailed to the user & text'd to log on to my system. This would be more secure than most of these systems today as they are more predictable as they are generally 6 characters long (fixed length) and numbers (limited set). Even though they all have a time limit on them why not go this extra mile as it's not that much harder.
This RNG returns bytes. There are 256 possible values in a byte. Your coupons can only use one of 62 characters, so you need to reject bytes that do not map to ASCII letters or digits.
I like @palacsint's idea of using a List<char> to store allowed characters and populating it with character-indexed for loops, although I'd make the list a lazy-initialized property rather than recreating it each time. And I fully agree with @Guffa's point about using StringBuilder to create the coupon rather than the += operator.
You can make the generation about 4 times faster by rejecting fewer values. Instead of accepting only the 62 values that map to the characters you want, divide by 4 to get one of 64 equiprobable values, and accept 62 of these (mapping them to the right characters) and reject 2.
That may be slightly too long for a coupon code. One other suggestion is a using a pronounceable password generator, the link is something I converted from Java source a while back. Some uppercased examples:
If it's acceptable to have a slightly longer string, you could use the ShortGuid class. This takes a Guid and makes it slightly more readable than the 32 byte format you're use to ({xxx-xxx-xxx...}).
You should not be using Random to generate coupons. Your coupons will be somewhat predictable: if someone can see a few coupons (especially a few consecutive coupons), they will be able to reconstruct the seed and generate all the coupons. Random is ok for most numeric simulations and for some games, it's not good at all when you need to generate unpredictable values. Your coupons act like passwords; you need cryptographic-quality randomness. Fortunately, there is a crypto-quality random generator in the C# library: System.Security.Cryptography.RNGCryptoServiceProvider.