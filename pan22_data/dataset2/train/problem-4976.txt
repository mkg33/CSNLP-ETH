I believe the specific thing that is fooling you is that every directory below / has at least two links to it: the directory's entry in its parent and . within itself (plus any .. links from child directories).  When you type ls -ld . it's looking at the . link in the current directory (which you have permission to read), not the link to the current directory from the parent directory (which you don't have permission to read).
For +x, I've found the easiest way to understand how it works on directories is permission to "get into" the directory.  You can't get into a directory without +x at all, even if you have read and write access to it. If you aren't allowed into a directory, you can't get into the subdirectories whether they have +x set or not. So, if you have fooledYa/ohReally/foo.txt and fooledYa is is chmod 0000, assuming no other ACL system overrides the file mode, only root would be able to get into ohReally/ or open foo.txt even if they know the path to the file without having to list the directory contents.
This is a good illustrative examples of inodes and how they represent directory references and file block on disk references: http://teaching.idallen.com/dat2330/04f/notes/links_and_inodes.html
First thing's first: I can write to the directory (make new entries) and I can execute (cd) to the directory. I can't read the directory, though. What that means isn't intuitive.
When you work with directories in Unix systems, the directory point to inodes, which are different things than the pointer entry. Being able to follow references down a directory tree is controlled by the eXecute bit. For each directory level down the tree, the operating system checks the execute bit before descending to the next level.
So, to summarize for directories, think of execute as a master permission. Without it, you can't enter the directory to do anything. After that, think of them as a two column file. If you have read permission, you can see the entries. If you have write permission, you can add or remove entries. If you lack those two permissions but have execute, you can make references to entries in the list, but you cannot read the list.
Thus, since ls tries to read the contents to tell me what's there (as checked by the Read flag), it is denied. Since I still have eXecute permission, however, the kernel will allow me to traverse to files that I specify if the directories above the file I want all permit me to eXecute into them, regardless of whether I can read them to see what the reference.
In this case, the directory inode is 121100226. The read permission tells whether I can access that inode file in userspace to read its contents. The contents of the directory inode are the references to other files. The kernel can always read that. You as a user are controlled by the kernel's decisions regarding the entries within that.
Meanwhile, the Read bit controls accessing the inode's contents. Everything you can reference on your filesystem is an inode entry. Directories or files, they point to an inode.
One of the odd things about these permissions is that if the directory is +r but not +x, you have permissionto read the directory contents so you can "peek in" from outside and read the list of files in the directory, but without +x you won't be able to get into the directory to access (stat) the individual files.  Therefore if you try to ls -l such a directory you'll get filenames but all the other fields for filesizes, modes, ownership, etc will be ? marks.