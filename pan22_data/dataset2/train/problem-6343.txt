You obviously don't do enough encapsulation. I see at least three classes with no behaviour (Bar, Level2 and Info), your "main" class (CVB) contains only static method... it does not seem like good OOP for me (and when we are talking C# we should mostly talk OOP).
Inside loop we have three ifs. If we look closely, we'll see that they are mutually exclusive. We will mark it explicitly, so we don't have to guess. If we follow this line of thought, we'll see that every time we don't hit continue inside our if we can safely return from call. So let's invert those conditions too.
In fact, repeating pattern (for every type of Output call a method passing output inside) clearly calls for some inheritance on Output side: you should have several different Output classes, subtyped after your Output.Type, with method ProcessSmth(CVB), which should have processing related to that type of output. Having that you would replace this whole switch with output.ProcessSmth(this). But I won't do that now, and instead concentrate of contents of there methods (although they are already pretty small and readable, with exception of Trade).
Another "safe" extraction is to put your 0.00000001 into a (class-level) constant, which we will name Tolerance, because as far as I can see, it is a floating-point comparison tolerance.
This line is repeated three times (although I suppose that third one is a mistake), so we extract it into method, also giving it meaningful name (RemoveAllAsksLessThan). We repeat same operation for remaining RemoveAlls. Let's look what's left of these:
But I must repeat: with exception of one operation (moving process inside CVB instance) all we've done here is a function-based refactoring. As it's already said here, we might be as well programming in C or JS. I would highly recommend you to rethink your approach into more object-oriented one.
Why are output and cvb ref, if it's not assigned anywhere in code? It should not be. Only things that implies assignment is call to writeToString(ref output, ref cvb, c);, which should not modify anything, because it's only writing. You have not included your code, but let's assume that it's not doing any assignments inside too. So we get rid of those refs.
In fact, it could be an one-liner if inlined all the variables, but I leave them as is for the sake of readability.
Next thing in here: you're passing in an array of CVBs and some c, most likely an index. But everywhere in method (with exception to calls to writeString) you're using cvb[c]. So we can safely extract it into temporary variable. Let's call it cvbEl, for the lack of best option.
All that's left is Trade. Most of it happens only when bar.bestAsk != 0 || bar.bestBid != 0. Let's invert that if so we don't have to think what happens if both bests are 0 (because we simply return at that, don't leave us hanging!).
Now I'll do some strange thing: I'll extract your call to writeString to variable. I do this only because it is the only thing that operates with cvb and c and I can not make any decision about it without seeing it first. So I'll just save entire call for later.
You do that for every run you got thru your Beginning: label, but in fact it won't change: neither output.price nor bar.high are changed elsewhere in this method. So we can safely move this operation above Beginning:. Same goes for bar.low, bar.close, bidDistance and askDistance.
With exception of Trade that still need improvement, and where you can apply same process, it seems to me that we've done pretty good work here.
Then we convert your goto into common-knowledge while(true). To do that we simply replace Beginning with while(true), enclose all code below in loop, add return in the end, and continue instead of every goto.
And now, thanks to this, all our code operates on cvbEl. So we can safely move it to CVB instance method, because all this processing is coupled to single instance of CVB. Let's call this method Process (of course, all the code inside it does not use cvbEl, but uses implicit this. Now, all that's left of yours processLine is: