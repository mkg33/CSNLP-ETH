By doing this, you can keep the primary key "simple" and use it like you normally would in a non-partitioned table.
Since you’re already talking about partitioning this table, I’m assuming there is already a LOT of data in it, so this may be a bit painful.  You may actually have to create a whole new table and batch load data from the existing table to keep from blowing out your log space.  Perhaps someone has a more efficient way of doing this (and that’s fine as I’m open to learning better ways of doing stuff), but I think this is the way I would approach this problem.
Every index participating in a partition table scenario MUST contain the partition column in some manner.  Clustered indexes cannot have INCLUDED columns, but non-clustered indexes can.
I have some tables that we want to partition on a date column which is not the primary key. I kept getting error message "Partition columns for a unique index must be a subset of the index key."  So I added the date column to the primary key.  Now I can't recreate the foreign key because foreign key has to include all columns of the primary key and it doesn't make sense to include the date column in the foreign key. 
Based on the comments, it seems the answer is to create a clustered index on the column you want to use to partition the data and then make sure your non-clustered Primary Key index is not partition aligned so you will not need to add the partitioned column to the primary key.