My all-time favorite application of group theory in TCS is Barrington's Theorem. You can find an exposition of this theorem on the complexity blog, and Barrington's exposition in the comment section of that post.
Rings, modules, and algebraic varieties are used in error correction and, more generally, coding theory.
In the world of list decoding, a recent paper by Guruswami gives an linear-algebraic method of list decoding folded Reed-Solomon codes, which has the nice property that all of the candidate messages lie in a low-dimensional affine subspace of the message space. One can construct subspace evasive sets, sets which are almost as large as the whole space but have small intersection with every low-dimensional affine subspace. If one restricts messages to come from a subspace evasive set inside the message space, then Guruswami's scheme gives an algorithm that guarantees nice list size. So far the only explicit construction of subspace evasive sets is given by Dvir and Lovett in their upcoming STOC paper, Subspace Evasive Sets and construct the set by taking a specific affine variety (and taking its Cartesian product with itself).
Algebra (and algebraic geometry) has had a pretty big role to play in cryptography, with elliptic curve groups, (number-theoretic) lattices, and of course $\mathbb{Z}_p$ being the basis for nearly all modern cryptographic work.
Also, there is homotopy type theory, which interprets type theory in (sort-of) an algebraic topological setting.
Semirings are used for modelling annotations in databases (especially those needed for provenance), and often also for the valuation structures in valued constraint satisfaction.  In both of these applications, individual values must be combined together in ways which lead naturally to a semiring structure, with associativity and the one semiring operation distributing over the other.  Regarding your query about modules, neither monoid has an inverse in these applications, in general.
In functional programming, the most general and elegant abstractions for problems are often algebraic (or category-theoretic) in nature: monoids, semirings, functors, monads, F-algebras, F-coalgebras, etc. Some classic results (e.g., the Yoneda lemma) happen to have computational content and utility.
Specifically, there is an abstract error correcting scheme (algebraic-geometry codes) which generalizes Reed-Solomon codes and Chinese Remainder codes. The scheme is basically to take your messages to come from a ring R and encode it by taking its residues modulo many different ideals in R. Under certain assumptions about R, one can prove that this makes a decent error correcting code.