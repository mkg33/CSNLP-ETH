e.g. with the following example the first call to [dbo].[Get] 1 takes 333,731 logical reads as it chooses an inappropriate plan with key lookups. When the plan is removed from cache and recompiled with 1 passed first the logical reads fall to 4,330
In the specific example in your question where you are selecting a single column and that is the same column as you are filtering by this is unlikely to present a problem but it can do in other cases.
If this were a function I’d suggest avoiding multi-statement options, so that the QO could do its stuff more nicely.
Your "Conditioned select" option is still vulnerable to parameter sniffing. If the procedure is first executed when @Parameter is null then the branch with the [Field] = @Parameter predicate will estimate 1 rows (rounded up from the 0 expected for a =NULL predicate).
I am aware of the parameter sniffing issues associated with stored procedures written with a predicate like the following:
If there is no significant variance in the result set with different scalar values of @Parameter, Dynamic SQL is a top performer, has the least system overhead, and is only marginally worse in regards to administrative overhead in comparison to OPTION(RECOMPILE).  In more complex scenarios, where variance in parameter value can cause significant changes in result sets, using Dynamic SQL with a conditional inclusion or exclusion of OPTION(RECOMPILE) will be the best overall performer.  Here is a link to Aaron Bertrand's article detailing the approach: https://blogs.sentryone.com/aaronbertrand/backtobasics-updated-kitchen-sink-example/ 
As you get more and more parameters, you will find the Dynamic SQL option is clearest, even though it looks scarier to beginners.
Assuming [Field] is scalar, and the clustering index on a table. What are the pros and cons to the following approaches to writing a stored procedure(s) to support the query: 
Depending on the value of the parameter, Scalar or NULL on first execution, a plan is cached that will likely be sub optimal for the opposite value.  
They’re all excellent. Really. They all have the same impact of having two plans in the cache, which is what you want.
Based on the previous answers and comments from Aaron Bertrand, Martin Smith, and Rob Farley.  I wanted to put together a pro/con list for each approach, including the additional approach OPTION(RECOMPILE):