One of the sorts of entries we might consider is an array. Each row of our original array is, itself, an array (though heterogeneous situations are possible also). So, we get an array of arrays. There is nothing in general that says that each of those arrays needs to be of the same length, as the information stored in a row might vary. 
We often use arrays to keep track of information. Each entry (I'll call it a "row" here for reasons that will become obvious) holds some data we need to keep. Sometimes the entry for a row is complex, not simple. Sometimes it is just an object of some type, but sometimes it is a collection of things. We can use any sort of collection for an entry (row). 
At the chosen point, multiple bus lines connecting, the bus terminal, or airport, create a 'table' of the departures, grouped by route number, destination, carrier, etc. 
With the two sets of tables developed, you are now in a position to move into directed graphs. No longer do the traveling sales agents have to travel some foreign routes to unknown places with "costs" which are hypothetical. Now they can travel to known points in the city with real-world time constraints based on catching buses and making transfer connections.
I've thought about combining this with Sudoku to show inheritance. Both KenKen and Sudoku are played on a square board and share the constraints that each row/column must contain unique values from a range. They are different in how the additional constraints are defined.
An example which I think could be useful to you, both because it's a "ragged" array and because students are likely to see it again later if you talk about parsing text, is splitting text by line and by character:
Selecting one bus stop I frequent, there are 5 different buses which stop there. One is a short circulator, one is a long-range route with frequent service, and the others are 'normal' routes. Creating a 2-dimensional array with only those five routes gives a nicely 'ragged' array.
For example, in user Ben I.'s prime factor example, a row contains the prime factors of a given number. But a column is essentially meaningless. In fact, the use of an array, rather than some other collection is optional. It could, as well, have been a tree-set.
Also, for what it's worth, if you organize your midi-like events by time, it's actually ragged.  Different numbers of notes are played (or stop playing) at different times.  If you play a triad, you will have three events.  If you play a triad at the same time as you stop playing a previous melodic note, you now have four events.
Presuming that your location has some form of public transportation, there will be intersection points where multiple lines meet. Lacking public transit locally, there is still the nearest commercial airport. In many cities the bus, or rail, system has a hub, which makes a good example for a larger data-set.
The first token contains an operation and value (e.g. +6) with the remaining tokens are a list of the cells in that constraint. The cell location could be represented as a pair of comma separated indices (e.g. 3,1) or in a spreadsheet like notation (e.g. B5). In either case the line can be split on whitespace resulting in a ragged array. However, variation in the lengths will not be very great.
I would suggest the game KenKen. Although it is played on a square board, one can easily represent the constraints as a ragged array. Represent each constraint as a single line in a file. Each line contains a variable number of "tokens".
But (insight coming) here each of the rows has a definite meaning in your problem, but the "columns" have little or no meaning. Less meaning in any case. The situation isn't symmetric. It may be possible, for example, to swap rows in the array without losing essential information. But it may not be possible to swap columns in the same (lossless) way, though that depends on the problem. 