#1 unconditionally runs in quadratic time: i:[0..len-2], j:[i+1..0], which is in the order of nÂ² - n steps.
Selection sort specifically select the littlest element from the rest of the array.  This makes it more costly, but adds the additional guarantee that not only is array[0..i] in order, but it also contains the littlest elements of the entire array.
#2 is smarter about it, and doesn't run back comparing if it won't need to.  This means it has the potential to run in close to linear time.  Specifically, it will be in the order of n + d*n steps, with d being the number of elements out of order.
#3 would be closer to selection sort, a relative of insertion sort, though there's no advantage in allocating a new array. (Or maybe I misunderstand.)
Code #1 This implementation takes an element and sorts itself with all the elements to its left, one by one, like bubble sort I think. I am just sorting and I think I can not say I am inserting an element to its correct location.
Both build a sorted part in the array, guaranteeing that at step i, array[0..i] is sorted.  Both do their sorting in-line, not requiring extra array allocations.  And both select an element from the unsorted part and then insert it.  The difference between insertion and selection is in how they select the next element to be inserted.
Code #2 This implementation takes an element into a 'temp' variable, compares it with left elements in the array and sorts them by comparing with the 'temp' element. When sorting stops, which means that the left side is sorted corresponding the 'temp' element, then this is element is put into that last location.
#1 and #2 are both implementations of insertion sort (*).  The way you insert the element is not so important: whether you copy one by one, use arraycopy, or bubble it down is up to implementation.  I'd imagine arraycopy to be the best for larger inputs.
I might be wrong but that is my thought. Please suggest algorithm modifications or my thinking if I am wrong.
I am learning data structures, and have written an algorithm for insertion sort after learning from some sources. But I am confused which implementation is more correct or appropriate.
A strong point of insertion sort is that it performs very well for input that is already (mostly) sorted.
I also have another idea though I have not written the code which I think matches my thought about the meaning of insertion sort.