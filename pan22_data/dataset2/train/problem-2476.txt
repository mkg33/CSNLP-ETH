When you transition from the current state to the minigame state you just need to change the global render backend provided by the service locator.
In some designs it seems legit to be able to access the render backend globally. In the Singleton pattern that means that each IRenderBackend implementation should be implemented as unique global instance. But using the ServiceLocator pattern doesn't require this.
Just to demonstrate how implementations can vary during the runtime, let's say that your game has a minigame where rendering is isometric and you implement an IsometricRenderBackend.
Lets say that you have a rendering backend interface which has some common operations for rendering stuff.
Just know that you'll have a mix-in of both synchronous & asynchronous communications.  Pick what is appropriate, but know you'll need to support both styles among your subsystems.  Designing support for both will serve you well into the future.
The question is actually seems to be about how to reduce coupling without sacrificing performance. All global objects (services) usually form a sort of context which is mutable during the run-time of the game. In this sense, the service locator pattern disperses different parts of the context into different parts of the application, which may or may not be what you want. Another real world approach would be to declare a structure like this:
Keep in mind when it comes to communication itself, that doesn't always have to imply a direct function call itself.  There are many indirect ways communication can occur, whether it be through some indirect method using Signal and Slots or using Messages.
To get the basics out of the way, some developers prefer to design it like much like a pyramid where there is some top core class often referred to as a kernel, core or framework class that creates, owns, and initializes a series of subsystems such as audio, graphics, network, physics, AI, and task, entity, and resource management.  Generally, these subsystems are exposed to you by this framework class and usually you would pass this framework class to your own classes as a constructor argument where appropriate.  
Something we use in our games to organize our global data is the ServiceLocator design pattern. The advantage of this pattern compared to the Singleton pattern is that your global data's implementation can change during the runtime of the application. Also, your global objects can be changed during the runtime too. Another advantage is that it's easier to manage the order of initialization of your global objects, which is very important especially in C++.
And pass it around as a non-owning raw pointer sEnvironment*. Here pointers point to interfaces so coupling is reduced in a similar way compared to service locator. However, all services are in one place (which might or might not be good). This is just another approach.
Another advantage is that you can use null services too. For example, if we had an ISoundManager service and the user wanted to turn the sound off, we could just implement a NullSoundManager that does nothing when its methods are called, so by setting the ServiceLocator's service object to a NullSoundManager object we could achieve this result with hardly any amount of work.
To summarize, sometimes it may be impossible to eliminate global data but that doesn't mean that you can't organize them properly and in an object oriented way.
Sometimes in games, it's important to allow actions to occur asynchronously to keep our game loop moving as fast as possible so that frame rates are fluid to the naked eye.  Players don't like slow and choppy scenes and so we have to find ways to keep things flowing for them but keep logic flowing but in check and ordered too.  While asynchronous operations have their place, they're not the answer for every operation either.