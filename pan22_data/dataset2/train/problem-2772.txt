The rest is actually easier to understand with code....., and it can be generalized very easily with a method like:
I think just fixing those obvious things will be enough to see a significant increase in overall performance.
A number of answers have pointed out some algorithmic changes, and some logic steps you can take, to calculate the result, but there's a simpler way to do it, which is not necessarily the fastest way, but it is still blazingly fast, and still very simple.
There's a few key optimisations that, on my machine, takes the execution time of your function down to 10 seconds (my 2.5 GHz Intel Core i7).
Second, you don't need to check every factor; if your x is divisible by 20, then it's also divisible by 10; if it's divisible by 18 it's divisible by 9; if it's divisible by 16 then it's divisible by 8. And so on. So the only factors you need to check are 20..11.  10...1 are already covered. (BTW, going from 20 down is a good direction.)
The algorithm you have by testing every number is obviously overkill, but, what about going through the basics of the process, and implementing it in code. What is the question actually asking? It's asking for the lowest common multiple of all the numbers 1 through 20.
Now we have 2, which is a multiple of both 1, and 2. We want to find the multiple of both 1 and 2 (which is 2), that is also a multiple of 3, so, we check whether 2 is a multiple (it's not), so we add 2 to itself, which is 4. Is 4 a multiple? No, so we add 2 again, to get 6. Is 6 a multiple of 3? Yes. So, 6 is the lowest multiple of 1, 2, and 3. Now, we just repeat this process to 20.
Some of the other answers may have written the code to generate this list in general (i.e. for values other than 20).  They don't seem to have commented the code in a way that's making it clear to me what they're doing.  
Then, find the multiple of 1 that is also a multiple of 2... to do that, we add the 1 to itself repeatedly, until we get a multiple of 2. This is easy, it is just once....
Seems like I am a little bit late, but I would use a completely different approach(as if i would do with a pencil and paper) which returns the result immediately
Let's introduce some names here, lcm is the lowest common multiple, and sum is some value that is a multiple of lcm. If sum is a multiple of lcm, then it is also a multiple of everything that lcm is a multiple of.
Now, I have taken that concept and implemented it on Ideone, and you can see that it arrives at the right solution, using a simple algorithm, in almost no time.
Check out your main loop; you're incrementing the possibilities with ++, but since you know the answer must be a multiple of 20, so why not start at 20, then increment with x+=20; then just check if it's divisible by 19, 18, etc. This gives you a 20x speedup.