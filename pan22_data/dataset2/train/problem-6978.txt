Have Varnish strip the Accept-Encoding headers from the incoming requests, that way your backends won't try to gzip (iff they're configured to do so), and Varnish can parse your backend response objects for ESI includes. Varnish will then present to your Nginx proxy
I've got a very similar setup running in production (without the SSL termination), and I've found it works quite gracefully.
That way you don't have to delegate your ssl, gzip requests to one back end server, and the ESI requests to another. 
I've serveral backends (one is nginx+passenger) to combine via ESI. Since I don't want to go without gzip/deflate and SSL varnish can't do the job out of the box. So I thought about the following setup:
Based on the diagram, I'm not sure exactly what what you're trying to do (what is ESI?).  However, there's a small, fast load-balancing front-end server called "pound" and it will handle the SSL layer for you.  It could sit alongside Varnish on the front end on port 443 (I assume you have Varnish on port 80?) and pass the SSL traffic directly to nginx (SSL can't be cached anyway, so no point in going through Varnish).  Normal, unencrypted traffic would go to Varnish as expected.