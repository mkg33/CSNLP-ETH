in any case the way you build your code is prone to side channel attacks (especially timing attack). In the web, you may find solutions to password hash comparison timing attacks but none towards username timing attacks. In many contexts such as records/document management users are horrible in password decisions. They have words from their usernames in their passwords. 2FA authentication is not an option. I have seen examples like username = sarah.johnson@xxxx.gov password = sarah1 when pwd is limited to 6 digit alpha-numeric. You would get Sarah123 in case of 8 digit uppercase+lowercase+numeric constraint. Therefore, timing attack against username and then dictionary/birthday attack on password works just fine on such contexts. Hacking valid usernames (which are mostly real mail addresses) is often overlooked. In your case + you have password hashing if the userId matches, your code exits much earlier if userId is invalid. Remember password hashing algorithms should be slow enough to fight brute attacks. This opens the back door to the timing attack. The attacker checking the response time difference can easily pick the valid usernames from invalid ones. In fact, the attacker would get most if not all of your usernames in one attack episode. 
colleagues have pointed out all the major mistakes. i want to stress the deadly mistake of storing the plain-text password in the DB. check this out as a starter. This as an advanced implementation. 