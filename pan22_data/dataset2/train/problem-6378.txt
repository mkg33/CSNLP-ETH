The part where I said there could be "consistency checking here" would be important if the combination of input and previous state does not make a valid mutation. For example in the case of a state machine you may want to verify that the state transition is valid and, if it isn't, throw an exception or simply return false or something (which are both safe at that point in the code). You can't do that before the lock because your checks may be working with data that changes under your feet, and you can't do it after changing part of the combined state because then aborting the mutation part way will leave the object in an inconsistent state.
A general tip from my experience is to keep locks as short and simple as possible, not too many calls and calculations, and very simple flow control. You want to get the information you need to perform the full mutation, then lock, perform the mutation leaving the object in a perfectly consistent state at the end, and unlock asap. You can follow the same pattern for pretty much anything.
Java isn't my first language, so bear with me if I confuse the syntax a bit. I agree that your copyFrom is not atomic in that the changes are externally visible before the copy is complete. I would also say that it isn't atomic because the origin is not locked and so could change while the copy occurs. Yes, I believe this is a possible point of deadlock - in general I believe it's best to always avoid firing events under a lock for this very reason. 
In terms of exception safety, notice that I follow every lock operation with a try..finally and a single unlock in the finally. This makes the code clear, and exception safe with regards to unlocking. In terms of exception safety regarding the internal consistency of the combined state of X and Y (for example if Y is always meant to be the string representation of X or something), you would perform consistency checks before any mutations but after entering the lock.
If you just want to ensure that copyFrom is atomic in that sense that no intermediate state of the copy is visible externally, then you could do like this:
I would also urge you to think clearly about the reason for the copy being atomic. Specifically, are X and Y coupled to each other in such a way that the object would contain inconsistencies if only X or only the Y was copied or changed? Think about the following: