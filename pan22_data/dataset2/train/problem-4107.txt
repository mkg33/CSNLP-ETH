VocabularyFile. Combining the underscore with PascalCase is not typical for C++, it looks more like Ada.
Good that you’re returning the vector by value as a normal return value — many people try to avoid that for outdated reasons.  But, again you did not make the function itself const, so you are implying that calling this will modify the file object.
What is the purpose of max_size_source and max_size_target? They are defined but never used. Your IDE should tell you this.
will show up in the source editor and code UTF-8 bytes in the character array, regardless of what ANSI code page is in effect when you run the compiler.
For display:  if you are outputting to the Windows Console, the normal 8-bit stream will use the current code page.  In the past, I’ve had inconsistent results using Microsoft’s library just switching to the wide calls — but that was years ago; maybe it’s fixed now.  I got proper output by using the raw Win32 console output commands instead of the stream wrappers that feed standard output to the console.
The parameter s should better be named exit_command. Its type should be const&, since it is not modified in the function. Instead of std::wcin >> ss, you should rather use std::getline(std::wcin, ss), because otherwise pressing Enter does not provide a good user experience. Oh, and rename ss to line, to make the code clearer.
Since the string "Please enter" is duplicated, you could save it into a variable at the beginning of the function:
Why is this passed by value (making a copy)?  And I find it odd that “checks if words are in file and returns row of it” would also modify the file object!
You should start the presentation of the code with Vocabulary.h and Vocabulary.cpp, since these are the most important data structures in the program. Without reading these files first, it is difficult to understand File_Vocabulary.cpp.
Second, the const in the parameters don’t have meaning there.  It is useful in a function definition, but ignored in a declaration so omitted as not being part of the interface contract.
In Vocabulary.cpp, the operator>> looks misplaced to me. It clearly belongs to the other code that is concerned about the file format. By reading the code alone, the file format is not easy to guess. Therefore you should have included an example vocabulary file along with the code.
In Vocabulary.cpp, in method operator<<, you should replace os << x + L" " with os << x << L" ", to prevent unnecessary string allocation.
Wait … the for (;;) or while (true) is completely useless. As is the whole function. Why should the user enter a specific word to close the window? Just let them press Enter once. The whole function should be removed and replaced with the parameterless keep_window_open below it.
By the way, the inline is not useful for functions doing interactive I/O, and the return at the end is redundant. You can just remove both.
?  Note also I changed the return type to indicate its actual domain.  Even if you just make that a typedef with no compile-time checking, it still is good human documentation.
The class VocabularyFile does too much, in my opinion. It should only have two methods at all: save and load. All the other operations can be done in-memory instead. Since this program is handling vocabulary, there will not be more than a million entries in a single vocabulary file. (No human being could ever remember this many vocabularies.) Therefore you will probably not run into an out-of-memory situation.
Meanwhile, the font loaded in the Console will not display characters outside of the current code page (or closely related ones).  You may need to switch to a Unicode font in the Console’s system menu.  A simple program to print the alphabet (in each language) will tell you if it is OK to proceed.
The variable names in words_to_line are bad. Rename sv to words and ret to line and x to word. This will make the code intuitive to read:
In Vocabulary.h (and many other places), you should name the variables properly. org and tar are not useful, since tar is the well-known Tape Archiver. Better name these variables source and target. Oh, I see, you did that for the source_words and target_words methods. In that case, I change my advice to "Be consistent in naming things". Since methods must not have the same name as fields, prefixing all fields with m_ or some similar prefix has become common sense. Then you have source_words() and m_source_words, and the reader doesn't have to guess anymore.
As far as the use of wide strings (note for others:  On Windows wchar_t is 16 bits), it is necessary for calling Win32 API functions.  But for most uses in the program, it is easier to just use utf8 everywhere.
Here are my remarks, without any further structure or grouping. I started reading the code top to bottom, but then started to jump around.