If you don't mind the extra comparisons, we can just use a do/while or even a regular while.  Absent compiler optimization, the original code already does this many comparisons anyway.  
If the extra comparison is too big a hit on performance, we don't need to check what the character at current is again.  We can just check the count in the previous if, where you decrement it.  
If you are doing this a lot, you could do this faster by building an array of the same length as the string which stores the location of each match.  Then this whole method could be as simple as 
Furthermore, you don't actually use the flag. Thus, if you intend to break out with the flag, you don't need to break; - if you want to use break, remove the flag and use while(true). Or even better: use some sensible border checking in the while loop so that you also can handle malformed input.
It's probably a trivial difference in performance, but if we exchange the two comparisons, it will do one fewer.  That's because if the first comparison is true, we don't have to do the second comparison.  And the originally second comparison will be true once more than the first.  
If matches is sparse, you might consider making it a HashSet instead of an array.  The array is probably faster, but the HashSet probably uses less memory.  
Both loops use exactly the same principle, just in an opposite direction. You might consider generalizing this by declaring the startingBracketType, the oppositeBracketType and the offset in variables, and modify the loop accordingly:
You don't use the flag variable.  We can get rid of it and just say while (true) or for (;;) with the same effect.  