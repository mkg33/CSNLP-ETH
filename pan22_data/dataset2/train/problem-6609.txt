So if possible always go for the system testing in a real conditions. If it is not possible, you can still run load tests testing against a scaled-down environment, however don't expect you will be able to exactly extrapolate the results like this machine has 10Gb of RAM and is able to survive 1000 RPS, that machine has 20Gb of RAM therefore it will be 2000 RPS - it won't work this way. 
I work in a company that is entirely on the cloud and we have started a stress testing project. The idea is to load everything in production to a new environment and run stress tests on it to find the total capacity of the system and where the bottlenecks are. 
To calculate capacity we used to (and some still do) use a calculation to predict when capacity will be met or if the response time is below satisfactory levels.
First of all check out Can a proportionately scaled down testing environment find performance load issues? question and its answers. 
It is always better to stress the entire system and use a production-like environment (or even production). 
Now, I remember a time when we stress tests physical servers as well as private clouds and I remember that it was almost impossible to get a complete copy of production and all its moving parts. Also, even with stress testing tools like sysbench, Jmeter and ab, you never could exactly simulate traffic just like production. 
We would usually monitor and profile production as much as we could, identify an issue and then try to fix that specific issue by simulating it in the stress testing environment.
Considering that the project to recreate production and stress test it is quite time and resource consuming, is this the best way to go to find bottlenecks in the system and measure capacity, or is the "old" way better?
An applicationâ€™s underlying infrastructure is constructed of many different components such as caches, web servers, application servers and disks(I/O). Bandwidth and CDNs also play a role in its function and therefore have to be taken into consideration during scaling. Each component behaves differently in the application according to how it was configured and scaled. However, the tiered structure makes it difficult to calculate how each should be tested and scaled.