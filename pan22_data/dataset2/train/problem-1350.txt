This component can handle the shared needs of tracking HP and dying, and expose hooks to attach more specialized behaviours. Here I've shown an example using Unity Events, so you  can use the Inspector or scripts to wire up a receiver to act on damage or death events, regardless of the type of script it's defined in.
I want to implement a damage system that works across both living items (Entity) and environment items (Environment). The key components of this is that I need to be able to trigger something to take damage from another script, be it a collision with a projectile or a blast radius trigger, etc.
Both entities and environment items can be damageable (ie. entity death or environment destruction), which (to me) requires an interface to make the projectile collision (and other) system easier.
Please note, I am struggling with how to represent this best, let me know if it needs clarity in an area.
In this case, if player characters, enemies, and environment objects all need to take damage, then damage-ability doesn't say much about what the thing is, it's a behaviour each of these things has. So we can model it as a component attached to GameObjects of all these types.
Player is obviously way more complicated than a regular Entity, but also has a more customized death.
The two approaches I see involve interfaces or inheritance (or maybe a mix). While the inheritance appears necessary to copy the similar code between all items from a base class, it does lead to some issues where only the parent class method is called (defined in collision example). Although interfaces would solve this, I would also wind up duplicating the common code that inheritance helps with.
I'm also assuming that if I moved the IDamageable interface to each item that inherited from Entity it would then be called on the subclasses? But in that case I would have to implement the method separately each time, even if there was duplicate code. At the same time, that would enable some entities to take damage differently than others (ie. if wearing armour, etc)...
Entitys all have health (and some other common attributes), as well as a shared but extendable (through inheritance) death mechanic.
Attached on its own, this will let you create destructible objects, and it can be freely mixed with other components to create more specialized behaviours without duplicating the core HP/death logic.
This underlying issue (calling specific subclass methods through cast parent class/interface) is most noticeable in the Projectile collision script. As noted in the script comments, I understand that since the Entity class is what implements the IDamageable interface, it is what is returned.
How do I properly handle the relationship between taking damage and dying, if one is an interface and the other an overridable base class method?
Obviously this issue is much deeper than a damage system, but it was the best example I could think of that illustrated this problem.