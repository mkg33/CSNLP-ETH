Where are CollectionB and CollectionC coming from?  The approach I'd shoot for is to have a variety of factories that all accept the same type of input, and then store them in some type of collection.  For example, if one has a list of objects to be created, one object per line, and the portion of each line before the first blank defines the type of each item, one could have a factories that take a string and yield an appropriately-configured object.  For example, if the input looked like:
I've hidden the switch statement in the client code, but you could move that into the blackboard as well.
For example in this case I would want to send in a database connection for the DatabaseSaver and a file path and name for the FileSaver and a URI for the TcpSaver.  You believed that providing that configuration information for building the implementation object somehow sullied your design, but I don't believe it does.  
one could have a SquareFactory, LineFactory, and TextFactory all of which inherit from GraphicObjectFactory, which accept a string and return GraphicObject.  One could then have a Dictionary that maps String to GraphicsObjectFactory, and put in it an instance of each of the above mentioned factories.  To allow the file reader to handle more types of graphics objects, just add more factories into the Dictionary.
Let's move the example ahead a bit by showing how I might pass the needed configuration item into the factory so the IPersistable implementation class can be constructed around that extra configuration information.
What data each concrete Impl needs is now hidden from both the Factory and the client code. However if you need more data in your Blackboard for Impl(x+1) you will need to update every place in your code that creates a Blackboard.
This feels very redundant, and off somehow.  What would be the best way to abstract the actual parameters of the factory?  I feel like with the above switch statement, I am strongly coupled to the implemenations of IImplx, even if I don't have a direct reference.
That is a proper working Factory method. It is dependent upon the type string that you pass in.  That is expected, because you are telling it that you are building a specific type and that is expected.
I became a little lazy on that last one and didn't implement it all because I know no one will read all of this.  I will leave you with the entire code listing which you can run and examine using LINQPad.
Depending on application, over-constructing the Blackboard like this may be expensive for you. You could construct a cached version at startup, or you could make the Blackboard an interface and have your client code derive from it.
I mean the whole point of a factory is that something tells it to build a specific implementation class. In my case I create a list of strings which are then passed in to the factory.  Imagine those strings were loaded with other information which configures my IPersistable implementation.  That would be fine.
So I have a series of objects, which I will call Impl1, Impl2, and Impl3.  They each implement an interface, called IImpl.  I have a Factory class who's task is to retrieve the ImplX which is appropriate for a given circumstance, and pass it on to its callers.  So the code in the factory looks like:
So depending on the arguments passed in, different instances are selected.  All well and good and works ok.  The problem now is, that I have a class which needs to call this factory method.  It has no references to IImplX, which is good, but it winds up having to know exactly how to construct the input array to GetInstance, in order to ensure it receives the correct kind of instance.  Code winds up looking like:
I suggest we use an IPersistable interface which supports one public method named Save().  It'll look like the following:
You can now copy that C# code and paste it into a LINQPad (http://linqpad.net) session and add the following main method and it will work beautifully.
How about some kind of intermediary blackboard that the client code constructs before calling the factory, and each concrete Impl can poll to construct itself?
However, what you are wondering now is what happens if the type you are requesting to be built by the factory needs some other parameters so that it can configure itself.