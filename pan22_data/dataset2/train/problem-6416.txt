Unless you are familiar with Dockers use of iptables, then switching it off completely may cause more issues.
The easiest solution is to use the --outgoing-ip command option with docker run commands.  This example represents a container with an outgoing IPv4 address. For IPv6, use --outgoing-ip6 instead.
I understand that Docker uses MASQUERADE and that it could be possible to switch that off and configure iptables manually as an option. However, I wonder what other options are available and what is the option that could be recommended.
An alternative method is define this in your network definition and add some iptables rules, youâ€™ll have something like this:
The packets generated in the container are being forwarded via the Docker hosts interface rather than being generated by the host. The src hint added to the default route does not take effect as the packets already have a source address.  I believe iptables masq only chooses the source IP address based on the outbound interface, so I think you are stuck with inserting a new rule before the default MASQ rule (like the serverfault answer).
The issue is that the container must be on the custom network, because it connects to other internal services on that network.
I have already tested to use --network=host and that works well because this puts the container on the host's network (where it's working).
Software run on the server connects to a public internet endpoint which is behind a firewall for whitelisting IPs, hence it needs to use the static IP for outbound traffic there for things to work.
Then connect your containers to this custom network created. All traffic for these containers will go through the specified IP Address.