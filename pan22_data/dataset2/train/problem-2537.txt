If you want to make it asynchronous you'll need to store the callback as a member variable, but return immediately in CheckRange. Start the actual processing on a separate thread by e.g. using a BackgroundWorker. Once this execution completes, you can call the stored callback with the result.
I don't see how this runs asynchronously. callback(_status); will still only be called after all processing is finished, parallel or not. In this case this makes the callback rather redundant, as it does the same as a simple return value.
the amount you are locking is not so cool.....  I'd make an "Add" method that does your locking for you
general rule of thumb with multithreading..... do all your synchronization in the most minimal tiniest piece of code as possible.  ie, try and make it all go through one spot so you have limited points of failure.  ( personally I tend to put things through synchronized queues )
The only issue I can see is if your implementation of IValidationCondition is not thread safe. It doesn't sound like something that would have any state, but I figured it should probably be stated explicitly in the code's documentation (either as a requirement of the interface or the UrlChecker's constructor).
Have you considered using a ConcurrentDictionary rather than implementing the locking yourself? It's bundled with the Reactive Extensions if you're still on .NET 3.5.