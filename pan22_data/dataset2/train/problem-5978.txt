The builder pattern really shines when you have complex logic around what you are trying to construct.  I use this pattern frequently in my unit test projects.  If I need to setup some dependencies that require mocking, but the interactions aren't central to my test, then I don't want to see it in my test.  A builder is also useful for setting defaults that are required by the object under test, but again, not central to what I am trying to test.  Putting all this code in a builder gets it out of the way.  It also keeps the code DRY (Don't Repeat Yourself), so that if there is a change to how that object is instantiated, there is only one place to fix all my broken tests.
If you are looking for a way to avoid a long constructor parameter list, I would suggest waiting until it gets long, and then evaluating what your class is doing.  Perhaps some parameters are only needed during the execution of some method.  If that's the case, just pass those parameters in when you call the method.  If you feel you can't do that, then maybe the class is starting to violate the Single Responsibility Principle.  Look to see where those parameters are used, and maybe you can identify which ones go together, and split out another class.
It's a useful pattern, but I think your initial assessment is right: that this use case is too simple for it.
Builders are often employed when complex structures or records with lots of attributes need to be set. But more simply they are used to keep an object immutable. A prime example of that is the StringBuilder class which is used to build immutable Strings: the object isn’t very complex – in fact, in terms of data it’s as easy as it gets – but the logic to create them might be.
Immutability is a highly recommended feature of classes. This is why you shouldn’t choose the second method you proposed, i.e. have a class with lots of setters. In fact, setters are often code smell.
The StringBuilder class is needed because strings themselves are immutable for performance (and other) reasons. As a consequence, lots of operations on strings create new strings. If many such operations are chained, this becomes inefficient. The StringBuilder class mitigates that by providing a mutable string which can be modified repeatedly, and only then transformed into an immutable string.
Another example from one of my projects was a complex class which represented a special class of graphs. Again, for performance reasons and to keep its API simple, this class was designed to be immutable. So in order to to create and mutate graphs I provided a builder class which exposed methods for modifying its internal graph structure, and a conversion method to an immutable graph.