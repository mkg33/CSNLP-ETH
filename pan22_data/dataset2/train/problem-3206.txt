so if the spec changes it is much more obvious where in your code you have to make changes. For example: 
The other answers here are very good, especially the accepted one by Brendan. I would like to add one additional comment. You wrote:
The result of dividing steel by 0.5 isn't an amount of steel. It's an upper limit for the number of whistles you can make. So write
It is very common for new programmers to start wanting to make unnecessary micro-optimizations right off the bat; especially in areas that don't really matter (e.g. writing a program that say, generates image files, but trying to optimize the code that checks if an output filename string is valid.) Don't go down that path! Design -> Implement -> Test -> Profile -> Optimize -> Test, and only do the last 3 if your performance requirements aren't met.
Do not worry about wasting a few CPU cycles here or there if it leads to clean, maintainable, clear code, especially during initial development where you may be changing things unexpectedly. You want to avoid premature optimizations that both distract you from your real goal and lock you in to a certain implementation that cannot be easily changed if and when it is necessary.
A final subtle point is that you've stated a whistle needs an X and a Y and you've added X's and Y's weights (0.75 + 0.35) and implemented a function to divide by 1.1.
I want to touch on your comment about making it "more efficient" with just a simple comment: Don't. Write your code, get it working. Code cleanly and do what makes sense to keep your design straightforward. Document your code, think about others who might view or work with it, and think about yourself in the future coming back to it and not remembering what you were thinking when you wrote it.
Now the big thing: You don't have "steel". You have "feet of steel". What if the spec changes and the amount of steel is entered in meters? Or in pound, and you have to calculate the length? Better to write
I know this is may be general advice and a bit premature, but if you keep this in mind (as well as all the information in the other great answers here) you will be setting yourself up for a smooth and productive experience.
Once your program is written, then ask yourself: Is it not meeting the hard performance requirements I have set? Is the UI too slow? Is some algorithm here or there taking too long and actually affecting usage of my program in a noticeable and negative way? Am I running out of memory somewhere? If so, then first concentrate on improving any algorithms or logic on a higher level; perhaps, for example, you are sorting a large amount of data and it is definitively too slow or resource intensive -- first consider a different sorting algorithm. After you are satisfied with that, then if necessary you can proceed to add further micro-optimizations but only after you have clearly identified where the actual bottlenecks are (e.g. profiling, or measuring function times, not just blind guessing). 
Your commenting is poor.  Commenting is difficult for beginners because it's hard for you to tell which parts of your code are obvious and need no more explanation, and which parts would benefit from having comments added.  As you gain more experience, you'll get better at this.
You have some 'magic numbers' embedded in the code which are a really bad idea as they make it difficult to maintain or change. You should separate out the fixed ratios and give them meaningful names. Using #define for a numerical constant isn't too bad in C as it doesn't have a const modifier. So add #define CLAPPER_BRONZE 0.35 etc.
Use comments to document the PrintLine function, not the places where it's called.  It's pretty obvious that it prints a line, so you don't need to keep saying it.
On the other hand, you don't document the two Calculate functions at all. That's the only part of the program that really needs explaining, since it's the only part that uses facts specific to the problem that you're trying to solve (e.g., what materials you need to make a bell or a whistle.)  You could say something like
Most of your comments are completely redundant because they don't add any explanation. For example, you have several instances of
It would actually be much better to capture the knowledge you have about the domain more directly and transparently in the code. If you're told making a widget needs an X and a Y then code that. Then worry about coding what an X needs. This may seem like overkill but it will be much easier to change the code to adapt to changing circumstances. (E.g. we switch to making X's out of something else.)
In a similar vein, your comments on the lines that read user input don't help the reader understand the code: it's obvious that those lines read in the amount of steel, brass and ball bearings.