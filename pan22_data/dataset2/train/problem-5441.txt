The function returns some ID values based on XML data.  It was being OUTER APPLIED by various procedures without issue, until in one situation it returned about 60,000 rows, in which case the procedure execution time took 18 minutes instead of a fraction of a second.
I've just finished debugging a problematic SQL Server 2012 table-valued function.  It was declared to use a unique column in the table:
Can anyone suggest a reason why this might happen (e.g. memory not being freed, or something).  I've been using SQL for over ten years and never seen behaviour like this (the behaviour was replicated on two servers).  
Before debugging and altering it, even after the query had completed (18 minutes' worth), SQL Server remained extremely unresponsive.  Simple queries took minutes rather than milliseconds, and the SSMS GUI continuously froze and showed Windows' not responding message.  This lasted for about an hour each time before SQL seemed to assume normal speeds.  
If you were profiling at the statement level to understand the performance of the function, then the profiler would have had severely affected the process of the system.  SQL Server applies the function to every row.  If you have 60,000 rows, then you will have 60,000 invocations to run through.  That is a lot of profiling data.
Or, can anyone suggest TSQL code to help investigate different areas where the problem might lie?  I've found code to test for locks, but there was nothing 'locked' here, the transaction had completed and nothing was being executed (by my apps) at the time.
Our application uses functions heavily.  We have learned through experience to exclude functions from profiler traces.  Any time we profile functions, the performance of the entire system slows to a crawl.