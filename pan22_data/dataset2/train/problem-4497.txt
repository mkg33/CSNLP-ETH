One issue with your approach is your memory usage is \$O(n^2)\$.  You are building up the entire Pascal's Triangle, and subsequently printing it.  If you simply want to print Pascal's Triangle, you don't need to keep the entire triangle in memory.  You can simply generate and print it row by row.  Since you generate the next row from only the previous row, the memory requirement is simply two rows, which is \$O(n)\$.
Instead of needing to keep track of the last row, and feed that back to generate the next row, we can package that up into a generator function, which can prime the loop and do the feedback itself:
I have written a program that takes a number n and prints Pascal's triangle having n number of rows. 
There's an even better way to generate the Pascal's triangle that only requires O(1) memory. It can even calculate a certain row directly without requiring previous rows to be computed.
The following is a profiling run of all of the methods I've seen above, with some improvements to the I/O.
row[:-1] is all the values in row, except the last one.  For example, if row is [1, 3, 3, 1], then row[:-1] is [1, 3, 3].  Similarly, row[1:] is all the values of row except the first, so [3, 3, 1].  zip() takes the first value of each of the lists, and returns those as the tuple (1, 3), which get assigned to x and y respectively, which get added together to get 4.  Then, zip() emits the next pair of values, (3, 3) which results in 6, and then the final pair (3, 1) results in 4, producing the list [4, 6, 4].  The [1] + ... + [1] adds the bookends, which results in the next row of the triangle: [1, 4, 6, 4, 1].