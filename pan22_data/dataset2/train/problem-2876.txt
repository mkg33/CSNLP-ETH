There's the case where the index relation is simply missing. The catalog entries exist, but the backing file doesn't.
Another kind of corruption is a simple bit-flip. That's where you pick a random (or targeted) byte from the index relation and change it from a 0 to a 1 or vice versa. This can happen in reality if memory errors (including gamma radiation, heat problems, etc) cause an index page to be corrupted in-memory before it's flushed to disk. It's trivial to write a program in C, Python, or whatever to do this.
This is one of the reasons why "fuzzing" is so interesting. Because it's very, very hard for programmers to anticipate every possible state and guard against every possible problem, so problems can often be found by making random changes and seeing what breaks.
A further kind of corruption is where the index is structurally valid, but outdated. It doesn't reflect the current table contents because for some reason some updates to the index didn't get written. You can create this situation by setting indisvalid to false, doing some inserts/updates/deletes on the indexed relation, then setting indisvalid = true again. Since PostgreSQL ignores an index with indisvalid = f, assuming it's in the process of being built, it won't update it, so you'll have outdated index contents.
Another kind of corruption is where an index has blocks that are simply invalid - zeroed out, replaced with random values, etc. Most likely reading such an index will result in an ERROR if/when that block is accessed. You can create such an index by dding from /dev/zero or /dev/urandom into some offset into the index.
Yet another kind of corruption involves b-tree structure problems, like missing leaves, circular references, etc. The best way to create these kinds of corruptions is to modify PostgreSQL's source code to make it do them on purpose. It'll be difficult to do them using just the index relation.
Assuming you are talking about the indisvalid column in pg_index, or some status field derived therefrom, you can create an invalid (or intentionally corrupt, if you prefer) index like so:
Erwin's answer does a good job of answering the question as originally stated, however you added the comment:
Here, Postgres knows that the index is bad and marks it as such in pg_index. There are countless other ways to create a corrupt index that Postgres won't immediately notice: Erwin's answer, mismatched glibc or other collation behavior between a primary and a standby, writing arbitrary bytes to the files behind those indexes, performing bogus updates to Postgres' catalog tables, and on and on.
Erwin describes a method of creating an index that violates PostgreSQL's assumptions about the index, producing results that are likely incorrect and do not match the underlying table.
The list goes on. Almost by definition, corruption can be anything that isn't the normal state of affairs.