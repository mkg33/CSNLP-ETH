So your sleep does not guarantee a period of inactivity on the serial line or give the device a chance to process one command before you send the next.
(This code also makes the mistake of confusing serial data with strings -- serial ports transmit bytes, not characters)
The Windows API provides an event when the kernel write buffer has been completely drained and the serial wire becomes idle.  Use it.  Even if that means throwing away the C# System.IO.Ports.SerialPort class.  Ultimately, that's the better approach: don't use the horrible wrapper provided by .NET web developers, use the Communications Functions API that was written by people with hardware experience.
As far as reviewing yours, I can't get past the usage of Thread.Sleep().  It's wrong, irredeemably broken, because the sleep starts when the data is appended to the kernel buffer, not when it gets transmitted.  Actual time of transmit is affected by how much data was already in the write buffer, what busses exist between the UART and your CPU (for example, is it connected via USB?  Then transfers have to wait for USB timeslices and may get delayed behind bulk transfers to USB mass storage devices), UART flow control, and then there's the actual transmission time based on the number of bits (including start, stop, and potentially parity) divided by the baud rate.