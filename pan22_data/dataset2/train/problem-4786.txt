A fundamental part of understanding software architecture is to understand how your target platform will shape design decisions.
One of the things that I think you can only learn with experience is to acquire a mature attitude to risk. Many of the decisions in programming are concerned with risk. Should we release now, or write more tests? Is it wise to use a new open-source library that has just become available? Should we move forward to the latest version of X? We know the customer's stated requirements, but how likely is it that they will change? How much should we invest in extra resilience or security? In the end, these are the judgements that make a project succeed or fail.
The best way to prove that you have this knowledge is by putting together something like an online portfolio. What were some interesting projects you did in school? Can I see them? What personal projects do you work on? Do you contribute to any open source projects? 
By way of example, I've lost count of the number of times I've seen a new developer put out code that runs a 'select *' on a large table ... multiple times, then wonder why the computer grounds to a halt when that page loads.  Only to come to the "conclusion" that locally caching all that data is the right answer.
And if you ignore all of that advice, at least try and get really really really good with SQL, because EVERY job you will look at is going to need it.
Then there are the non-computing aspects of the job. How do you handle a boss who has made an incorrect decision? How do you handle customers who try to make design decisions for you, and do it badly? How do you handle an experienced and respected senior developer on the team whose knowledge has actually become rather rusty? How do you manage conflicting demands on your time?
For each of these constraints there are architectural designs to help alleviate them, but all designs have drawbacks.  Understanding those along with your target platform will usually point the developer to the right solution.  
Regardless of the type of work you do, the code is going to be constrained by the hardware it runs on.  Processor speed isn't necessarily that bottleneck.  Often it is memory availability, disk transfer rates or even network transfer speeds.  
tl;dr: Give me a link to a list of cool things you've done, and be able to setup your own workspace.
In my experience (in the UK), a lot of current degree courses offer a breadth rather than depth of knowledge (a "flavor" of lots of different languages, rather than a decent length of time programming in one language)
Secondly, I think CS (and even Software Engineering) courses find it very difficult to teach the things you will only encounter on large projects: how do you grapple with half-a-million lines of code, how do you work on a team with 40 developers?
Firstly, I think CS degrees vary widely in how "theoretical" they are. Some try to teach you about programming languages and even vendor-specific products that you are likely to encounter in the real world; others focus much more on teaching the fundamental principles. Personally (as someone who has always worked in industry) I would much rather have people who know the principles and the theory, because that knowledge will remain useful for much longer. But whether your background is theoretical or practical, on your first real project there are going to be a dozen technologies or tools you have to master that you have never seen before.
Developers who have spent any time at all on a home project or on an internship tend to have a real advantage in this area.
By that I mean, if you have Java listed on your resume, I should be able to hand you a laptop with a clean OS on it, and you should be able to write and run a basic hello world program. You should know how to download, install, and run Java, and you should know how to write, compile, and run a basic program. You should know how to look new stuff up in the documentation, Google, and Stack Overflow. That's how programmers get stuff done in the real world.
This often means that graduates have only spent a few weeks developing in a language (possibly for one coursework for one module). So by the end of their first week or two on the job, they may have done more programming in a language than they ever needed to in order to pass their degree.
First off, employers expect entry level employees to be inexperienced. So most will not be looking for you to have a lot of hard skills. Some will want to know that you have the right aspirations and personality traits, since you will learn the skills you need on the job. Most will want to ensure that you have a minimum level of competency with one particular programming language. You should know what programming language you want to spend the rest of your life using, and get good with it. That will help you not just to land a job, but to land the right job for you. Other important things that may be neglected by your school are good Testing practices (including test driven development), and engineering principles. Experience writing code is one of the most valuable things that you can get, because it will be expected that as a new grad you will have virtually none. Make sure to take courses with lots of coding, not just theoretically knowledge. Those courses are fine too, but they shouldnt be the ONLY ones. Project based classes, open source or personal projects and internships are all critical.
TBH, I think they should spend their entire senior year working on a mid sized project.  Something run how one would be in the real world.  Replete with hardware, software and time constraints - as well as changing priorities and requirements.  All of them would benefit from having experienced that before showing up at a new job.