In practice, we also want programs to run fast.  For speed considerations, we do care where the data is.  We want the data we are accessing most often to be stored in hardware which permits the fastest access.  Our programs would like to run entirely out of DRAM.  However, we often don't have enough DRAM to do this.  Virtual memory is a solution.
The basic concept relies on the fact that a modern CPU can manage translation tables keeping track of "what address ranges has a certain process been allocated to use, and which physical addresses (think A00..Axx lines on a memory bus), IF ANY, currently are used to actually store the data. "IF ANY" because "none at all" is a possible and acceptable state: In this case, an error condition (a so called "page fault") will be raised on a hardware level - and this error will trigger an OS-level handler that can eg load memory contents that have been written to a swap file back into any free location in physical memory (in case of a read) or find an actual location to put stuff (in case of a write), update the aforementioned translation table, and only THEN hand control back to the process that attempted to access that memory.. and which will be none the wiser of what happened.
2) allows a larger virtual address space (e.g. 64-bits) to be mapped to a smaller physical address space (e.g. 32 or 64 bits)
This can happen within a single process or OS - most BSD UNIX derived OSes have a single read-only page of zeroes, that can be mapped into any zero-filled virtual page, typically COW (Copy On Write - read only zeros, writes trapped and page unshared and made writeable).
When a program accesses a logical address, the CPU looks in the map for a corresponding physical address.  If it's found, the memory access proceeds as expected; if it's not found then a physical address must be allocated and the content loaded from some other storage - the "swap space".  If every physical address has already been allocated to some logical address, then some logical addresses must be "swapped out" (their content saved back to the swap space) to make physical addresses available.
Virtual memory increases the amount of data a program can address.  From a software point of view, we (generally) don't care where they data is stored.  It could be stored in physical DRAM memory, it could be stored on a flash drive plugged into the machine, or it could even be stored on a spinning platter.  What the software cares is that, when it asks to access that data, it succeeds.
In theory, it could just read the data directly off of the disk.  However, there's reasons it isn't done that way.  The programs don't want to have to be aware of all of these complications.  We can and do write software which intelligently puts data on disk (it's called caching).  However, it takes a lot of extra work.  The fastest we can do it in code is:
An astute reader will notice that, even if the data is in memory, we had to have a conditional to check whether it is there.  This is much slower than just operating in memory directly!
Virtual memory solves this problem by doing the check in hardware on the CPU.  The CPU is in a position to do this virtual memory operation extremely quickly because it can dedicate hardware to it.  Any attempt to do this in software alone must use the general purpose parts of the CPU, which are naturally slower than dedicated transistors would be.
It can happen between processes - e.g. UNIX fork() creates child processes that share almost all virtual memory in a COW manner.
The maximum allocated memory is the size of the swap space, which can be much larger than the installed memory.  It might be helpful to think of the swap space as the "real" memory, and of RAM as a high-speed cache for the swap space.
This leads to why we always page the data back into memory rather than just reading it from disk and leaving it at that.  We break the memory up into "pages," each of which is marked as either present or not present in memory.  The operating system maintains this table in a format which is convenient for the CPU to use directly.  Whenever a program accesses data that is present, the hardware on the CPU gives them access to the data in DRAM directly.  When the data is not present, a "page fault" is issued, telling the operating system to go load that page off of the disk to some physical page of memory and the update the table to point the CPU at this new physical page.
It can happen between OSes - e.g. Guest OSes on a virtual machine host can have pages deduplicated, shared COW, etc. (Some recent security attacks have taken advantage of this.)
3) allows a smaller virtual address space (e.g. 32 bits) to be mapped to a larger physical address space (e.g. 40 bits), and thereby allows older applications to take advantage of more physical DRAM.
7) virtual memory can allow parts of the virtual address space to be mapped to files, or to memory mapped on other processors, whether in the same multiprocessor system, or across the Internet.
With virtual memory, the operating system "pages" out data which has not been used in a while, storing it on a hard disk.  This is still accessible, just slow.  If the program requests data that's on the hard-disk, the operating system has to take the time to read the data off of the disk, and move it back into DRAM.
4) allows physical memory that us fragmented and non-contiguous in the physical address space to be rendered contiguous in the virtual address space.
1) allows a large virtual address space to be mapped to a smaller amount of physical memory, with excess "swapped out" to disk, or SSD, or prospectively to NVRAM and other devices.
The key to this whole problem is to minimize its usage.  In practice, we find that operating systems are very good at choosing what data to keep in memory and what data to page out to disk, so the vast majority of memory accesses occur without ever causing a page fault.
5) allows processes to be given their own virtual address spaces, and hence be isolated from each other.
6) allows different virtual addresses that happen to share the same data values to allocated a single physical page.  
(This is far from a thorough description, it's intended to answer the immediate question without getting into relevant-but-unnecessary detail.)