Of course it's brute-force approach, just as proof of concept of encoding. For sure you can make searching for "n-th" number much more efficient (but as it is not part of your question and complexity is not important, I will not elaborate).
As you stated, that complexity is not important, you can even enumerate all integers and count those fitting given sum, once you find n-th you are done.
You can choose integer encoding as you like. Examples: Fixed length 64bit, Prefix code generated with Huffman encoding, etc.
The exponent tuple is (0, 0, 1, 1, 2), and the deltas (pretend there's an extra 0 at the beginning of the sequence) are (0, 0, 1, 0, 1), so this encodes as "0010010" binary. You might want to encode somewhere (beginning of the sequence?) what are the base and sum of the digits, though.
The first $\log n$ bits of the vector tell you how many digits $N$ has. The second $l$ bits tell you the position $p$ (from the right) of the first not-zero bit. The subsequent $M - 2$ blocks of $log l$ bits tell you offsets $d_i$ for $1 \leq i \leq M - 2$. You use these offsets to reconstruct the number quickly, as:
This has a minor inefficiency in that you will never see nine consecutive zero deltas. If you're that desperate for space, you can stipulate that if a zero delta would cause a digit overflow, one is subtracted from it during encoding (and added to it during decoding). For instance, 19 would be encoded as (0 * 9, 0), not (0 * 9, 1). 
Let's say you are dealing with numbers in base $b$ with up to $n$ digits whose digit values sum to $M$. To encode a number $N$ of length $l = \lfloor \log_b  N \rfloor + 1 \leq n$, just create a bit vector of length $\log n + (M - 1)\log l$. 
What about writing each number as a sum of powers of 10 (or whatever is the base for your problem) in ascending order and then delta-encode the exponents with some universal code? You might need to nudge the deltas since most codes start with '1', but if you use e.g. Levenstein coding to encode 122: