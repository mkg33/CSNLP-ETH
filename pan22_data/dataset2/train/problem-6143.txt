First, there's the problem of how to define the boundary. Images are usually rectangular (again, this is a matter of history - if our screens were hexagonal, things would be a bit easier). So, not even the image boundary is a straight line. Do you put the same number of pixels in each row? Do you alternate even/odd? And... is the lower left pixel to the left to the one above it, or to the right? You immediately get almost 10 different standards, and programmers have to remember each time how it goes (even row-major and column-major difference or top-down/bottom-up indexing difference is causing errors sometimes). This brings along the immense problem of conversion landscape/portrait (natural transformation, which is trivial on rectangular grid, but requires interpolation and is almost necessarily a lossy procedure on a hex or different grid). This is even a problem for rectangular pixels (aspect ratio != 1).
Interpolation and antialiasing in general has a lot of algorithms that depend on the square grid. Bilinear interpolation, for instance. All fourier-based processing methods are tied to the rectangular grid as well (FFT is very useful in image processing)... well, unless you do some expensive and lossy transformations first.
Scaling different shapes like hexagons takes more processing, as you cross fraction of pixels.  While a Square is just multiplying each side by the constant. Also trying to plot a hex grid you can't just just do an easy X, Y location. 
Then there's the natural instinct people have with rectangular layout. You have matrices in math, which have the same layout. Similarly, a cartesian coordinate frame is pretty much the easiest to use and understand in most general cases. Getting the index of a pixel at (x,y) is just x+width*y (not the other way around - legacy of scanline indexing). If width is a multiple of 2, you don't even need multiplication. Working with non-right angles makes a lot of complications that stem from vector algebra, when basis vectors are not orthogonal: rotations are no longer simple cos/sin superpositions. Translation becomes weird. This brings a long a lot of computational complexity (would be a few times more expensive to compute), and code complexity (I remember coding the Bresenham's algorithm once, and I really wouldn't like to try doing it in hex).
In both cases, pixels are not required to be square, but are like that purely by convention. Case in point: early widescreen displays used the same number of pixels - both in hardware and software - as non-widescreen displays, but the pixels were conceptually rectangular (the horizontal size was greater than the vertical size) rather than conceptually square as is the standard. Nevertheless, using pixel shapes that do not approximate a square is non-standard and likely to cause massive compatibility problems, at least in everyday usage.
If you are not interested in a general purpose display, but one geared towards a specific purpose, then you can be more flexible.  An extreme example is the 7-segment LED, if all you need to do is display a number, 7 non-square pixels arranged in such fashion is all you need.  Or 15-segment LEDs that allow letters.
That all shows that data in the memory and file formats should be stored as rectangular grid. How you display it depends on the display device/printer, but that should be the problem of the driver. The data is supposed to be device-independent and shouldn't assume what hardware you have. As shown in the posts above, there are many advantages to using nonrectangular pixels, due to human eye physiology and other more technological factors - just keep the data on the square grid, or you'll have a horde of neurotic programmers to answer for :)
Some of the answers already touch this... I think that non-rectangular array in terms of data storage would create almost unimaginable complexity and would be extremely error prone. I've had lots of experience with modeling physical systems where the grid is not rectangular (staggered grids - data points at half-edges and so on). Indexing is a nightmare.
While they may not physically be square.  They are abstractly represented as square, and when shown on displays with lowered resolutions they are seen as squares. Mostly due to laziness, and less processing. 
Despite all this, I actually played with a thought of having a circular pixel arrangement for integration in watch faces (making hands straight lines). When I started imagining how difficult would that make drawing anything as simple as a straight line that doesn't go through the center, I came to a lot of the conclusions I mention above.
From a bystander's POV, I'd have to say it's because the screen you typically watch this on anyway is rectangular. A common aspect ratio is  1920 by 1080. Past a certain length such as 720 allows for "high definition" to be recognized. This could very well be more difficult to achieve with circular or hexagonal pixels.