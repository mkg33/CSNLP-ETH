I'm a MySQL DBA and not a .NET person, but from what I can tell from a quick search it appears that declaring CommandType.StoredProcedure allows you to take better advantage of the capabilities of stored procedures, by making some of the parameters INOUT or OUT, and not just IN.  This might be useful, for example, if you wanted one of the parameters to be the ID of the newly-inserted user, which the SP could return to your code.
If someone could manage to pass the following string value to your application as txt_f8.Text... it would be obediently concatenated into your MySqlCommand()...
Your stored procedure, itself, in a vacuum, as written now, does not appear vulnerable to SQL injection... but that is not the only consideration, and is not the final answer.
This randomly-googled tutorial reinforces the point of not crafting queries with string concatenation, and using SqlParameter instead:
You need to use the SqlParameters in your code, If your sure that there is no possibility of the Sql injection attack, you code is perfect. There might chance for the code maintenance problem to understand what are all the parameters passed. The best practice is use the SqlParameter to pass the values to the SQL statement from out .NET code.
Stored procedures are pre-compiled. If there are any changes to the query we can directly connect to the database server and edit. Code maintenance becomes easier.
If you don't need return values, you don't have to do it that way... but feedback/confirmation isn't usually a bad thing.
It's always possible that it could be updated later and become vulnerable, but there's yet something else to consider.