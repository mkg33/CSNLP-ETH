Two, your code checks each number individually. But you want all primes from 1 to two millions, so you should check if there is a faster method. And there is one: On a piece of paper, you could write down the numbers from 2 to two million. Then remove all the numbers that are multiples of two except the number two itself (4, 6, 8, 10, ...). Then remove all the numbers that are multiples of three except the number 3 itself (6, 9, 12, 15, ...; but the even numbers have already been removed so you just remove 9, 15, 21, 27 ... ), then the multiples of five except five itself (that would be 15, 25, 35, 45 ignoring the even numbers, but 15 was already removed as a multiple of 3, so you start at 5 * 5) and so on. 
Project Euler problems usually need a bit of thinking to get a fast solution. Your code has two problems that make it slow.
One, your code to check whether an integer i is a prime or not is slow. A number i ≥ 2 is prime by definition if it has no divisors other than 1 and itself. You look for a divisor j, 2 ≤ j ≤ i - 1. However, you only need to check numbers where j * j ≤ i: If j is a divisor, then i / j is also a divisor. If j is the smallest divisor, then i / j is also a divisor and i / j ≥ j (because j is the smallest divisor). That means i = j * (i / j) ≥ j * j. So after checking the values j where j * j ≤ i you would have found the smallest divisor. You didn't find one, so i is a prime. 
Why is this faster? You might have divided for example several hundred thousand numbers by 89. But with this method, you just remove every one in 178 numbers; much less work. 