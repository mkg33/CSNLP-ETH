NOTE: More specifically command mode may be called argument mode (as in arguments to a command), the other mode being called expression mode. In my older PowerShell book I just saw it called command mode, but the current doc talks about argument mode. 
In the first line, you're just creating a string, "10.2.0.0,10.1.0.0". PowerShell is going to let you make that string however you want and leaves it alone. Even if you omitted the double quotes, you'd notice that PowerShell won't do the same thing as Example 1...and this is because it's in Expression Mode and won't auto-quote your strings for you in this mode. When I try that I don't get anything assigned. You probably saw that as well.
In the second line of your example, there's nothing special PowerShell is going to do - it's just a string that happens to have a comma in it - it's not going to inspect and modify your string, it's going to just pass it along, where it will fail to parse into an IPAddress because it's not the valid form and whatever parse method IPAddress has can only handle a single IP Address and not a comma separated string of them. 
In your first example, PowerShell is in Command Parsing Mode because your line begins with a command. In Command Mode, PowerShell will automatically quote arguments to a command for you, since quoting everything all the time when working in your shell would be really annoying! This means it is quoting your unquoted IP address values for you, turning them into strings and the ',' (Comma operator) is combining the two strings into an array. Since the Parameter is IPAddress[] (array of IPAddress object), it tries to cast your strings to IPAddress, and it succeeds, since they are individual entries in an array and IPAddress knows how to parse 1 string in that format and creates an IPAddress object with it. At least, I'm 90% sure a combination of those 3 things (comma/array operator, command parsing mode, and casting) is why that works.
However, you didn't specify whether you're intending to only process some scopes. I don't see a comment about you editing your CSV to exclude certain scopes (or in your code), so you could instead skip ALL of this in that case and just call Get-DhcpServerv4Scope without any -ScopeId argument and it will return all scopes. You could then skip all this to CSV and back work.
Let's answer the immediate question at hand: why does your first example work but your second example doesn't. Let's start with why the first one DOES work. It involves PowerShell's different Parsing Modes.
It's unclear to me the reason for the scope rebuilding, since it seems like you're potentially discarding existing 8 day leases (if they have the same as what it was before, maybe they were set to be quite short first) and could get address conflicts if the server re-assigns it before clients with those leases expire. Maybe I'm missing something. Just take care with whatever it is your end goal is here, and good luck!