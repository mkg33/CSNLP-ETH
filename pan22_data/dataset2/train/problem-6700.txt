In the article, they define another "loop" later on with admittedly better code than raw_input. Adding the python line to rc.local also seems like a sketchy idea.
You can check your current runlevel with runlevel. In /etc/rcX.d where X is the runlevel, you can see all services that are started when the system enters that runlevel. I would suggest adding another entry there, near the end like S98mybuttonhandler which will be a sh/bash script calling nohup python myscript.py &. & is a command line trick to tell the shell not to wait on the program, "detach it". nohup is used to prevent SIGHUP from terminating your program. This is usually called when the shell which started your program closes, even if you used &.
Use shutdown now instead of halt. I am not familiar with the later and trying it on my computer made it behave strangely. Alternatively, you can use shutdown -r now to reboot.
rc.local is executed everytime the system changes runlevel.  See more info on runlevels. Basically, during a normal boot, your script will be executed at least once, but it is difficult to say since embedded devs sometimes use tricks in order to get things going. It is also possible that python will not load correctly during that time.
After you've booted, you can use ps aux and check which process are running. You should see a python yourscript.py somewhere.
the system will shutdown when you press the button. But this line is unusable in rc.local and crontab (@reboot python /home/pi/shutdown.py)
Try your script by starting it manually. I assume you can get a shell to your pi, so run it on a terminal an see if it works. If it doesn't then the fault is not related to the boot sequence.
raw_input blocks until the user types something in and presses enter. During boot time, nobody WANTS to press press anything in order for the system to boot. Also, blocking forever during boot is usually frowned upon.
and press the button. Nothing will happen. I assume the script already stopped as there is no raw_input or so!