If you are using Java, one general hint is to buffer both standard input and output. In my last few attempts, the most time was spent just reading the input and outputting the result. Avoid the use of java.util.Scanner, as it appears to be a real dog.
I've managed to get a submission past the CPU limit, using an approach similar to what Winston  Ewert describes above. First I tried it in Ruby, and hit a wall at 5/11 test cases. Switching to Java immediately brought it to 9/11, and a little more optimization got it through.
In the case where we recurse left and then find a node in the range, everything descended from the right of that node onwards is in the interval [i, inf), so we can just call find_in_range again with new parameters and fight the right end node. A little snipping here and there and we'll have selected exactly the nodes in [i, j] in our quadrant. The same argument works if we recurse right.
The way I'm trying to do this is have four BSTs, one for each quadrant. Here's my sketch of the tree so far:
just as a note: your N= and Q= is (IMHO) an almost unreadable mess. (can you not read everything in and then proccess it?)
The only thing I can think of is that there is a conservation of points, i.e. reflections do not destroy create points, so the four running totals are not independent.  We only need to keep track of two for example and the total.  However, this isn't really a big realization which to my mind.
The CPU limits to this problem are extremely tight. I have doubts whether any interpreted language will be able to meet them, unless there is a better data structure than the one I used. Using a compiled language, the time limits are supposed to be 1/4 of that of an interpreted language, but it is way more than 4 times as fast. My recommendation would be to validate your approach using Python or whatever, then reimplement in Java or C.
The problem I'm having is that if we start the first find_in_range and we're already in the range, I don't know where the end-points are. Does anyone have a suggestion for me? If I can solve this problem, the rest is just details.
The perplexing thing here is that this is the cheapest/easiest problem of the lot, and I don't think it is easy.  I already solved Meeting Point, and this seems to be harder than that.
I've tried this problem a number of different ways and I'm still not getting past the speed checks. I've tried using lists and sets as my data structure, and both don't have the required asymptotic performance. @Winston Ewert is right: you need at least O(log N) time for all three operations, and the best way to do this is with a binary search tree.
The data variable will be the index of the node in the list representation of the coordinates we are handed. The whole point of using a BST here, as I see it, is that we can potentially move a whole segment of points from one quadrant to another by grabbing a node that the segment as a whole is descended from and inserting that node into the new tree, updating the count parameter of the tree as we go. To do that we need a method for inserting nodes into trees:
The tricky method, which I'm not sure how to do yet, is the part that grabs the interval in question but no more than that. Obviously, we do not get a specific [i, j] to look for in the tree, since we don't know which tree i and j are in. We only get a range. This method will grab the first node that falls in the range of [i, j] in the tree:
I wrote a solution which takes all the reflections and combines them into a single set of reflection instructions.  For example, X i j followed by Y i j is equivalent to a single "diagonal" reflection, i.e. all points from first quadrant to to 3 rd quadrant.  This was no easy task as you can imagine, but it is correct.  The result is that the complexity is still O(N) but it is done efficiently, i.e. instead of first doing an  X reflection followed by a Y reflection, we do a single reflection.  Unfortunately, this did not pass the online judge either.