Those are transferrable skills, as is the more basic one of being able to use a command line at all. The details of using a particular IDE are not transferrable, unless you understand what they actually DO. The command-line-level skills are also what you need to figure out for yourself why a "new improved" IDE isn't doing what you want when you first migrate to it!
Related to this, also start early teaching them how to use a version control system in a simple way from the command line - not to mention "make!" 
I wouldn't try to impose any less-than-the-most-powerful tool on a pro. I wouldn't on a novice either. However, if someone comes to me already a vim (say) expert, I'd let them use it, and might not even notice. But if they hand me unreadable code, I'll notice pretty quick. 
Furthermore, IDEs can help to improve programming speed with features like autocompletion, built-in refactoring tools etc.
Of course for professional programming work nobody would NOT use the most functional IDE they could find for the task they were doing. But if you throw a complete beginner into the deep end of a tool like MS Visual studio, they are unlikely to have any idea what is going on, and the only way they can create a working project without wasting a lot of time is be following a "magic recipe" provided for them. Personally I don't consider that to be a university-level learning experience.
It may be easier to transition students who have gained proficiency in using a a command-line environment to switch to using an GUI IDE, than vice versa.  If so, starting with an editor+terminal will allow more flexibility in your later curriculum design.
Actually, using vi (or vim) or emacs plus command line commands can be an efficient way of working without an IDE, since the command line commands you need often are only one key-press away!
The vi editor and gedit provide very nice syntax coloring.  They also don't "spoil" the user with auto-completes early in their learning.
An advantage, especially for beginners, could be that it doesn't overexert the students with too much information - in contrast to IDEs that come with syntax highlighting, code style checking, automatic error correction and code suggestion.
In Eclipse, I can integrate testing. I don't need to type every character of the program. I can leave pretty-printing to the system. I can integrate useful program metrics. I can have compilation done automatically. I can search by structure, not just text. And on and on. Emacs is quite wonderful, but it has about 200 textual commands to learn. Life is short. 
The real question is this: do you want to teach your students what is actually going on, or teach them which magic buttons to press in an IDE?
A feature that could be nice to have for beginners is that IDEs normally have a nice debugger which could be used to motivate students to debug their code when they see an error. This is something the editor/terminal combination can't achieve - even if there are command line debugging tools, they are most likely not user-friendly enough.
This is most likely the more lightweight solution. Editor and terminal often don't consume much space (or, at least, come bundled with the operating system so it doesn't really matter) and start fast.
Of course they shouldn't be forced to use a command line "for ever," but IMO they should certainly be required to use it until they understand the relationship between classes or modules with physical files (including any required naming conventions,) how to get the individual parts connected together into a complete application, etc. 
Using editor and terminal can demonstrate students that writing a program can be done without using a huge IDE including a lot of tools, as it is essentially not more than writing down instructions using a normal text editor and executing them.
What I believe is also worth noting (inspired by Ben I.'s answer to a related question, thank you) that IDEs come with integration for professional developer tools like version control systems or unit testing. I am not sure whether this is already needed in the first year of programming, but I can definitely come in handy later.
In a real working environment, there is nothing more confusing than sitting down at someone else's workstation where they have configured an IDE in a completely different way from your own - that's the time when just firing up "vi" in a command window can be the quickest to get "real work" done!
Nor can I find a language that I can't write in Eclipse, since it isn't really an IDE, but a workbench onto which you can plug nearly any tool. Like Emacs, it has a lot of headroom (and isn't unique in that, of course). 
I started programming on primitive equipment (card punch) and came up through every level since. I don't romanticize the old way of work and I wouldn't go back. I wouldn't try to impose primitive tools on newcomers. But then, in CS1 my goal is to teach them how to program effectively. I think that is a hard enough job that I want to ease the path in every way possible - remove all obstacles to thinking about the problem and creating a solution. 
But as I said at the top, it depends on your overall goal. For me, the overriding goal is to ease the process so that students can focus on the programming itself and the mind-expansion that comes from that. If a better tool comes along, I'll work to use that. Key punching was abominable. So was the teletype, ... 
IDEs are most likely a more heavyweight solution. Normally, they consume a lot of disk space as well as memory and have a notable startup time.
Go to local companies and talk to the developers.  The command-line interface is still used a great deal owing to its programmability and extensibility.  My beginning students learn about the command shell.  
Pretty printing is good because it lets me see the structure of a program without first fighting to get it into shape. Not typing close brace lets me think about what I'm trying to create, not the requirements of the language itself. Writing a test for a nonexistent feature and then having the system enter the skeleton for that feature is just marvelous. No cut, switch, paste, or mis-spell and correct. It just works. It lets me get into a flow of creation that I can't do if I'm writing just text. 
It's worth noting that there are multiple "levels" of editors: When choosing the editor, one could choose between a simple text editor without any programming-related features (not even syntax highlighting), more advanced editors that have syntax highlighting, or something like IDLE, which is an IDE on the one hand, but at least in my opinion more like an advanced editor. This could help finding a compromise between a fully-featured IDE and a text editor.
They can assist fixing errors by highlighting them and providing possible solutions. This is definitely an advantage in day-to-day use, however, when it comes to teaching how to find errors, one could interpret this as a disadvantage, as it's possible that students start to rely only on their IDE when searching errors and wouldn't be able to find them without any help.
Of course it depends on your overall goals. For me, however, the answer is clear: Use the most powerful IDE that I can find (Eclipse or NetBeans fit my def). 