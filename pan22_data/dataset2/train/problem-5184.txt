Beware that 86401 second days is nonstandard and against what POSIX supposedly requires. If setting up NTP servers that do this, they cannot provide time for other systems. It can also result in strange behaviors from applications that depended on a particularly formatted time.
Instead, some NTP servers can provide GPS or TAI.  This plus some leap second hacks will get rid of the leap second error corrected by the kernel or user land time sync. 
Red Hat published a good summary of ways to deal with it on Linux if one is using UTC. Note that many sites repeat, smear, or let NTP fix the second of error without needing to show the 61st second.
This all seems like a lot of work to me. I'd rather not see the 61st second, if I could let NTP or the kernel deal with it, via the methods the Red Hat describes.
See ESR's essay  Time, Clock, and Calendar Programming In C  for the actual data structures involved, and some good references. 
However, you need to understand the TAI - UTC offset and what your source time is. NTP time is standardly UTC, so just setting a "right" zone on a UTC synced system will be off by TAI - 10 - UTC, which is currently  26.  
TZ data will need to updated, twice a year will catch leap seconds. If you patch leap seconds for this reason you will need to do it again. (Very likely you already need to update other software more often than this for various reasons.) There will be additional leap seconds, the Earth's rotation change is a physical necessity.  There also is a political necessity of the likely time zone and daylight savings time changes forâ€¦ less technical reasons.
First, the notion that the clock on a computer system must be provided TAI or UTC is not strictly accurate.  I can get and set the time with time zones, for example GNU coreutils date command is very flexible. On a system set to right/UTC (more on this later): 