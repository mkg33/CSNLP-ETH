PS: Error does NOT appear if the offending query is repeated, so it's not strictly related to the query itself, but perhaps with a table update/sync transient.
I currently have a PostgreSQL slave node that is presenting problems, that don't arise in the master node. Seems to be related with the node sync process.
The question is: how can I debug the actual cause of the problem and/or solve/avoid it? Don't hesitate to ask for more info if needed to pinpoint the problem, right now just don't know what else to provide.
What you see is a common experience for anyone running standbys and bigger queries on the master.  There are a couple of possible causes:
The most important option is hot_standby_feedback, which helps against the most common cause (VACUUM removing recently-dead rows).  It has its own costs (might cause table bloat), but the outcome is usually still better than running the same queries on the master.
We did experience the same couple of  times, where in we wrote to master , and reads were from slave. The above errors started appearing when we read from slave but at the same instant some other process due to a functional constraint removed that data. Hence in order to resolve such issues, we added our own "read your own writes" method, wherein there is a requirement for an application thread to read what was just written to db. In that case that particular thread that writes to master will read from master. Yes, the flip side to this is that there is a slight compromise in read scalability. We moved all reads to slave (stand by)where we were sure of consequent transactions not changing the data.There are more complex workarounds, such as changing transaction isolation level to repeatable read, but the application code gets complex and hard to maintain. HTH.
When a query will be killed for one of the above reasons is hard to predict, but usually there are some that appear more often.  It is also configurable, for options read the documentation page further.