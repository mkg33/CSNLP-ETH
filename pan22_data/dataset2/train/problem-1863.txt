Note that in practice one may want to set up multiple such timers (especially if you are going to make use of time scaling and want some objects to be unaffected by scaling).
In this loop, if your game runs at 60 frames per second, every object is also updated 60 times per second. However, if your framerate increases or decreases, the rate at which objects update increases or decreases as well. Typically this is undesirable because the wall-clock time (that is, real time) is still exactly the same, so the user perceives the game objects moving much slower or much faster.
Framerate independent motion is when objects in your game move based on some criteria other than which rendering frame you are on. Typically this alternate criteria is the delta time since the last update.
In the above example, the actual real time between successive updates is computed and used to scale the updates, which results in more correct update rates even if your frame rate changes. Generally this is a more desirable way to write your update loop. Not only does correct for disparity in update rates, it also lets you do interesting tricks like scale the delta_time (or set it to 0) to implement time-slowing effects (or pause the game logic). 
Old games typically did this, which is why if you try to run some of those older games on modern CPUs (even under emulation), they run way too fast to be playable, because your modern CPU can execute many more instructions per second.