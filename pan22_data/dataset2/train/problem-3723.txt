The al_draw_rotated_bitmap function takes an angle to rotate the bitmap by. The documentation sadly isn't specific about what direction it rotates in. It also doesn't say whether the angle is in degrees or radians.
You should be able to find out both of these via experimentation. You shouldn't have to, but there's not much you can do about it. Just draw a sprite, then draw the same sprite next to it with a 45.0 rotation. If that causes the sprite to rotate right by 45 degrees, then you know it's a clockwise rotation and its in degrees. If it goes left by 45, then it's counter-clockwise and in degrees. If it's something else, then you know it's in radians, and you should try again with 0.785.
You appear to want to draw a sprite that is always facing the mouse, correct? Then your first task must be to draw a sprite that is always facing something. Pick an arbitrary point and then do the math to draw the sprite so that it faces it. Then pick another point; the math should still work.
"He who would learn to fly one day must first learn to stand and walk and run and climb and dance; one cannot fly into flying..."
If al_draw_rotated_bitmap takes radians, you can feed that directly to it. If it takes degrees, you'll have to convert it to degrees by multiplying by the radians by 180/Pi.
Once you know how the function works, it's a simple matter to use it. Given the location of the sprite S and the location of the point of interest P, you can compute the vector direction from the sprite to that point (P - S).
Then, you want to compute the angle you need to rotate from whatever your zero facing is to face that point. Let's assume that a zero angle represents facing right (a direction of (1, 0)). This means your sprite, when not rotated, faces right. I make this assumption because it allows me to do this: