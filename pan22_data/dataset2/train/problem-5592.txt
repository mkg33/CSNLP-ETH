From the official CS50 notes from last year's Week 0 lecture, the following three bullets explain what this phrase means:
Programming is the actual act of applying the theory and manipulation of the machine. They often get mixed up because programming is such an integral part of CS but is, in fact, only a part of it.
If your "pitch" has enough time for an example, the canonical CS50 example -- one which my students remember vividly from Day 0 since it involves ripping up a phone book -- is to pose the question asking how to find a name in a phone book. You could approach the problem linearly and go page by page (correct but slow). You could look at two pages at a time to double the efficiency (incorrect without checking a potentially skipped-over page). You could divide and conquer by examining the middle page and throwing away the half you no longer need (logarithmic efficiency). Even something as simple as looking up a name in a phone book allows for discussing linear v. binary search, computational complexity, debugging, sorting (since the book comes pre-sorted). 
I'll attempt a self-answer here, based on hindsight and a few previous experiences where I went in knowing I wanted to do this.
The downside of this answer is that it doesn't get into the mathematical foundation of CS, or how CS is about unchanging fundamental concepts. But I'm beginning to think that's not a big problem... such topics might be beyond the scope of a five-minute intro for a complete layperson.
Technology keeps changing all the time. You get used to the menus in Microsoft Word, and then they change it to the Ribbon. You learn to program buttons in Java using Applets, and then Applets get removed from every major browser as a security risk.
It can be helpful to try to make the analogy with the listener's own profession, as long as it doesn't backfire by derailing the conversation.
As an alternative to the phone book example (since it's more effective with an actual phone book and not in the abstract), say this: "Think of a number between 1 and 1024. I guarantee I will get it in 10 guesses or fewer." A computer scientist will conquer that challenge every time.
I compare the difference between CS and IT to the difference between medical doctors and EMTs.  As an EMT, I was required by law to follow the protocols established by physicians, who get to do the experimenting and the researching and the paper-writing.  As an IT worker, you will be handed a set of tools (databases, operating systems, programming languages) and have to work with what the researchers (the Computer Scientists) come up with.  The world needs IT workers as much as they need EMTs, so it isn't less, just different.
But there are some things that never change, because they're in the realms of mathematics, or they are fundamental organizing principles.  For instance, computer right now work in binary, 1s and 0s.  The properties of binary numbers themselves aren't going to change no matter what new technology comes around tomorrow.  We might create a computer that's not based on binary, but the properties of binary itself are fixed.  This is the realm of computer science.  Computer science is the foundational stuff that doesn't change.
In my story above, I segued from this into the Halting Problem and efficiency. Looking back, I think that was too big of a jump, at least when presented as abstract concepts. I like the phone book example mentioned in Peter's answer. I think I'd modify it this way:
Dealing with (my) parents who are not particularly aware of computers or the difference between a server and a database, I believe I have a fairly simple answer for this question.
It's not perfect, but I teach at a two-year school, so it's enough to get students thinking about which major to choose.
This explanation in some form has had a fairly positive response to me. Or, if you're particularly pressed for time: "Programming is part of computer science, but CS is a lot more focused on the understanding of how the computer works."
I don't know if this will help you, but I often find myself in the position of explaining the difference between CS and IT to students / prospective students / parents, and I use the experience of being a one-time emergency medical technician to help.
I've found that starting off with an analogy helps a lot of the time. Friends and co-workers have reported similar results in my super unscientific poll. The one we use is along the lines of
It's highly mathematical, highly theoretical, and there are a lot of proofs involved, but when you study computer science, you are studying the deeper question in the nature of computation itself, and that's stuff that never gets dated.
I regularly have to explain what computer science is to parents, and I have lately settled into this explanation:
Computer science is the theory and study of how computers work, algorithms (in layman's terms, a process to solve a problem), and how to think like a computer in order to manipulate it to do what you/the client/whoever want.
Computer science is a discipline of problem solving. I use this phrase from CS50 often (mainly because I teach an adaption of it): 
This is what I use on Day 0 when I welcome students to my class and at Back-to-School Night presentations to parents.