If you have an application that may work frequently with different database engines such, let us say an ERP that should accept any known database engines such as MySQl, MS SQl, ORACL, Inerbbase...etc triggers may become a problem in maintaining the code since triggers syntax is different for each database engine
In my experience, triggers are hard for developers to work with - they are effectively a side effect of the intended action (e.g. they intend to update a record in your table, and as a side effect, the trigger writes and audit entry). I've seen several cases where a change to the "normal" SQL caused the trigger to become much slower as a result of an unintended consequence of the side effect. For instance, a developer who was tuning a slow query changed an index which caused the trigger associated with that table to run MUCH more slowly. 
You can try using the SQL Server Change Data Capture feature instead of using triggers. In Change Data Capture, the information is retrieved by periodic querying of the online transaction log. The process is asynchronous. Database performance is not affected; performance overhead is lower than with other solutions (e.g. using triggers)
SQL Server Change Data Capture requires no schema changes of the existing tables, no columns for timestamps are added to the tracked (source) tables, and no triggers are created. It captures the information and stores it in tables called change tables. For reading the change tables, Change Data Capture provides table-valued functions
There's an application that will create triggers for you - ApexSQL Audit. You can test the behavior then, but based on what you said, it's not a high transaction database, so there should be no problems. One more resource you can use to audit data changes is reading transaction logs. 
Most performance problems follow a hockey stick curve - performance declines roughly linearly for a while until you hit a bottleneck, and then performance declines exponentially. The trick with scaling your system is to work out where your inflection point is, and what you need to do to move it further away if necessary (e.g. add more RAM, tune your queries, introduce off-line processes etc.). 
In general, I'd recommend against using triggers for any heavy lifting - it's not a question of whether the performance is "better" or "worse" - it's that performance becomes unpredictable and issus are hard to debug. 
Here's a short (noncommercial) article I wrote that might help keep any triggers from getting out of hand:
I'd probably stick with triggers, for the same reasons gbn described, but if performance becomes an issue, you may want to consider using Service Broker to perform the work asynchronously (if business requirements will allow that). The typical design would be to have a trigger call a stored procedure that sends a Service Broker message, and the Service Broker queue handles the work where latency is occurring.
So, I'd recommend against using triggers unless your audit requirements are literally just copying data from one table to another. 