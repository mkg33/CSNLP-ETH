If your movement should look a lot like your graph, you could make use of a bounce easing equation like this one (source):
What is a good equation that results in such a graph? The transformations I can do myself I guess, but I'm just looking for the kind of equation.
The easiest way to implement it is to give your camera an initial velocity vector (call it u) and you want to find the final velocity vector after the camera has collided (lets call this v). Lets call the CoR e.
However, what is a good equation for bouncing? I mean, for a circle you can do y = sqrt(1 - x^2), but if I were to have a bouncing graph, what would the corresponding formula be? I guess it's something with abs as it has to 'bounce'. Something like (I made this up with Paint):
Use some sort of position update function (Euler, Verlet or even RK4 - see this link) and it will make this task a lot easier.
If you want bouncing then look into the Coefficient of Restitution. It's a value between 0 and 1 that represents the "bounciness" of the camera. A value of 0 means that no bouncing will occur when the object collides with the ground, and 1 means that the camera will bounce back up to it's original height after it has collided with the ground (in this scenario anyway).
I basically want my camera in 3D move automatically. Currently, I have linear movement which is rather dumb, so I'd like to do a bouncing movement.
Using a graphical equation will not help you apply natural looking accelerations to the system. You may be surprised to find how easy it would be to simply use basic Newtonian equations here. Give the object a little mass and momentum and let the force of gravity and Newton handle the accelerations & position changes. It's far easier than you may think
So all you need to do is multiply your initial velocity by the coefficient, negate this velocity (for it to travel in the opposite direction) and voila, you have your final velocity and if you keep doing this for every time it collides, you have your bouncing motion. This is assuming you have a flat plane that you want to bounce against, if you have a complex mesh you're colliding against, then instead of negating the vector, simply multiply it by the normal of the polygon you collide with (which is essentially what negation does on a flat plane).