Also, unbuffer is for buffering (unbuffered, block, or line-buffering) of the standard streams. It is likely (but not necessarily) not relevant here, unless you are passing tarballs over the net and untarring them locally, or redirecting output from a net-connected process to the filesystem. Even so, it shouldn't matter unless these programs are using block buffering with a huge size, or line-buffering for binary data and you're unlucky enough to not have had a single 0x0d or 0x0a in your data for some arbitrarily large amount of data. Also, this caching is a library feature, not a kernel or program feature. The latter may set parameters.
The caching you are referring to is not in userspace; it's the Linux kernel inode and dentry cache. You can control the rate at which the kernel reclaims memory used in this cache by adjusting the vm.vfs_cache_pressure sysctl parameter. This article suggested  a value of 10000. As for Linux cache [coherency] itself, I couldn't give you a definitive answer but it's likely not the issue.
ls and friends do not cache their results. Instead, I suspect the output of du just changes slowly. (Due to the way your transferring software plays with open file handles). You can also try dropping the filesystem cache altogether, although I don't think it makes much sense here: echo 1 | sudo tee /proc/sys/vm/drop_caches
Long story short: in my case, I can use cd . to update the terminal â€¦ or delete its cache or whatever.
But am pretty sure that, you wont get wrong data at any time. Kindly recheck what you are doing. In all the cases, these find and ls gave me very correct data, even while handing tons of files.
For a better way to track the progress, you should use rsync for transfer and give it the -P flag, which makes it print progress in standard output. 
(Context) I am using a Docker / SilverStripe environment and I am frequently running into this exception when trying to call http://example.com/dev/build/?flush=all (which rebuilds the database and clears the cache).
I learned that I can navigate to that directory in the terminal (outside Docker) and delete the file manually. But doing this repeatedly leads me to this same caching issue where ls -hal will show me an empty directory even though the file exists (and cannot be deleted).