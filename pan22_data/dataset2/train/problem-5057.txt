The big point is that you recognize a real need versus just wanting to do it differently because, as a single dev, your time is precious.  And once the need is determined, do it inline with your other work so it's part of your normal workflow.  Continuously evaluate how well your code fits together and serves its purpose and continuously improve code if it meets the criteria above.
On the other hand, for long-lived projects, the bigger driving force is technical debt. Like financial debt, it can slow you down or even kill you off. In this case, as soon as you know there's a problem, and it makes sense, fix it.
For example, I tend to do major architectural refactorings project by project: I commit to small project (order of months), and any major changes (like moving towards an entity/component architecture or a data-driven design) I commit to when I start on the next project.
Generally the earlier you fix the flaws, the less money/time you lose compared to fixing them later. These errors/inefficiency tends to stack up. There's plenty of literature on agile development though and working iteratively. That being said, refactoring should be a part of your work cycle.
At some point also look at your overall architecture; if changing one section of code requires lots of external changes then modules are too tightly bound and that may be what's causing you to need big rewrites...
To summarize, it really depends on the needs of the project and your availability. Personally, I try to integrate small refactorings as I go, and leave major ones for the next project (which is not too far off).
The real thing you want to consider is why you're refactoring. If there's some tangible benefit you get out of it, sure, refactor when you see the need. If not, you can put it aside.
Continuously refactor and rework the code.  Code is more like clay, where you continuously remold it, than some kind of brittle structure that you set up once and use forever.  You can always go back and improve bits you don't like.  That said, you have to be extra careful not to break anything in the process of refactoring.  There may be a point of spagettiness beyond which a body of code may be nearly unsalvageable -- ie when even reasonable refactoring exposes bugs that you never would have guessed would pop up.  If your code base is in that state, then you have 2 options:
If you're working on a single, long lived project then refactor as soon as a good case can be made for the change.  And by "good case" the criteria should be how many new systems will have to work against this code, how often does the code surrounding this change, will this change actually make it easier to use or is it just to be pretty?  Will it save you time?
If you're working on multiple, sequential projects then simply mark it for a refactor and do the work when you start the next project that uses it.