Surely the point of the trie is to store the words in the nodes, so why should they be stored elsewhere? If Trie.words is eliminated and the class Indexes is eliminated then TrieNode.substr can just store a direct substring of one of the strings. (Before anyone complains that this would increase memory usage: Java's String.substring shares the char[] with the original string, which it can do safely because strings are immutable in Java. The only memory increase would be a boolean per node to record whether the node ends a word, and that's balanced by the memory saving of 64-plus bytes per word from not having the list).
Looks like either a refactor or a copy-paste which didn't tidy up the JavaDoc. I would expect the IDE to give a warning.
I mentioned the singly linked list implemented with TrieNode.sibling. I would prefer to use a suitable Collection<TrieNode> children for two reasons: firstly, because there doesn't seem to be a good reason for reimplementing something which the standard library already supports; and secondly, because with the right collection (I'm thinking TreeSet<>) you could use binary chop rather than linear search.
That recurses down the tree to find a node, and then returns enough information to recurse down the tree again looking for the same node. That's a clear sign that refactoring is necessary.
Also, maybe because the posted code doesn't include the class header for the main class, I don't see a full explanation of the data structure. I see mention of it being a "compressed trie", and it's possible to deduce from the fact that a TrieNode contains a substring which isn't necessarily a prefix or a suffix roughly what is meant by this, but e.g. what guarantees do we get about common prefixes between siblings? And is there any constraint on the order of the singly linked list implemented with TrieNode.sibling? That information is essential for the maintenance programmer who has to deal with this code in two years' time, and they shouldn't have to try to reverse engineer the code to work it out.
Why? If there is no word, returning a list containing no words would be more consistent and would simplify things for the caller.
My first thought when I started looking at the code was that the first few lines seemed unnecessary: