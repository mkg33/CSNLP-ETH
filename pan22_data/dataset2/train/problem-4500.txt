It might also be good to make test functions like this act in the positive sense, as in in_comment(), instead of not_in_comment(), just because ! not_in_comment() may be a bit confusing if it's ever needed.
If you want to be pedantic about the C you parse, a newline can actually be escaped with a backslash, continuing the line. Even continuing a // comment, or escaping a newline in the middle of a /*. Not that I'd recommend writing code like that, but you might want to be aware of it.
Since the interesting cases need looking ahead to the next character, you might consider pulling the next character in unconditionally at the start of the loop, so you don't need to duplicate the ungetc calls in different branches of the function.
This could be just if (NOT_COMMENT && !d_QUOTED && !flag). Split over two lines if you like. Added confusion since the next almost identical case has the !s_QUOTED and !flag tests in the opposite order.
While I don't think variable names need to be especially long, flag is much too generic to be of any use (at least without a comment). escape perhaps? (Should the backslash also be checked only inside quotes? I'm not sure.)
Don't exit() from inside a function, just return an error code and leave the decision on how to deal with the error to the main program. (Though here, you'd need to close the first file too if the second open fails.) In the same vein, I'd leave the timekeeping to the main program, too.
Helper functions like this are ok, but they need to look like functions to not confuse the reader, and also because you might want to implement them as inline functions. So, make a variable state, and a function like in_comment(state). Make state a bitfield or a struct if you need.
I find this logically odd. There's no way to nest quotes, so instead of a incrementing it as a counter, I'd just flip the value when encountering a quote, somewhat like you did with flag. So, d_QUOTED = !d_QUOTED.
Though again, you can only be inside a comment or a quoted string, not both, so one variable for those should be enough.
Frankly, I think this looks horrible. A macro that acts like a function should look like a function, not a constant. One of the reasons you're doing this, is that your variable names are too long, so you resort to tricks to keep the line length under control. There's a bit of a relationship between the length of a variable name, and the scope within which it is used: variables used inside a function or a single loop can have shorter names than globals, since the reader doesn't need to remember them for very long. 
Though in this case is good to note that you don't need two separate variables for the two kinds of comments, since only one type can be active at a time. This shows later in your code, as setting DOUBLESLASH_Comment is protected with an if (NOT_COMMENT), etc.