You can optimize for searching by using a Map<String, Integer> for counting frequency, and then use a NavigableMap<Integer, Set<String>> for maintaining order (1). Adding an entry will look like this:
When searching for an element in the queue, you can abort once it's found. On average, this will halve your time spent searching:
As you noticed, searching for your entries is adding to your time complexity, because you have to run down your queue. Priority queues are very good at polling the top element, but not optimized for searching for specific entries.
And a nitpick from an 'elegance' point of view: consider adding a method to MyWord that creates a new, incremented instance. Right now, outside code is accessing the fields and creating new instances with it. This is something MyWord can handle internally.
(1) If you're confident about your data being densely distributed and bounded, you can replace this with an array for quicker access—approaching O(1) i.o. O(log N)—but it's going to make your code messier dealing with edge cases.