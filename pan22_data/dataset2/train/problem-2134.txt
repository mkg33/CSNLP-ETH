First, avoid premature optimization. As Matthias notes in the comments, keep your implementation simple until you actually experience a performance problem that you can attribute (via profiling) to the configuration variable system.
Alternatively, you can store the variable data in a trie which is a tree-like structure with (in this case) up to 26 children per node; paths through the tree spell out the variable keys and the leaf nodes store the actual variable data.
One of the big potential performance issues in an implementation like the one you have described will be the string comparisons, so you will potentially see a gain by removing them. A common way to remove string comparisons is to hash the strings to integers, which are generally faster to compare. 
Setting the CVar might lag a little, sure, but that's okay - you're already parsing the text input from a command. To optimize it if you must, hashing the name to an int for a quick lookup map is all you need. You could also make a directory structure, EG sv points to the sub-map containing sv_cheats to further minimize lookup comparison count.
Many famous game such as Quake or Half-Life use CVars to allow easy and flexible game parameter manipulations.
If all your variable keys are known up-front, you can do this hashing at compile time or load time (whenever the earliest you know the full set of keys is). Then you only need to hash the user input, and all subsequent comparisons to look up in the map are done via integers. In fact, if you do know everything up front you can potentially "hash" every variable to an ordered list of integers and simply use an array for lookup. If you don't know everything up-front, you can still leverage hashing, but the lack of foreknowledge means you lose out on the opportunity to achieve a perfect mapping.
It's getting the value of the CVar that you have to keep tightly optimized - and that's easy, just keep a pointer to the CVar, rather than looking it up by name every time. (This is how Quake and other major CVar users handle it internally).
CVars are used intensively during the game - if they were set or retrieved by string name lookup there would certainly be a performance hit. Therefore, I'm assuming CVars are somehow cached.
In both cases you will want to build yourself an API that wraps storage of and access to those variables -- do not store a std::map directly in your Game object, as you did in your example code, because that will make it more difficult for you to tweak or replace the underlying storage and retrieval mechanism if/when you discover there are performance issues.
How would this kind of system be implemented? I thought about storing pointers to the real values in a map having the CVar names, and then use the real values in the game. 