Branching (if) is faster in terms of compilation, perhaps, but for the month of december, you'll end up performing all if statements.
Neither will be simpler than using the date function's F code, and I'd bet $5* this would be faster than both.
* Coincidentally, $5 is the maximum amount of money you should spend trying to optimize this code. ;)
If your determining the name of the month then it's pretty obvious the data-set is limited to 12 valid strings. But in most cases, you might end up with an ever growing switch or if-elseif-else tree. That's not efficient coding. The moment you have to scroll to see a single block of code, you can safely say it's time to think about refactoring your code.
Like I said in my comment: If you want to know which is faster, write a benchmarking script, it's that easy:
That's why I'd either use the array approach (works just as well when data is coming from a query, so you can create a function that you can reuse). Or, if you are working on dates, I'd give way to normalization, and use the DateTime class. when I see new DateTime or $d = DateTime::createFromFormat, I know what to exepct. Even more so when I see:
Mind you, This is micro-optimization of the worst kind. It's completely pointless and the speed difference won't be noticeable. Especially if you use some form of OP-Code caching (APC, for example). That should be the first port of call if you're trying to optimize some code.
My gut tells me that in this case, the switch will probably be the faster option. Considering a switch construction is sort of like labeling blocks of code, and then do some sort of eval-go-to thingy.
This is the better question to ask. The efficiency of some snippet of code isn't just determined by the time it takes to execute. Efficient code is good code (is stable, performant, error and notice-free) and is easy to read, update and maintain.
The array approach, for this example, doesn't look like the fastest approach you can take in this case, because it's constructing an array, performing a HashTable lookup, evaluate the result of that lookup, then perform the same lookup again, or return an empty string. HashTable lookups are as fast as it gets, of course, but still, you're having to do 2 of them, just after you've constructed the HashTable. The other approaches don't construct to then perform a lookup.