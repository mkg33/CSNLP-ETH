Not knowing the language, and course objectives, I can't layout a definitive plan for the scaffolding. I'm sure that if you work backwards from the larger projects, you can design smaller projects that cover the earlier material that can end up in the finished version of the large one(s). If the students have enough time, and new material, between writing, and then reusing a program, they will see the benefits of best practices. Either from the hard work of rediscovering what the old ones do, or being able to easily see what they do from reading them if they did use best practices earlier. Of course, if they get to see other students' work, or have to figure out what other code does without best practices, that helps. Having to reuse their own code (when they think I'll always know what this does) will drive the point home in a firm, and memorable way.
Here is an amusing exercise.  Have your students build an API for extended precision rational arithmetic, BigFraction.java.  Ask them to javadoc it and to have all of the basic goodies (toString, equals, add, subtract, multiply, divide, pow, etc).  
Another alternative is to show two short code snippets in class, one with descriptive names and one with non-descriptive names and ask the class to determine the output of each, one after the other. Time how long it takes for at least half the class to find an answer and then (in most cases) they will see it takes much longer when you have to decipher non-standard code. I remember learning pointers in C in this way.
Now take these APIs and assign as second project:  Solve some problems with BigFraction (compute harmonic numbers, bernoulli numbers, etc) using another student's .class file (no they can't see the code) and their javadoc.   This often has entertaining results and it cements the idea that documenting programs enhances their usefulness.
Best practices are sometimes best taught in conjunction with or after one teaches a problem or solution area where lack of best practices can cause bad things to happen.  Show them, or better yet let them experience, the bad things that can happen first, after violating a certain practice.  Make them value the practice.  Otherwise you might be creating blind followers of unsupported dogma or the latest methodology fads.
Every time you produce "throw-away" code in demonstrations, problems, or handouts, make sure that you have followed whatever "best practices" you are trying to get them to follow. Then, don't make them create "throw-away" code. It might be the next lesson, it might not be for two weeks farther into the term, but as much as possible have the code created in one lesson be applied or modified in a later lesson. Emphasize your set of best practices early on, and help them understand them with code reviews on the earliest assignments that focus on those practices. For later assignments, place less emphasis on the review of best practices, and more on the code itself.
One of the first principle to realize is that the students are not only learning from what you teach, they are also learning from what you do. They won't buy into a practice that you aren't following yourself. Would you purchase a Lincoln Towncar from a salesman that drives a Honda CRV to work every day? Your students are watching you, and they are evaluating you. Use that to enhance the lessons, not diminish them.
The easier you make it for students to know where they have gone wrong, the more likely it is that they'll improve their code. I suggest automating this in some way to make it part of their submission.
I have heard of teachers developing a bit of code as a class to the point where something is working properly for everyone, then deliberately breaking something and running a light obfuscation tool on it. Then the students are tasked with reading through code without comments and with meaningless variable names, trying to fix it.
For this to work, students need to know that they have written bad code or are not following industry standard guidelines. You should introduce them to lint tools so they can make it part of their workflow earlier in the learning process.
In engineering labs, we often broke things (with a loud bang) in conjunction with the learning theory on how to design things that didn't fall down.