Multithreading can be discussed in CS1 if the students build GUIs, since the GUI needs its own thread to maintain responsiveness while the main thread is handling time-consuming GUI events.  But most GUI libraries do this multithreading for you, so the students don't have to do it themselves -- you can talk about what's going on under the surface, but the students don't gain any hands-on experience and it's unclear to me how much they take away if they don't have to do it themselves. But there are schools that take this approach.
We don't specifically cover how to write programs using these. A student could also get a good grade and know little about there.
Given the type of software development that occurs these days, such as on mobile phones and with "big data" technologies, I think concurrency, threading, etc. should be introduced very early.  Basically as soon as you start talking about what a program is, how it's invoked or executed, and what happens when it completes, I would discuss all that in the context of a concurrent environment.  You don't necessarily need to get into all of the details initially but I would try to avoid teaching new students that all programs are sequential and uninterruptible. 
Of course, it's not true multi-threading, as all of Scratch runs inside Flash, inside the browser, on just the one core, but I doubt those using Scratch will be aware of, or care about, the distinction.
If we don't introduce parallel/concurrent thinking early, our students can develop a sequential mindset that makes it hard for them to make the shift later. The rest of this is in the context of a college/university CS curriculum...
Our fourth course is Programming Languages, where we spend 1-2 weeks on languages that provide features for parallel / concurrent execution.  For example, we contrast languages that expect threads to communicate via shared memory (and the different mechanisms to synchronize those accesses: semaphores, locks, condition variables, monitors) with languages that have threads communicate via message passing (e.g., Erlang, Scala).
We introduce students to multithreading in CS2 (Data Structures), using Just-In-Time pedagogy.  The basic idea is to give the students a problem that requires them to store a lot of data in a data structure (e.g., an organism's genome in a C++ vector or a Java ArrayList, or a really big image to be processed) -- enough data that processing the data sequentially takes 5-15 seconds.  This is an eternity for todays students and they get impatient waiting so long for their program to solve the problem.  We leverage that impatience and use it as motivation for introducing multithreading and parallel execution as a means of speeding up the program. We think the CS2 (Data Structures) course is the first time there is a natural motivation for introducing multithreading, since that's the first time you can store enough data to really motivate it.
Children might encounter this in a maze game, perhaps programming a number of similar ghosts to chase the player's avatar. It's also useful for agent-based modelling, e.g. the spread of an epidemic through a population. 
I do not see much value in teaching more than an appreciation of threads and locking, until you have covered less primitive techniques for parallelism.
This does, though, lead to potential difficulties in 'graduating' from Scratch to a text-based language such as Python - young Scratchers who've been used to programming in parallel in Scratch can find it hard to adjust to doing just one thing at a time in introductory Python programming.
These techniques allow parallelism that scales beyond what threads and lock does, is easier to learn, and less prone to bugs.
The upshot is that parallel and concurrency topics are "sprinkled" throughout our curriculum, rather than being confined to a single course.  (We also offer a junior-senior elective course that focuses solely on parallel computing, so that students who want more can dig deeper into the subject.) That's one way to do it.
We're introducing some aspects of parallel processing quite early on in Scratch. Each sprite has its own script which appears to execute in parallel with those of the others. Scratch has a broadcast and receive message protocol, and support for shared as well as private variables and lists. 
Our CS3 course is an Algorithms course, so we continue the exposure there by introducing parallel versions of searching and sorting algorithms, graph algorithms, etc. 
Our sixth course is OS & Networking, where spend several weeks exploring the implementation of the features needed to do all of this: threads, processes, semaphores, locks, condition variables, message-passing systems, etc.