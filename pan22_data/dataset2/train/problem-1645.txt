We append a comma, and we repeat the process for the next word, which is World. This has the index 119. Again, substract 1, which gives us the following compressed word: Œ‰. This gives us the following code for my language:
The temporary variables are temp_string, temp_string_2, temp_index and temp_position. I know I should not be using names like these, but I didn't know what else to name it. This code just doesn't feel clean, and I don't know if it's just me, but it's not pleasant to look at. The code above can be found here. The dictionary.unicode_index is found here.
Don't use a bare except - you'll catch things you don't want to (for example, Ctrl+C).  Also, narrow the try as much as you can - if it is this big, it will be very hard to tell what caused the error. You should strongly prefer catching specific errors over all errors - errors you aren't expecting are probably bugs, and you'll want to learn about them.
You probably also want to factor out the first if branch into its own function, but given that it seems a little similar to the outer branch and the loop.  My guess is that the entire function this is in could be redesigned to be simpler and more modular, however without seeing that I can't speak exactly to it.
I was wondering how I can make the code look more clean, because right now, it looks like a complete mess.
Don't use string concatenation the way you are - that's gonna be wasteful. Instead, use string.join.
You need better constants - "\u201d" is too magic - I would have no idea that it is a right double quotation mark just looking at that.
I have made my own compression tool for a stack-based language that uses a dictionary compression method. The code for the decompression is the following:
For example, we want to compress the sentence Hello, World!. We first look at the index of the word Hello, which has index 2420. Since the language is 0-indexed, we need to substract 1 from this, leaving 2419. We now slice this into two pieces, 24 and 19. Then we find the corresponding indices, found here.