If that doesn't fix it, you may be hitting a weird edge case in the code with threading that I wouldn't have though possible on a single-cpu system. You might need to implement your own software check for debounce or to try adding a small capacitor (0.1 uF) across the switch. A further increase of bouncetime might help, but if it doesn't I'd suspect bug.
I can't explain why this would work, but it does. I suspect that eventhough an event is detected, the system needs a little bit more time before it knows which one it is, rising or falling, or that it's two systems and one is slower to catch on that the other? I don't know...
The resistors can be added in one of two ways. A physical resistor can be put in place, or the Pi has internal resistors that can be used. The GPIO library has support for this. For example:
The first thing to check in mysterious situations like this is do you have the latest version of the GPIO library? The newest one should be 0.5.4.
I think you should change GPIO.BOTH to either GPIO.RISING or GPIO.FALLING. I suspect that any jitter otherwise could be detected as two different interrupt event, one falling and one rising.
The second problem may be that you're not setting a pull-up or a pull-down. In an electrical circuit with only a switch, when the switch is closed, you know what it is. However, when the switch is open there's no physical electrical connection and so technically the Pi could read anything on the GPIO pin. (What it actually reads is some weird combination of electro-magnetic radiation from your refrigerator and static electricity from you sweater, that sort of thing.) To prevent the "unknown" state, a pull-up or pull-down resistor is used. This way, when the switch is open, the resistor comes into play and the circuit is still defined.
What seemed to have fixed it for me (it's a weird fix, I'll say so myself...) in addition to the above, having a pull_up_down=GPIO.PUD_UP in your GPIO.setup was adding a small delay after the event is detected, and before you check which one, like so:
If the switch is connected to ground and the GPIO pin, you want a pull-up resistor. By default it "pulls the circuit up" by connecting the pin to +3.3 V, so that the pin reads 1 unless the switch is closed. The swtich has no resistance, so it short-circuits (in a good way!) the resistor and the pin now reads 0. The switch opens back up, the resistor comes back into play, and all is well reading 1 again. A pull-down resistor works the same, but exactly the opposite. It connects the pin to ground, so that the pin always reads 0. The switch then connects the pin to +3.3 V. When the switch is closed, the voltage short-circuits the ground connection and the pin reads 1. Etc.