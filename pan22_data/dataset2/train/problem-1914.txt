Whenever you add an element to the territory, you iterate over adjacent tiles and see if they should be a border tile; in this case, they are a border tile if they are not an element tile.
But if you're only concerned with finding the outer border (not interior holes), then we can do this a bit more efficiently:
This takes O(1) work whenever you add or remove a tile to or from a territory.  Visiting the border takes O(border length).  So long as you want to know "what the border is" significantly more often than you add/remove elements from the territory, this should win.
If you need to find edges of holes in the middle of your territory too, then your linear in the area of the territory bound is the best we can do. Any tile on the interior could potentially be a hole that we need to count, so we need to look at every tile in the area bounded by the territory's outline at least once to be sure we've found all the holes.
I just wrote a blog post about how to do this. This uses the first method that @DMGregory mentioned starting with an edge cell and marching around the perimeter. It's in C# instead of Python but should be pretty easy to adapt.
Whenever you subtract an element from the territory, you ensure that its adjacent tiles are still in the territory, and you see if yourself should become a border tile.  If you need this to be fast, have the border tiles keep track of their "adjacent count".
If your examples are representative of your real data size to within a couple orders of magnitude, then myself I'd go for the naive area search - it will still be blazingly fast on such a small number of tiles, and is substantially simpler to write, understand, and maintain (typically leading to fewer bugs!)