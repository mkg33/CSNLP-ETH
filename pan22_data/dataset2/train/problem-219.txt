PHP's sleep() is a simple wrapper under the OS's scheduler API. When its called, php stops running - so the PHP can't check if the clock has run out until the sleep time expires and the scheduler adds it back onto the run queue, and the CPU gets round to processing the next instruction.
While this example is rather artificial (why would you ever write a script like that knowing you'd got a timeout running) there are many scenarios where the thread of execution passes outside of the PHP interpreter, and it therefore does not get a chance to check its stopwatch - e.g. when the script starts other processes, or the thread is in an extension - such as waiting for a db query to return. The problem can be avoided by asking the system to send a signal back to the PHP code at a defined interval (pcntl_alarm) after you define a signal handler (pcntl_signal).
Other methods such as loading php via fcgid or fastcgi would give you greater control over process management / execution time / timeouts / idle time / etc. 