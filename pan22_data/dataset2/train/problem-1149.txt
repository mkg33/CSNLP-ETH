My AP Computer Science Principles course teaches three languages: Scratch, C, and Python. One of the 7 Big Ideas for the course is abstraction. At the end of the course, I emphasize how Scratch exists at the highest level of abstraction relative to the other two as a block-based language and how the Python interpreter we use is written in C. Connecting this to lower levels of a computer, we form a chain that looks like this (from high to low):
Learning how charges of electricity on transistors can be constructed to form logic gates, which in turn form the building blocks for computer architecture -- that is magical. 
Obviously for the purposes of the class, it is a bit of a simplification as we don't cover instruction sets or adders and ALUs or assembly language specifically. However, as an introduction, students can begin to form a conception as to how a computer operates at each level. This lays the foundation for further study as students look ahead to pursuing computer science in college.
Despite any potential future benefit, I take this more philosophical approach to this topic: there is an intrinsic benefit and reward to looking "under the hood" at how things actually work; in that sense learning lower levels of computer architecture is an end in and of itself.
It is very hard to describe why tail recursion is important, or the operational output of (mystring == mystring2) in Java, or even what the code below accomplishes without discussing some lower level operation of the computer:
Regarding architecture specifically, I don't see a tremendous benefit in high-school level programming classes.  However, at just one level or so of higher abstraction, discussing the principles of memory management as it applies to programs they write (such as stack and heap operation, how function calls are handled, etc) can make a big difference.