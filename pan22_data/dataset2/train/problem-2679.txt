An example might make this clearer. Suppose a game modelling cities, and that version 1.0 tracks the cities' overall level of development, while version 1.1 adds Civilization-like specific buildings. (Personally, I prefer tracking overall development, as being less unrealistic; but I digress.) GuessNewValues() for 1.1, given a 1.0 savefile, would begin with an old level-of-development figure, and guess, based on that, what buildings would have been built in the city -- perhaps looking at the city's culture, its geographic position, the focus of its development, that kind of thing.
This is a problem that exists not only on games, but also on any file exchange application. Certainly, there are no perfect solutions, and trying to make a file format that will keep with any type of change is likely to be impossible, so it's probably a good idea to prepare for the type of changes you may be expecting.
If your save files are massive xml could be a problem, typically i've save files work really well where you just dump key value pairs in to the file like this ...
Most of the times, you'll probably be just adding/removing fields and values, while keeping the general structure of your files untouched. In that case, you can simply write your code to ignore unknown fields, and use sensible defaults when a value can't be understood/parsed. Implementing this is quite straightforward, and I do it a lot.
The other way of course is to use a database type format or something like a csv file, but it does depen on the data you are saving.
You can do this for the whole file, for individual sections of the file, for individual game objects/components, etc.  Exactly what split is best is going to depend on your game and the amount of state you're serializing.
At a higher level: if you're adding new features to the game, have a "Guess New Values" function which can take the old features and guess what new ones' values will be.
I would suggest going with something like XML (if you save files are very small) that way you only need 1 function to handle the markup no matter what you put in it.
For the low-level side of things, I'd endorse Sean Middleditch's answer (which I've up-voted): keep the existing load logic, possibly even keeping around old versions of the relevant classes, and call first that, then a converter.
The root node of that document could declare the version that saved the game and allow you to write code to update the file to the latest version if need be.
I hope that this can be comprehensible in general -- that if you're adding new features to a game, loading a savefile that doesn't yet have those features requires making best guesses as to what the new data will be, and combining those with the data you loaded.
One easy-ish approach is to keep old loading functions around.  You need only a single save function that writes out only the latest version.  The load function detects the correct versioned load function to invoke (usually by writing out a version number somewhere in the beginning of your save file format).  Something like:
Note that this only gets you so far.  At some point you might change your game enough that the save data from earlier versions simply makes no sense.  For instance an RPG might have different character classes the player can choose.  If you remove a character class there's not a whole lot you can do with saves of characters that have that class.  Maybe you could convert it to a similar class that still exists... maybe.  Same goes if you change other parts of the game enough that it doesn't closely resemble the old versions.
These two methods should work for most cases, but keep in mind that they are not the only possible changes you might encounter. I had a case in which I had to change the entire level loading code from whole-reading to streaming (for the mobile version of the game, which should work on devices with significantly reduced bandwidth and memory). A change like this is much deeper and will most likely require changes in many other parts of the game, some of which required changes in the structure of the file itself.
Be aware that once you ship your game it's "done."  You might release DLC or other updates over time but they're not going to be particularly big changes to the game itself.  Take most MMOs for instance: WoW has been maintained for many years with new updates and changes but it still is more or less the same game it was when it first came out.
Then when you read from this file you always write and read a variable in the same way, if you need a new variable you create a new function to write it and read it. 
For early development I simply wouldn't worry about it.  Saves are ephemeral in early testing.  It's another story once you get to public beta, though.
you could just write a function for variable types so you would have a "string reader" and a "int reader", this would only fial if you changed a variables type between versions but you should never do that because the variable means something else at this point so you should create a new variable instead with a different name.
This also means you can apply a transform if you want to convert the data in to a "current version format" before loading the data so instead of having lots of versioned functions lying around you would simply have a set of xsl files that you choose from to do the conversion.
However, sometimes you will want to change the structure of the file. Say from text-based to binary; or from fixed fields to size-value. In such case, you will most likely want to freeze the source of the old file reader, and create a new one for the new file type, like in Sean's solution. Make sure you isolate the entire legacy reader, or you may end up modifying something that affects it. I recommend this only for major file structure changes.