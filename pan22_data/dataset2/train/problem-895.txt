This is standard of mine specifically for regexps in the context of rm, but it would have saved you in this case.
Then, press Alt-Shift-8 (i.e. Alt-Shift-*) to expand the "*" wildcard explicitly in bash.  This also avoid re-entering a "rm -rf *" command when navigating the history.
Sadly, I cannot leave a comment above due to insufficient karma, but wanted to warn others that safe-rm is not a panacea for accidental mass-deletion nightmares.
I always do echo foo*/[0-9]*{bar,baz}* first, to see what the regexp is going to match.  Once I have the output, I then go back with command-line editing and change echo to rm -rf.  I never, ever use rm -rf on an untested regexp.
I usually use the -v flag to see what is being deleted and have a chance to ^C quickly if I have the slightest doubt. Not really a way to prevent bad rm's, but this can be useful to limit the damage in case something goes wrong.
The following was tested in a Linux Mint 17.1 virtual machine (warning to those unfamiliar with these commands: DON'T DO THIS! Actually, even those familiar with these commands should/would probably never do this to avoid catastrophic data loss):
First, type rm -rf * or rm -rf your/path/*, DON'T type Enter key.  (of course, you should have a habit of caring not to press Enter fast/accidentally when using rm -rf)