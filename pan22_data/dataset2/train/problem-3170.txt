that should help with the speed. Especially this function which is in the "inner loop" should have a significant benefit from being inlined.
As you have discovered, making more function calls has the potential to make the program slower if the compiler is not doing significant optimizations. Modern optimizing compilers can automatically inline functions when the optimizations are turned on, but you can also suggest to the compiler that it can inline the functions. 
Finally, what does loop mean? Maybe nested or levels or depth would be better. Or even num_open or open_brackets.
I'd suggest either explicitly stating that in your function name (open_or_die), or simply echoing the "successful" behavior by calling it something like fopen_rb or open_file_rb.
You also mentioned in the comments on your request a performance hit after converting to functions. If you look at your original version, you handled '[' and ']' separately. Why not do that in your functions? And while you're at it, just return the result.
I don't care if your tabs are 2 spaces, 11 spaces or what, as long as they stay the same. I don't care if your braces are up or down, or even (God forbid) down and indented. The good advice and consistency will overwhelm your failure to use a multiple of a perfect prime number as your tab size.
Btw, your find_matching_bracket function looks better than the one I wrote for my interpreter. It's shorter and simpler.
This is the gold standard for functions, and so you won't see it very often. But when you do see it, grab on! In your case, you've got a couple of them right here:
Having a formal document to refer to makes it really easy to be dogmatic. Go ahead, it's the internet!
Also, consider that your read_code function represents an operation so common that Perl gives it a name:
The second kind are "we want to have a guide, but we don't want to risk a flamewar, so we're afraid to make any firm guidelines". Ignore these, too. 
The one weak spot I think I see with your code organization is writing your code with a common level of abstraction inside functions. I've already mentioned main. This also shows up in run in two ways. First, because the interpreter code is finer grained than the make_tape and read_code functions, and second because read_code should just go ahead and incorporate the file open and close operations. Change this:
That's another function that would be worth "isolating" so you could keep it in your toolbox. (By "isolating" I mean separating it from your code, so that the name is more general, the types used are all standard types, etc.)
I have some issues with your coding style. You didn't specify what style you were trying to write, and I suspect you started with "IOCCC" as your base, although I don't know why. So:
The third kind will provide some good advice, and some amount of nutrient-laden fertilizer. That's the kind you want! Find one of those you like and stick with it. 
This is a bit of an art form, but what does get_file_handle return? Surprisingly, it returns a FILE pointer. This is surprising because handle is one of those magic words in computing that "everybody knows" what it means. And it doesn't mean that. According to Jargon a handle is:
You spend some characters casting the value of TAPE_SIZE. Why not either include the typecast in the macro (#define TAPE_SIZE ((size_t)300000)) or declare a static variable for the value which you could configure from the command line (-t SIZE):
You edited your code after posting it. Someone is going to yell at you for that - it's considered poor form. Since nobody had replied when you edited, it's not the end of the world, though.
You didn't specify enough about your environment. What version of C are you writing for? (I'm guessing "not K&R" since you're using ANSI-style function declarations. But is that C89, C99, C11, or C18?) Is your code limited to *nix or Windows, or must it run on both? Do you care about compiler versions? Are you allowed to use compiler extensions?
Also, what does "get" mean? (Seriously.) There are quite a few meanings for get in computing. Java(Beans) screwed it up for most people by slathering it in front of their accessors. But it used to mean "fetch or create." Now days, you're better off avoiding it, especially considering what your function does: return a valid file handle or die.
First let me say "Good work!" on revising the code to use functions. This is important in C (and most other languages, too) because it makes smaller units of code which are easier to read and reason about. 
You do this with your read_code and create_tape functions, and this is generally the right way to go if you have to choose between #1 (above) and #2 (this option).
Once you find your ideal coding standard, tattoo it on your body somewhere. I have found that whatever style people adopt first they will be able to rationalize retaining for the rest of their lives. And you can be really dogmatic about it - it's fine! I still write (C) code using the coding standard from my first "corporate" job by default. (Of course, it was a pretty well-thought-out standard, even if pre-ANSI...)
Another option is to turn up the compiler optimization level. With gcc or clang, you can add -O2 or -O3 and it should do the inlining for you.
I'm not aware of any coding style guide that argues for the elimination of whitespace. If you are following one, please post a link to it so that we can burn it out for the heresy that it is! This code shows a lack of horizontal and vertical spacing:
This code computes the size of a file given a file pointer. That's something you might wish to reuse later, and it has nothing to do with your main code - there are no special types or anything getting in the way. This would be something you could put in your toolbox. (You'll probably find half a dozen different ways to do this task. Collect 'em all!)