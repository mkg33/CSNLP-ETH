and then you can get the axis rotation values  from the quaternion you can extract it with this function
If so, the only thing you have to do is make sure each sprite points to the camera. If both your camera and the sprites use the same coordinate system, the Y rotation for your object can either be the inverse of the Y rotation for your camera (for planar billboarding), or the angle between the camera and the object, whose cosine is the dot product between the normalized vector between the camera and the object, and the normalized vector of the camera's forward vector (for cylindrical billboarding)
The only gotcha with this approach is that there are two possibilities that you have to be able to identify and handle due to the fact that cosine is defined between 0 and 180(0 and Pi). In order to handle this you have to take the crossproduct of the two vectors and check the results Y component to determine if you should use a negative 'a' or a positive 'a' in your yaw.
If you normalize the vector that represent Right(Rn) and you normalize the vector resulting from the subtraction of the objects position from the camera position(Cn) then you can use the dot product to determine the angle that you want to apply to your Yaw. 
You probably want to use the latter. The Rotate axis should be Vector3.Up for yaw. The resulting matrix can be applied directly to your object's transformation.
XNA makes this surprisingly easy with Matrix.CreateBillboard and Matrix.CreateConstrainedBillboard. The first method returns a matrix with the orientation determined by the input vector you choose, which is where you use the camera's lookAt vector. Simple enough. The second method returns a matrix with a constrained orientation- that is, it's limited to one of three axes (it can be an arbitrary axis, not limited to the orthogonal directions). 