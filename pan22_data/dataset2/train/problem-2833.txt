This is by no means the "best" code.  Many improvements can still be made in naming (can we have something better than click?), spelling of variables, and so on.  Perhaps a class may be in order.  
will catch any and every exception, and ignore them all, regardless of the correct type.  Why is it bad?  Imagine you correct the spelling error in your main program, and change my_compdictonary to my_compdictionary, but you don't correct it in this section of code.  You test the program, and it doesn't crash, but every definition you look up returns "Sorry definition not found".  Where is the bug?  How hard is it to debug?
Now, word is "noun" and defintions is "A person, place, or thing.  Can be classified into two groups : common or proper."
Here is a simple refactoring of your original code with some of the suggestions from comments above.  No global variables.  The click() function is moved into main(), so it has access to the local variables textentry, my_compdictonary and output.  The image was deleted, so I could quickly run the program.  The dictionary is generated using list comprehension, and will ignore blank lines.
You might want to allow the user to look up a definition by just pressing "Enter" after typing in the word.  The way it works right now, the user has to move their hands from the keyboard to the mouse.
The Robustness Principle warns us about the input we get from the outside.  Be fault tolerant.  Or perhaps better, make it so faults can't happen.
What about blank lines?  They will still crash the program.  You might want to test for those as well.  What about non-blank lines that don't have a definition?  Those, well maybe it would be ok if those result in an exception; that would be really bad input in the "glossary.txt".
the program would crash with a NameError, with the traceback showing you the exact line in question.  Now how hard is it to debug?
How about 'glossary.txt'?  Do we have to guess what the file format is?  Perhaps you could have given a sample file with 3 or 4 entries.
In this particular case, the try...except structure is really overkill.  You can provide a default argument when getting a key from the dictionary to handle the key not found case.  That reduces the above four lines to only one:
Avoid using global as much as possible.  It is a sign of poorly organized code, and makes it harder to reason about the correctness of the code, and harder to test the code because side-effects increase in scope.
split(" : ") now returns 3 items, and you've only got variables for two.  So you'll get ValueError: too many values to unpack (expected 2).  How can you avoid this?  How about telling split() that you only expect to find one delimiter:
Why are you opening the file for reading plus?  Will you ever be writing to it?  Can the program now accidentally write to the file because it has write privileges, corrupting the file?  You are only reading the file; just open it for reading.
Avoid writing code in the main scope.  Move the code into a main function, and call it ... but only if the script is not imported into another file:
What if the user enters with CAPS LOCK on?  What if the definition is provided with a capital letter?  Is the definition really not found?  Could you be a little more liberal in what you accept?
Make it easier for reviewers to run your code.  You have an image 'me.gif' in your code that we don't have.  Running without it crashes the program due to file not found.  How big was that image?  32x32?  300x300?  It would affect the size of the resulting window.  Do we just delete the lines of code so we can test the program?
In this case, it is simple to avoid the global definition because definition is never used anywhere except in the click() function.  It should not be a global variable; it is local!