Similarly, the point of having a PK is to have an unchanging reference to that record-/ the record's identity. Changing the ID on the record should only occur under unusual circumstances. Like a database migration. The PK is best used when it is immutable. 
Id values should persist for the lifetime of the record. Maybe you're confusing an ID with something more flexible, like an Employee Number. Employee Number values may change (although rarely), but ID values are house-keeping data that you shouldn't ever change.
If at some point in time you will need to update the ID field of Employee, it means it should not be aprimary key but an attribute of the Employee entity. It is much better to have an "abstract" key and reference that on the "History" table
The big advantage of SQL compared to document based DBs link MongoDB is, that you can easily do queries like:
Constraints are part of the table's metadata, and serve to make sure the value in the foreign key column does not get out of sync with the key column it references. Either it block changes, or duplicates changes if you declare the foreign key constraint with cascading effects.
Even if SQL were to support a "pointer" like you describe, the pointer itself would take some memory. Ironically, the pointer might even be larger than the integer value it points to.
In fact, the PK should be a auto-number primary-key index, such that the numbers are never recycled and no record's number ever changes. You can think of a primary key ID as the identity of the record.
RDBMS normalization is not about saving space, it's about removing redundancy. You can imagine all history events with the same ID being attached to the same Employee with this ID.
Employee.ID should be an auto generated field (auto_increment) called Employee.EmployeeID, and it's value only set by the database system. History.EmployeeID would be a foreign key referencing Employee.EmployeeID by having the same value. You can use bigint as a datatype and it should be enough for most use cases.
I can establish a relationship between History.EmployeeID and Employees.ID with a foreign key, but that duplicates data. So then History.EmployeeID and Employees.ID would contain the same ID number which would be stored in memory twice. So if I went into the database and changed John Smith's employee ID, I would need to write a script or something to scour the database and do a find/replace for that ID.  
What you want to have is a second row Employee.HumanID, which stores the ID of your Employee in business terms, for example a string that says "EmpID-007x". You can then easily change the HumanID of an Employee without affecting the integrity of the foreign key constraints.
This may sound like a dumb question, but I am a software developer new to database design... So the concept makes sense to me, but maybe this doesn't carry-- 
Example: If I have two tables... one containing a list of all employees and another containing a history of those employees coming and going from the office.
Another consideration would be to use HISTORY, or better ATTENDANCE as a list of time spans, having both a start and an end date. You would need to create the end date as infinity or something when you create the Attendance entry, but it is a lot easier to process things like working hours, just do a:
Is it possible for a field in a record in Table B to simply point to a field in a record in Table A?
By way of real life example, as you grow older, your facial features change, and your ears get bigger, and your hair turns silver, but you never lose your identity, the very core of your physical self.
And the JOIN this with another table and so on. Also note, that I instinctively used EMPLOYEE in the singular.
What I want is for Employees.ID to contain the real ID and History.EmployeeID to simply contain a pointer to Employees.ID. That way, if I updated John Smith's ID, the change would be centralized to one field in one table.
You tagged this question with MySQL, so I'll answer with respect to MySQL: there is no support for this pointer concept. In a relational database, columns contain values, not pointers.