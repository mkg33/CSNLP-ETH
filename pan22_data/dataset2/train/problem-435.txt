My shell is zsh, which should give you a hint to what's happening here: That $0 is interpreted by the shell spawned to parse the command line sent over the SSH command.  If we just escape the $0 and "$@" parts like: ssh foo  strace -vff -e execve bash --login -c 'exec \$0 "\$@"' ls -lrt we get:
The ssh accepts exactly one argument as a command, therefore it should be in the quotes or apostrophes. The same applies for the bash -c argument -- it is just a single argument that is accepted. The others are passed to the bash instead of ls. The following example works just fine:
I know I've problems from the 2nd example itself. But I was just trying something to make it work and to find where the problem is. The 3rd example is not showing any error/output at all.
I assume you're using ls -lrt as a proxy for some other more complex command that actually needs bash --login and such, else just do what  suggested in the first comment and use ssh foo 'ls -lrt' instead.
execve("/bin/bash", ["bash", "--login", "-c", "exec", "$0", "$@", "ls", "-lrt"], ["LANG=... As you can see here, bash is called with the arguments --login, -c, exec, $0 and so on. This doesn't get us all the way to where we want to be, since it's now effectively just calling exec by itself.  To work around this, we need to quote what comes after the -c argument so it's not unpacked too early, like ssh foo strace -vff -e execve bash --login -c '"exec \$0 \$@"' ls -lrt:
This is accepted by bash, since it allows you to use $@, but if you're writing proper POSIX sh, you should use "$@", in which case the right answer is ssh foo strace -vff -e execve bash --login -c '"exec \$0 \"\$@\""' ls -lrt: