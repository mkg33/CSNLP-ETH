It doesn't appear to me that the testADC flag can actually change during the course of the loop, and by definition of the previous loop, msgCount was just checked.  For those reason, I suspect that the second loop can either be made unconditional or omitted entirely.  It's also already been mentioned, but consistent application of code style (e.g. placement of braces) will make your code easier to read and maintain.
In this code, there are a number of calls to things related to GSM.  For example, we have GSMgetNum() and GSMcheckBalance().  I don't much like either of those because their names are somewhat misleading.  I would expect a function named GSMgetNum to return a number, but it apparently returns nothing, instead putting the number somewhere ... but where?  Also GSMcheckBalance() is not a very good name either, because I suspect it doesn't just "check" but actually gets the balance.  There are a few approaches possible, but I'd suggest creating a struct to hold such values and then passing a pointer to the struct to the various routines.  For example:
I don't instantly understand the intent of the code.  In this case, there's an associated comment which says:
I see that there are already some functions such as ADCinit and ButtonsInit which, I presume, handle setting up those subsystems.  I'd suggest reducing the main code to something like this:
The advantage is that now the code itself is telling you what's going on so there is no longer a need for the comment, nor any possibility that the comment and code will say different things.  It's all too easy over time to wind up with code like this:
In addition to the comments already made regarding code formatting and the avoidance of global variables, (hint: if there must be globals organize them into structures) here are a few more things that may help you improve your code.
That's a relatively extreme makeover, but what it does is very clearly show the overall structure of the program and that what is happening is first an initialization and then an infinite loop processing messages.  The complexity of each of those can then be moved to separate functions with clearly delineated assumptions and responsibilities.
Getting these interfaces both sufficient and minimal is one of the hardest but also most important task with embedded system programming.
In this case, (not from your code -- just an example!) the comment is wrong -- the code actually turns the LED on, not off.
Because ctrl is a variable with the scope of all of main, the compiler (and the human reader of the code!) will both have to figure out whether this value is used somewhere else later on.  It is not, so the compiler can safely use that register for some other purpose after the code.  Better would be to make that explicit to both the human reader of the code and the compiler:
The current code uses ctrl (which is an awfully nondescript name) for multiple purposes.  In one case, it's the number of times the GSM test code will attempt.  In another, it appears to be an index variable for stepping through a string.  I'm betting that the intent was to minimize the use of memory or registers, which is a worthy goal, but in fact, the compiler will do a much better job of that than you will if you don't do things that way.  For example, look at this code:
We have initI2C and initMPR121, but also ADCinit, EEPROMInit and ButtonsInit.  I'd suggest establishing some convention and then using it consistently.  I've used a few different conventions for embedded systems in the past, but the one I find that seems to work best for me is to do something like a C version of object-oriented code.  That is, I'd have all of the functions for a particular subsystem prefixed with the name of the subsystem.  It most resembles what you mostly already have for the EEPROM.  I'd name the functions like this:
With that, it's immediately clear to both compiler and human readers.  Note too that unlike the original code, this code explicitly sets or clears all bits no matter what the input might have been.  
If you wanted to, say, change from an IIC LCD module to a SPI-based LCD, it appears that the code is already well suited to accomodate such a change.  The main routine only appears to use initLCD and LCDstring which both seem to do a pretty good job of hiding the implementation details.  (I'm guessing that the first two arguments to LCDstring are row and column?)  However other components don't appear to be as nicely isolated.  The ADC in particular does not appear to have a nice interface for your application.  I'd suggest writing one, perhaps using the language of the problem domain as in getVoltage() rather than in the language of the problem solution (your particular hardware) such as ADCSequenceDataGet().