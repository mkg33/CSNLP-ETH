Next thing I would expect is some kind of switch that decided what calculation is used based on some kind of external parameter. This could be extracted first into individual class with method and then into class hierarchy with inheritance/interface, with concrete implementation passed in instead of "type" discriminator. To make it more complex, each of those calculations might want different input parameter, which might create complex method parameters, but would be simple if each concrete "calculation" class has it's own parameters.
So, in my opinion, best way to give people idea about OOP is to start with some complex behavior and show them how that behavior can be structured into classes.
In the end, this will show classes are just different way how to structure behavior and that there might be classes that don't have noun (or a thing) associated with them.
My primary working example of a "Big Noun" is a Whale, and I try to bring analogies back to this when possible.
OOP: I draw heavily from Yegge's Kingdom of the Nouns to describe OOP, since I think it is both a good description and a hard criticism of OOP. The "Noun is King" and we design everything around that. Yegge has lots of good analogies directly in his description, but I don't employ all these at first. I do emphasize that we design everything around some "Big Nouns."
Unsurprisingly, these classes contain a lot of similar code. They both move, etc. so we can take that code and break it out into a common base class...
Few things I would expect from this code. First I would expect there to be a complex method, with lots local variables and lots of code accessing those variables. This could then be refactored into class with local variables turned into fields and whole method split into smaller methods, each having access to the fields.
Next I would expect there to be some plain data structure, with code operating on this data structure. Maybe the above step would extract a method that works only with this data structure, and then that method could be moved into the data structure, making it a proper class. This could also work by introducing private fields, as the internals of the data structure might really be accessed by it's member method.
I might be in minority here, but I hate using THINGS as analogy to classes. Classes are about abstracting behavior, and THINGS are not behavior.
I'd turn the lesson on its head. Say, I am writing a game and I need to track what's going on. To start my game is going to feature a "good guy" running around fighting "bad guys". So I write Good guy and Bad guy classes. 
Idea that immediately comes to mind is to start with some complex, procedural code and use refactoring to create class structure out of it. This will allow students to contrast and compare two possible ways how code can be structured.
Procedural solutions: moving pieces of data around and manipulating them. I go back to a cooking analogy and compare programs to recipes: break eggs, add flour, beat those, add vanilla, etc. I say we think about programs in terms of basic ingredients (inputs), containers (variables), moving these around (control flow) and doing things to them (operations).
At the point in my CS1 class where we discuss OOP, my students are somewhat comfortable with the procedural paradigm. So, we first reflect on that before talking about OOP.