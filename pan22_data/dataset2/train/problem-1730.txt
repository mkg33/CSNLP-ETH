So just as a first statement, A* is at heart a graph exploration algorithm. Usually in games we use either tiles or other world geometry as the graph, but you can use A* for other things. The two ur-algorithms for graph traversal are depth-first-search and breadth-first-search. In DFS you always fully explore down your current branch before looking at siblings of the current node, and in BFS you always look at siblings first and then children. A* tries to find a middle-ground between these where you explore down a branch (so more like DFS) when you are getting closer to the desired goal but sometimes stop and try a sibling if it might have better results down its branch. The actual math is that you keep a list of possible nodes to explore next where each has a "goodness" score indicating how close (in some kind of abstract sense) it is to the goal, lower scores being better (0 would mean you found the goal). You select which to use next by finding the minimum of the score plus the number of nodes away from the root (which is generally the current configuration, or current position in pathfinding). Each time you explore a node you add all its children to this list and then pick the new best one.
One thing that's important to visualize when dealing with A* and Dijkstra's Algorithm is that A* is directed; it tries to find the shortest path to a particular point by "guessing" which direction to look. Dijkstra's Algorithm finds the shortest path to /every/ point.
Because the heuristic never overestimates, and the distance travelled so far is known to be accurate, it will always pick the most optimistic next step.
At each step, A* looks at the most promising path so far and picks the next neighbouring node that appears to be 'best', based on the distance travelled so far, and the heuristic's estimate of how far would be left to go from that node.
You might find ActiveTut's article on Path Finding useful. It goes over both A* and Dijkstra's Algorithm and the differences between them. It's geared toward Flash developers, but it should provide some good insight on the theory even if you don't use Flash.
A* begins with the start node, and tries successive permutations of that node plus each neighbour, and its neighbour's neighbours, etc., using the heuristic to decide which permutation to try next.