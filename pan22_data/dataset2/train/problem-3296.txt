The reason for the importance of pointers or something like them (references) is that some program data must live longer than the lifetime of a single function invocation, hence the stack managed memory isn't sufficient. And sometimes there is so much data that static (for all time) allocation isn't efficient. Hence, values must come and go, but asynchronously with function/method invocations. 
If you start with C, you meet them very quickly, because they are immediatly required, together with dereferencing, for (emulating)  passing parameters to actions "by reference". Exemple void swap_ints(int *ptr1, int *ptr2).
The other thing that is difficult is that is possible to orphan still-needed items in memory.  Try coding a singly-linked list from scratch in C without having memory leaks.  It is an edifying and humility-instilling experience. Warning: valgrind will hurt your feelings.
But in a language like C, in which the programmer is responsible for both allocation and deallocation of the blocks to which pointers refer, there are many traps. The two big ones are forgetting to deallocate at all, hence running out of memory in a long program, or trying to deallocate twice, causing a crash. The problem isn't easy in a complex program as the pointer variables are passed around between functions and if a block is deallocated but some pointer still points there and tries to access the block, bad things happen. Depending on the language they can be a simple crash or a run-away program. 
The basic idea of pointers is simple, but here are two examples that illustrate why they are tricky, even in a language like Java that handles memory management for you.
Are pointers hard? Not really.  They are just virtual memory addresses.   What is hard is memory management.  This is illustrated by the fact that browsers, run for a period of time, develop memory leaks and become slow as molasses.   Browsers routinely have exceptions during their execution: URLs are malformed or nonexistent, network connections evanesce, etc.   These often result in memory leaks.
What is hard is managing the heap.  valgrind is a great tool for this. Often poor exception handling leads to pools of undeallocated memory  that pile up like cholesterol in the veins of your program.  
The idea is simple enough, but the usage is complex. Furthermore, in such languages, the programmer has to solve the memory management problem for every individual program. In higher level languages, the memory management is by the system.
In a nutshell, we can say that though pointers appear to be a simple idea to understand their basic functionality, the difficulty arises due to the many associated concepts of pointer management and utilization. These are referencing, dereferencing,  allocation, deallocation, sequential indexing, parameter passing (call by value!), pointers to pointers, typecasting, self references in objects, dynamic binding etc., which need to be understood to know how pointers can be used correctly and efficiently. To address a part of the difficulty of pointer management, we have the auto_ptr template class in the c++ STL.
As many others already wrote before, pointers by themselves are simple objects - in the C sense, not OOP - containing addresses of other objects. 
The problem with pointers isn't at the level you have described, but in the use. In languages like Java the "reference" variables are basically pointers but the usage has been made safe via a garbage collector. 