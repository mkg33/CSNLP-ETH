The output routine is a separate function, but the input routine is not.  Is there a good reason for the difference?
Other locales include accented alphabetics in std::isalpha, and other encodings are not contiguous (the obvious example being EBCDIC).
We can make the map deal with case-folding for us, and have it map all non-alphabetics to a single entry, by providing a custom comparator:
The print method can now just iterate over the map, skipping the first element if it's not alphabetic:
Proficiency in C++ is the ultimate goal, but on that path, coding and compiler flags to produce the tightest executable are priorities. Without having delved into it deeper, but I think
[2J[2;47HAlphabetic character weight calculator[6;18HUsing: [1;35m/usr/share/dict/words[0m --> [1;2;36m3091845[2;37m of 3493701 = [33m88[1;37m%[10;49H[34m[[1;33mA[34m][1;36m   76[6C[34m[[1;33mJ[34m][1;36m    1[6C[34m[[1;33mS[34m][1;36m   98[6C
As part of another project that I'll be calling PHRASEG, which is essentially a hangman type game, I need to establish character rankings, based on a reasonably large text file. Each game will start @ 100 and by choosing vowels as an example, the score will be reduced significantly versus less frequent characters like J or Z.
On Debian systems (including Ubuntu), installing any wordlist will create a symlink /usr/share/dict/words pointing (via dictionaries-common) at the administrator's choice of default.  In my case, I have words -> british-english-huge, but I don't have /usr/share/dict/american-english.
This code writes terminal-specific escape sequences to std::cout, but you haven't confirmed that it's connected to a suitable terminal.  You may be connected to a file, a socket, or a different kind of terminal.  As it is, I find this kind of output hard to read:
I'll argue for a std::map<char,unsigned> to map from a character to the total of its appearances.  This means that we don't need to know what characters are considered alphabetic in the current language, as we can simply let the runtime manage that for us.  I'll write that as
It's a good idea to focus on the data structures and the operations the code will make on the data.  If we were doing object-oriented design, we'd probably create a class with methods to update from a file, to print the contents and so on.  But we can do the same with a simple map and some free-standing functions if we prefer.
It's quite tricky to get this right, given that /usr/share/dict/words is probably not in the encoding you want (here, it's in ISO 8859.1, but my terminals are all UTF-8, so some conversion is required).  I was able to make it work, by assuming that we can widen unsigned char to wchar_t by simple cast (I also added some sorting, in case that's of interest):