since if you have twenty-five $1 bills, you can make change for all dollar amounts from $0 to $25. But this calculation, that should be trivial, takes a very long time:
And good luck waiting for, say, change({1:100}) to finish running. So we can improve the performance in these cases by taking advantage of the fact that if have \$n\$ bills of denomination \$d\$, the possible values are \$0, d, 2d, \ldots, nd\$, that is, range(0, (n + 1) * d, d). Using itertools.product we can write it like this:
The algorithm loops over all subsets of bills. But this doesn't take advantage of the fact that bills of the same denomination are indistinguishable. For example, we know that
First up, I'd start by wrapping your code in a function.  This will help to define what it is your expecting to be passed into your algorithm and what you're expecting back out of it.  This in turn will make it easier to reuse the functionality if you decide to ask the user for the note information / read the information from a file instead.
For example, say you have 2 fives and 2 tens in your wallet. With these, you can make exact change for $0, $5, $10, $15, $20, $25, and $30.
I'd also think about the comments you're using.  Generally I try to use comments to describe why something is done, not what is done.  Programmers can tell what the code does by reading the code, so the why is the missing bit.  This also helps to stop the comments from getting out of sync with the code if you refactor.
"(e.g. three $1 bills", where the code only shows one $1 bill.  Should it be 1 or 3, is the comment right or the code?