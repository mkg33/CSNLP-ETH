So, what can you do about this? Well, as l0b0 said, one possibility is to set the pipefail option. You don't have to do this for the entire script, you can set it just for that particular subshell by doing it within the command substitution:
...while with the redirect option it won't. Also, with the second option the shell is responsible for opening the file (and handing the open file handle to the wc command), so if that fails it's the shell that gives an error (note that the error message comes from "-bash", not wc) and wc never gets run.
...but that doesn't work with a pipeline in a command expansion like $( ), because that pipeline is going to execute in a subshell, and PIPESTATUS can't propagate from the subshell; only the final status gets passed back to the parent shell:
There are a couple of differences between these two options: if you pass the filename to wc (and it exists), it'll output the filename as well as the number of lines:
Normally in bash, you can get the statuses of individual command in a pipeline with the PIPESTATUS array, like this:
The problem here is that in the pipeline cat "$filename" | wc -l, when the file doesn't exist cat will exit with an error, but wc -l will successfully count the 0 lines of text it receives from cat. The exit status of the last command in the pipeline is treated as the final status of the pipeline as a whole, so the whole pipeline is considered to succeed. Like this:
For this particular command, you can also eliminate the pipeline (it's what's called a Useless Use of cat, or UUOC), and have wc read directly from the file, either by passing the filename as a parameter: