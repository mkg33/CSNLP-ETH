It was also tremendously convenient for a situation where I had to delete backups.  I could mv an entire month of backups into the trashcan, mv the few I wanted to keep (1st of month, 15th of month) back into the backups, then rmTranshcan the rest.  Doing a similar command is hard to do with rm on its own, and doing it this way let me ls the backups to be confident in what files I am leaving behind (rather than just enumerating the files I intend to delete)
Also I suggest people never cut and paste a globbing wildcard pattern on a potentially destructive command line.  Because in my own hands that has been a problem :)
If you are working on a system where you are the only one accessing it, you might be tempted to just chmod 777 everything, but that is not the way a rational system is setup. Instead permissions should be something like 755 for all directories and 644 for all non-executable files. Executable files should be 755 at the least, but maybe even 744 if you only want others to read but not run the files.
For small recursive deletions, you can hold down the y key, once you're sure the command has been typed correctly.  For large deletions, you can abort the operation, and use commandline history to carefully change the -i to a -f.
A tech in my lab just made this mistake last week (3 months of work) - and yes we had a backup (1-day behind).
Meaning this is all a user interface issue even if it is on a text/command line level. How many safety nets do you expect there to be to protect you from doing something you shouldn’t? It’s like a pair of scissors: If you are somehow negligent and slip and cut your hand while intending to cut cloth or paper, who is at fault? Or even traffic lights and stop signs: There’s really nothing stopping a driver from running a light or ignoring traffic signs other than an acute awareness of what might happen if they do engage in such risky behavior.
This allows an inspection of the wildcard expansion, and then use of the exact same glob pattern without the possibility of inserting a space before the *. 
Try composing your initial rm command without the -f flag, but with -i instead, such that rm will prompt you for each file it intends to delete.
That said the best, realistic solution lies in system permissions for users as well as groups. That is the best/only real safety net to protect a user from themselves.
If I am in a situation where deleting the wrong files is a really big deal, one of the things I've done is make a trashcan folder, like mkdir trashcan, and then I have a script rmTrashcan which has a rm -rf trashcan/* or rm -rf * or similar, written very carefully and checked several times.
That way, if I make a mistake, the mistake is on a mv command, not a rm command.  Once I do a ls and am confident of exactly what I am deleting, a rmTrashcan actually does the dirty work safely.
(I don't actually expect this approach to be useful -- too many ways to mess up a command destructively to find them testing one-by-one -- but it provides a literal answer to the question).
A DEBUG trap could be written to cancel commands that look suspicious. The following, or code similar to it, can be added to your ~/.bashrc:
Not really. It’s proposed in another answer you could create a custom command to add a prompt before executing a task. But the problem with this custom command is it must be consciously installed on systems you are working on. And even if it is installed, the problem is your reflex to hit y to get the task done with could come into play.