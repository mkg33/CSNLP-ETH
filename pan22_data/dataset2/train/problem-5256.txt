Now the important thing is to understand the threading model. You need to establish how you want to distribute your computation across threads. And then how many threads you want per a thread group and then finally how many thread groups to dispatch with the device context on the CPU.
From what I can tell, it's simply a new type of shader file that makes use of HLSL. My question is this, does my program (aside from being DirectX 10 / 11 ) need its structure changed?
The overall structure of the program will be similar to that of a graphics application.  You'll need to initialize Direct3D the same way and load / set up all your shaders/buffers/textures the same way.  You'll call the Dispatch method to kick off a compute shader job, instead of one of the Draw methods.  
The number of threads per a thread group is declared in the shader file. It's also important to note that you logically distribute the thread groups and threads across a three dimensional array. So if I were to dispatch (2, 8, 1) thread groups where the shader declares each thread group as (1, 8, 1) threads. This would execute 128 instances of the kernel.
Also some peformance tips, minimize context switching of the pipeline from computational use to standard rendering use. Also avoid having to read data from the GPU as much as possible. Locking and reading buffers from the CPU is expensive.
Yes, you initialize it like every other shader type using it's specific CreateComputeShader call with the device handle. And you bind it and it's required resources just like every other shader type being executed.
For general synchronization, compute shaders offer some atomic functions and what are called memory barriers. Memory barriers are essentially synchronization mechanisms for shared memory among thread groups.  
I mean, is it simply a case of creating the CS file, setting in the project like I would any other shader, and watch the magic happen?
I've been trying to make use of the GPU as part of a project of mine. I've looked into both CUDA and OpenCL, but the lack of information showing you how to introduce these into a project is shocking. Even their dedicated forum groups are dead. So now, I'm looking into DirectCompute.
I suggest you don't skip the first couple of videos as they cover important concepts about the GPU and the threading model as pointed out by KlashnikovKid and Nathan Reed.
Some other important things to note, buffers that are going to be written to within the compute shader must be bound as unordered access views to the pipeline while read only buffers can be bound as a resource views. There are also some nifty new buffer features. An important one to note are the Append/Consume buffers. These allow you to pop and push data to and from a buffer with out having to worry about synchronization with other threads.