For audio, the chain was something like SoundSources  -> [Decoders] -> Buffers -> [3D Positioner] ->[Effects] -> Players. 
I haven't done this for graphics, but I did create a cross-platform audio toolkit (PC/XBOX/PS2).  We went the route of creating our own API with a least-common-denominator capability as well as optional platform-specific capabilities.   Here are some lessons learned:
Implement as much of the front end as possible with platform neutral code.  The code to attatch a reverb object to a sound object, or a texture asset to a shape object should be completely common, as should the code to iterate through and process active objects.  On the other hand, the low level objects can be completely platform specific except for the common interface.  
Definitely develop the platforms in parallel.  Make sure that the platform specific interfaces are well defined and testable on their own.  This prevents a lot of the "is it the platform level or the API level?" issues when debugging.
The key is to define a processing path that encapsulates the core capabilities of each platform, and allows growth.   In order to do this, you need to really understand each platform's low level API so that you can identify the right abstractions.   Make sure the chain works for the least capable platform, while providing access to the most capable patform's advanced features.  Do the work to get this right and you will save a lot of effort later.  
For graphics, it may be Model -> Shapes -> Positioner -> Texturer -> [Lighting] -> [Particle Effects] -> Renderer. (This is probably a completely wrong set, I'm not a graphics guy).
Write a front-end API which handles your core objects, and a platform-specific back end which maps the API to the low-level capabilities.  Provide a best-effort for each capability.  For instance, on the PC and XBOX the 3D audio positioning was done using the HRTF capabilities of the sound chips, while PS2 used a simple pan and fade.   A graphics engine might do something similar with lighting.
Make sure the API, or configuration files, allow the user to specify platform-specific options.  We tried to avoid pushing platform-specific code to the game level by keeping it in configuration files:  One platform's config file can specify "effect: SuperDuperParticleGenerator" while another says "effect: SoftGlow"