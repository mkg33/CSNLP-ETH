Most of the replies focus on the fact that you have a larger, 64-bit address space, so you can address more memory.  For about 99% of all applications, this is totally irrelevant.  Large whoop.
On OSX there are other advantages. See the following article, why having the kernel run in 64 Bit address space (regardless if your app runs 64 or 32) or having your app run in 64 Bit address space (while the kernel is still 32 Bit) leads to much better performance. To summarize: If either one is 64 Bit (kernel or app, or both of course), the TLB ("translation lookaside buffer") doesn't have to be flushed whenever you switch from kernel to use space and back (which will speed up RAM access).
Also, the subroutine caller/callee conventions for 64-bit have been defined to keep most of the passed parameters in registers instead of the caller pushing them onto the stack and the callee poping them off.
If it lists EM64T, your CPU supports 64 Bit address space according to x86-64 standard. You can also look for
The real reason 64-bit is good is not that the registers are bigger, but there are twice as many of them!  That means that the compiler can keep more of your values in register instead of spilling them to memory and loading them back in a few instructions later.  If and when an optimizing compiler is unrolling your loops for you, it can unroll them roughly twice as much, which can really help performance.
So a "typical" C/C++ application will get about a 10% or 15% performance improvement just by recompiling for 64-bit.  (Assuming some portion of the app was compute bound.  Of course, this is not guarenteed;  All computers wait a the same speed. Your Mileage May Vary.)
The term 32-bit and 64-bit refers to the way a computer processor (also called a CPU), handles information. 64-bit versions of Windows handles large amounts of random access memory (RAM) more effectively than 32-bit systems.
If it says 1 (true/enabled), your CPU supports the x86-64 Bit mode, if it says 0 (false/disabled), it does not. If the setting is not found at all, consider it being false.
A 32 Bit process has a virtual addresses space of 4 GB; this might be too little for some apps. A 64 Bit app has a virtually unlimited address space (of course it is limited, but you will most likely not hit this limit).
To find out if your CPU can run in 64 Bit mode, you can look at various sysctl variables. E.g. open a terminal and type
Note: You can also fetch sysctl variables from within a native C app, no need to use the command line tool. See
Under most scenarios, 64-bit programs use a bit more memory, but for a personal computer, this is typically not noticed.
Last but not least the x86-64 architecture offers more registers than the classic x86 architectures. Working with registers is much faster than working with RAM and the more registers the CPU has, the less often it needs to swap register values to RAM and back to registers.
Also you have performance gains when working with "long long int" variables (64 Bit variables like uint64_t). A 32 Bit CPU can add/divide/subtract/multiply two 64 Bit values, but not in a single hardware operation. Instead it needs to split this operation into two (or more) 32 Bit operations. So an app that works a lot with 64 Bit numbers will have a speed gain of being able to do 64 Bit math directly in hardware.
With a 32-bit machine you only have 4,294,967,295 bytes of memory to address. With a 64-bit machine you have 1.84467441 Ã— 10^19 bytes of memory. 