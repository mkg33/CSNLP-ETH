For the big zoom-out you want to be able to apply, you have to use mipmaps. Mipmaps are lower-resolution versions of your textures which are used when the objects are far enough from the camera. This means that you could save your 8192x8192 as a 4096x4096 and then another of 2048x2048 and so on, and you switch to the lower resolutions the smaller you see the sprite on the screen. You can both save them as separate textures or resize them when loading (but generating mipmaps during runtime will increase loading times for your game).
You really shouldn't be making this game in raw 2D. When you have fixed perspective a funny thing happens, you can seamlessly mix pre-rendered sprites and backgrounds with live-rendered 3D models, that has been used heavily by some games. If you want such fine animations that seems like the most natural way to do it. Get A 3D engine, configure it to use isometric perspective, and render the objects for which you continue to use sprites as simple flat surfaces with an image on them. And you can use texture compression with a 3D engine, that alone is a big step forward.
That is the sort of thing I would test to see if it helps. I imagine to get extreme zoom levels you will inevitably need an LOD system.
In this case the game will be trying to predict what the player will see in the future and load that in the background. (For example: stuff that is currently 2 screens away from the player.)
The next step will be to generate the mipmap versions of these textures as someone pointed out above. I would not store them in a single file but separately. So you would end up with 1024x1024, 512x512, 256x256 etc versions of each file and I would do this until I reach the lowest level of detail I would ever want to be displayed.
I recommend creating more atlas files that can be compressed with zlib and streamed out of the compression for each atlas, and by having more atlas files and smaller size files you can restrain the amount of active image data in the video memory. Also, implement the triple buffer mechanism so that you are prepping each draw frame sooner and has a chance to complete faster so that the stutters do not appear on the screen. 
A proper management system would load the required files on demand and release the resources when nobody is using them, plus other things. Resource management is an important topic in game development and you're reducing your management to a simple coordinate mapping to a single texture, which is close to having no management at all. 
First of all you need to use more, smaller texture atlases. The less textures you have the more difficult and rigid memory management will be. I would suggest a atlas size of 1024, in which case you would have 128 textures instead of 2, or 2048 in which case you would have 32 textures, which you could load and unload as needed.
I believe that the best approach is to split the texture in many files and loading them on demand. Probably your problem is that you're trying to load larger textures that you would need for a complete 3D scene and you are using Allegro for that. 
Now that you have the separate textures you can build a level of detail (LOD) system that  loads textures for the current zoom level, and unloads textures if not used. A texture is not being used if the item being rendered is not on screen or is not required by the current zoom level. Try to load the textures into video RAM in a thread separate to the update/render threads. You can display the lowest LOD texture until the required one is loaded. This might sometimes result in a visible switch between a low detail/high detail texture but I imagine this would only be when you perform extremely fast zooming out and in while moving across the map. You could make the system intelligent by attempting to preload where you think the person will move or zoom to and load as much as possible within current memory constraints. You can cache where the user has been until they move away.
I advocate breaking things up into smaller textures using whichever format you decided on. Determine the items that are always on screen and therefore always loaded, this might be the terrain and GUI atlases. I would then break up the remaining items that are commonly rendered together as much as possible. I don't imagine you would lose too much performance even going up to 50-100 draw calls on PC but correct me if I'm wrong.
Most games do this resource management by having level boundaries, while a loading screen is displayed all resources that aren't needed anymore in the next level get unloaded and resources that are needed get loaded.
Another option is On-Demand loading, which become necessary if level boundaries are unwanted or even a single level is too big to fit into memory.
Firstly find the most efficient texture format that you can while still being happy with the visuals of the game whether this is RGBA4444, or DXT compression etc. If you are not happy with the artifacts generated into a DXT alpha compressed image, would it be viable to make the images non-transparent using DXT1 compression for the colour combined with a 4 or 8 bit grayscale masking texture for the alpha? I imagine you would stay on RGBA8888 for the GUI.
I don't think loading and unloading will do a lot for you as you can have pretty much everything on screen at the same time.
There is one issue however, what happens when something unexpected happened that the game wasn't able to foresee?