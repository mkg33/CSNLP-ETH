Now on to the real question: for many years class hierarchies became deep and started to suffer from problems related to that.  In more recent times class hierarchies have flattened and composition and other data-driven designs are being rather than logic-driven inheritance.
I'm not sure what you mean by "too heavy," but C++/OOP is the lingua franca of game development for the same good reasons that it is used elsewhere.
Talk of blowing caches is a design issue, not a language feature.  C++ can't be too bad since it's been used in games for the past 15-20 years.  Java can't be too bad since it's used in the very tight run time environments of smart phones.
I reckon it would be cool that both troll and werewolf inherited its attributes from enemy and overwrote some of them. But maybe classes are too heavy to be practical, I don't know...
In Objective-C for iOS/Mac there are similar, but worse problems with the messaging scheme (even with the fancy caching stuff)...
It's all OOP and still used as the baseline when designing new software, just different focus on what the classes embody.
Often though it will still follow the OO concepts of inheritance and encapsulation - just implementing them differently to how the language does itself (e.g. curiously recursive templates, composition instead of inheritance (the component based method described by Marco)). If the inheritance can always be resolved at compile-time then the performance issues go away, but the code can become a bit hairy with templates, custom RTTI implementations (again the built-in ones are usually impractically slow) or compile-time logic in macros etc.
The method that I will be attempting to use mixes class inheritance and components.  (First off, I don't make Enemy a class -- I make that a component.)  I don't like the idea of using one generic Entity class for everything and then adding the necessary components to flesh the entity out.  Instead, I prefer to have a class automatically add components (and default values) in the constructor.  Then subclasses add their additional components in their constructor, so the subclass would have its components and its parent class components.  For example, a Weapon class would add basic components common to all weapons, and then the Sword subclass would add any additional components specific for swords.  I'm still debating about whether to use text/xml assets to define values for entities (or specific swords for example), or to do that all in code, or what the right mix is.  This still allows the game to use the code language's type information and polymorphism, and makes ObjectFactories much simpler.
Classes do not involve any run-time overhead. Run-time polymorphism is just calling through a function pointer. These overheads are exceedingly minimal compared to other costs like Draw calls, concurrency synchronization, disk I/O, kernel mode switches, poor memory locality, over-use of dynamic memory allocation, poor choice of algorithms, use of scripting languages, and the list goes on. There's a reason that object orientation has essentially supplanted what came before it, and it's because it's much better.
I've always wondered to what extent object orientation is used by videogames, especially huge 3D projects.
One thing to be aware of is that the concepts of object-oriented code are often more valuable than their implementation in languages. In particular, having to do 1000s of virtual update calls on entities in a main loop can cause a mess in the cache in C++ on platforms like 360 or PS3 - so the implementation might avoid "virtual" or even "class" keywords for the sake of speed.