Generally speaking it isn't possible to do real-time per-pixel masking with software renderers if performance is a concern. So you need to do the processing offline.
I know surfarray can be used for the task (after a list of pixel coordinates is extracted from surface B), but my tests were too slow and ended up hanging the main loop.
Is there a way to achieve the described above through an efficient and quick method, that can be embedded into the main loop of the application without a significant drawback to the overall processing?
If you don't use colorkey, you can achieve a similar effect using the alpha channel and the special_flags of the blit method.
If you need to recalculate this masked area every frame, then you're pretty much out of luck with PyGame - it uses a software renderer and doesn't provide the type of modern GPU operations that would make this practical on anything but tiny images.
I don't understand the task you are describing - masking is merely the act of selecting certain pixels to avoid operating on, so it sounds more like you are using a mask to perform some sort of colour replacement. If not, and you are literally just looking to render a part of surface B over a part of surface A, then the answer is to process surface B before the main loop starts so that the pixels you don't want to render have alpha values of zero.
I have been going through the documentation and the Pygame functions and classes today, but couldn't find a reasonable way to either create a circular crop of an image or how to use a mask to perform this: assume an empty circle with a line width of 50px, with a single key color, that is supposed to be removed from surface A and then replaced with the contents of the same pixels on surface B (perhaps I'm mixing definitions here between Pygame's Mask and image editors' - such as Photoshop - masks).