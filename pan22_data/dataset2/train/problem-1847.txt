Linux kernel information and controls can be accessed as files in /sys directory on modern linux distributions. For example:
To disable hyperthreading I include a script on machine /etc/rc.local. It is not exaclty clean, but is easy to install, independent of cpu architecture and should work on any modern linux distribution.
Old topic, but had reason to try this experiment. First, I am not at all certain that disabling the (slightly fake) CPUs at runtime is truly equivalent to disabling Hyperthreading at boot. That said, I did see a small performance boost in our application. (But not enough to keep.)
Now, the big question is whether or not you simply need a reboot for this to take effect, or if a full power cycle is required. Try it out and see how it goes!
For me, the problem with hyperthreading is: If I start as many cpu-intensive threads as I have logical cores, I will have fast context switches for the cpu intensive tasks, but expensive ones for the background tasks since the hyperthreading totally consumed by the cpu intensive tasks. On the other hand, if I start as many cpu-intensive threads as I have physical cores I will have no context switches to those tasks and fast context switches for the background tasks. Seems good, but the background tasks will found free logical processors and will run almost imediatedly. It is like they are realtime performace (nice -20). 
The "cpu-intensive" tasks I am talking about are artificial intelligence data mining and authorization servers (my work). Blender rendering in cheap computers and clusters (to sketch my future house). 
I had to wait until I could get into the ILO/Drac. The kernel boot parameters do not work on current Linux distributions.
In the libsmbios-bin package (Debian, Ubuntu, etc), you have the binaries isCmosTokenActive and activateCmosToken. Together with the token list, you can then try something like this:
Lukas' answer is nice but does not really work for disabling HT because core ID cannot serve for identification of HT siblings. This script works instead:
I do not know exactly why... but the system become more responsive with hyperthreading off (on my i5 notebook and massive Xeon servers with 60+ cores). I guess that has to do with per-cpu caches, per-cpu memory allocation, cpu scheduler allocation and process priorities complex iterations. I think the benefits of hyperthreading is outweight by the complexity of making cpu schedulers that know how to use it.
In the first scenario the hyperthreading is uselles, the background tasks will use expensive context switches because I maxed out hyperthreading with the normal processing. The second is unaceptable because up to 50% of my cpu power gets prioritized to the background tasks.