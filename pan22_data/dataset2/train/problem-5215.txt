With the approach outlined above, there's no overall data structure that dictates any structure (except listing all Cell objects), which means that each Cell object has to store references to its neighbours itself. The consequence of this approach is that the whole thing is stored as a graph (which happens to be a grid) with each Cell being a node.
That said, overall despite some of the naming quirks and distributed responsibilities I did find your code to be mostly expressive and easy to follow.  I particularly liked the way you had constructed the grids within your tests, so that they were laid out like a map to be processed.
Since you had provided them, the first bit of your code I looked at were your tests.  As has been pointed out by  @Roman Vottner, their names are not very descriptive.  test1, test2 etc tell the reader nothing about the scenario that is being tested.  I'm guessing that they should be called something like test5x5GridContains3Basins.
contains the 2D location of each cell already. But each cell also stores its position as member variables:
Having the method named test makes it appear like you're expecting grid to test itself, then solve itself.  Whereas with a different name it feels more expressive:
And I think it's because there's a conflict of responsibilities about where the location of a cell is stored. In some sense, the used data structure (a nested array)
The tests themselves are quite concise, although again as has been pointed out by @Roman, you're not calling assert.assertEquals which is what I'd expect.  All of your tests are also validating all of the basins in the returned list.  This is a good way to test a whole scenario, however it doesn't help you to know if you're testing all of the edge cases.  Having more tests that validate only a single thing can be more descriptive (this also makes it easier to name the tests).  For example:
From Grid.java's point of view, the solution is simple: Use a more general data structure like ArrayList for example, that allows you to "iterate over all elements" (which is what you are really doing anyway) with something like a for-in loop. If any action in the loop body requires the position of the cell, it can retrieve it from the cell. This would reduce the necessity for the double for loop to the construction of the cells. I guess Streams could also come in handy to make things even more simple.
The first method read is called from the Challenge class and the second test is called from your test classes.  This duplication is caused by Grid knowing how to read information from the user.  It would be better to only expose a single method, possibly populateGrid(int [][] heights) or populateGrid(List<Integer>) and have another class responsible (or the main method) for constructing the array from user input.  This prevents the need the Grid class to differentiate between when it's being called properly and when it's being called under test.  This also removes one of the confusing aspects of your unit tests where you do this:
The responsibilities of your Cell class are confusing.  It seems strange for a class called Cell to contain an array of Cells.  I also found the field next particularly unexpected.  What does it mean to be the next cell?