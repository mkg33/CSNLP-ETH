This is a dangerous viewpoint, and I strongly urge you to reconsider. Many students find programming difficult. If you tell them that it should be easy, then you're going to dissuade them from pursuing it.
But after that, you need to acknowledge the aspects of programming that are difficult, and introduce strategies they can use to solve the problems they're stuck on.
For example, programming may become difficult because usually all these are presented at the same time, in one big introductory mix:
In the intro class I try to have grades be weighted towards solidity of understanding than on the number of concepts covered - so that a slower moving student still has a chance at a passing grade. I also encourage pair programming (when I figure out how to teach it and manage it well I'll require it) and collaboration in general.
OK, maybe I'm just a contrarian, but the approach that I take is to validate the experience that programming is sometimes hard. I tell my students that pretty much every developer hits patches where programming feels hard. The compensation is that it is also fun, and rewarding, and a "worthy" challenge.
Easy things are those that conform to our mental models, so every person has easy things different from those of others.
Your question immediately reminded me of Andrew Luxton-Reilly's paper, "Learning to Program is Easy" from a couple years ago at ITiCSE
Careful! That's a pretty aggressive statement, and is liable to make folks who really do have trouble feel pretty bad about themselves.
You may want to take a look at this question. Whether you believe the answer to ultimately be yes or no, you will find that even the most adamantly "no" teachers admit to some number of students who have enormous difficulties 
Interest is highly important, of course, but how your brain is wired matters a great deal as well. Don't discount real difficulties that people face. That's the kind of thing that causes people to beat themselves up mentally, when they're alone with their own thoughts.  Interest is important, but may not be sufficient, and dismissing the problems others face can be unkind.
One simple and standalone enough concept is that of function, the result of which is calculated by substituting the variables with the parameter values in an expression. It is a powerful primitive with a solid theory behind it and it is at the heart of the meaning of computation. It also is familiar to the students for their mathematical counterpart: computer science deals with the very concrete point of calculating the result, whereas the mathematical function just denotes it without saying more. It can be imagined on paper. After understanding it can be translated to formal syntax. From there you can build the following steps, being always grounded on something they are already familiar with instead of jumping straight to complex automatons written with curly braces from lesson 0, as they have no previous experience whatsoever with automatons and will not understand them without a concrete model.
How instead to make computer science difficult: I think of those "funny" introductory paragraphs on some books that discuss at length how to put together a strategy for an automaton to be followed to reach a longed for result, often with examples having nothing to do with computations and which no one would approach in such a contrived manner. I have a book with this example of "how to go to sleep the computer scientist way", the solution is "1. change clothes, 2. wash teeth, 3. enter bed, 4. turn lights off", wow! Now the student is ready for algorithms with curly braces (lol): irrelevant order made relevant, unknown automaton primitives, no management of state mutation (that will magically appear in the code), no input to configure the operations, no output result of interest. In short: nothing related to what they're going to learn. That doesn't help students the least: its ambiguity is dangerous, the student is left without knowing what he's doing because he has no model for his automaton to be instructed. He will just try to say random things totally unrelated to computation and will start his journey to despair for not understanding what automatic computation is and will pass on the voice that computer science is difficult. A clear model is of the utmost importance.
"This programming stuff is really hard for me. My teacher told me that it should be easy, so that must mean I'm really bad at it. I guess this isn't for me after all!"
And finally there's a real inherently difficult point: students can learn many tools but then they need their own creativity to make use of them, and this is not easily taught as far as I know. You can show examples and talk about how to analyze and synthesize solutions, progressively enrich their tool set, preferably from distant disciplines, but then it's their job to invent and test their solutions.
However, one point working for everyone is that of separating distinct ideas and let them be understood independently, while at the same time making their connections explicit. Of course this is not easy.
Others have already said well why you shouldn't dismiss the difficulties of your students. I'll address this other portion of the question:
Again, the first step is to acknowledge that their feelings are valid and normal. Being frustrated is a normal part of programming.
All these are intertwined. An abstract discourse doesn't make sense without at least one concrete instance. On the other hand a concrete instance might be too complex without its accompanying simplified abstraction.
Then focus on why they're frustrated. I think many students find programming difficult not because of the syntax, but because of the logic involved. Programming is really a process of breaking down a goal into smaller sub-steps and then identifying the syntax that accomplishes a particular sub-step. Even if students memorize syntax, this process is often new to them, and that's where they get stuck.
Instead, I think you should acknowledge that yes, programming is hard. It's normal to feel frustrated or to not immediately know how to solve a problem. Then teach them how to approach that: break problems down into smaller steps, debug, research, read through documentation, etc. 
I point out that they are learning a new language (albeit a relatively simple one if you measure by the size of the dictionary or the number of grammatical constructs), a new way of thinking, an often cryptic system for reporting errors, and dealing with an often fanatical "grammar nazi" (the compiler).
Then I make my early assignments fun and expressive and small - I want there to be motivation and room to experiment and I try to encourage a culture in the class where it is ok to "fail" and where throwing code out and starting over is an option (hence keeping early assignments small).
The less concepts the easier it is to learn, the less your tools demand knowing the easier it will be for the students.
I agree that getting students over the initial "programming is too hard / too nerdy / too mathy for me" hurdle is very important. For that, you might look into doing the Hour of Code challenge. Have students get something up and running, and they'll realize that it's not as hard as they thought it would be.
The tools used must also make it easier to actually separate what must be separated, to minimize the unnecessary noise.