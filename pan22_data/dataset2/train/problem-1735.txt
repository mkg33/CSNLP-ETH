As a workaround you can use PHPIniDir directive in Apache Configuration to force PHP to a use a particular php.ini file
After some time with the same problem, I realized that even tho I recompiled the PHP with the correct paths to load the configuration, I forgot to do a make clean before recompiling. Apparently it does not regenerate the specific part on php.ini load path unless you clean the object files.
Similarly apache should be able to read other ini files as well. They other ini files should have read permission for others or they should belong to user/group apache and user/group read permissions are set.
If directory /etc/php5/apache2 has either user or group owner as apache. Then atleast one of group or user should have read and execute permission on /etc/php5/apache2. Or simple give others read and execute permission on directory /etc/php5/apache2. That is,
If you did, on some operating systems it seems that apache will cache the data so instead of doing /etc/init.d/apache reload you will need to do either /etc/init.d/apache restart or /etc/init.d/apache force-reload
If there is an open() call that returns a number, then it would appear that it's reading the file in correctly, and there must be a problem with the file that's preventing php from parsing it correctly, but I'd expect this to be logged in the error log.
The nuclear option is to run apache under strace, to see what it's doing when it tries to read the php.ini file.
Last do not make php.ini 777. That could cause problem if apache is checking for security permissions on file to make sure it is not world writable. Use 755 on php.ini. That is more than enough to ensure that the problem is not due to access control.
Request your phpinfo() page in a browser, and then kill the strace using ctrl-c. You can now grep /tmp/apache.log for php.ini and see if there are any errors displayed when it tries to read that file. This will show you problems like the file not being found or permission problems.