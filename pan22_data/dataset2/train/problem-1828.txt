Take a look especially at the Renderman shader sample in the GLES samples directory, which provides a more-or-less bare-bones OpenGL ES 2.0 shader that might serve as a good starting point. And might also give you a good idea as to why there aren't many cut-and-paste examples of good shaders out there. The basic problem: that shaders are tightly coupled with OpenGL ES server configuration, and the models that get rendered on them. Still. The Renderman shader is an excellent starting point, if you can pry it loose from the REnderMonkey tool.
When I was looking how to implement fog under OpenGL ES 2.0, I have found link to OpenGL ES 2.0 backward compatible project implementing functionality, which is not in OpenGL ES 2.0, For example fog, per vertex, per fragment(pixel) shading. You can look directly into shaders source.
I have been implementing per fragment lighting too, modifying this example created by ClockworkCoders (not OpenGL ES 2.0).
The AMD RenderMonkey package contains very advanced shaders for OpenGL ES 2.0 among the sample files.
As a result there really isn't much in the way of the kind of repositories you are thinking of. The GPU Gems books offer a good collection of cookbook-style descriptions of techniques with both game and shaded code examples that you may want to take a look at, though. So do the Shader X books.
Take a look at GPUImage (https://github.com/BradLarson/GPUImage), its probably the most complete collection of shaders I have found on the web so far.  Since they are all designed to work with GPUImage, they all share the same structure, so if you adapt the same structure in your application/game you should be able to quickly import a number of different effects.
Shaders of any complexity aren't generally the kind of thing you can download and drop in to your project like interchangeable cogs. Typically the more interesting effects require a fair bit of coupling to the CPU-side rendering subsystem in order to achieve their results. The same is generally true of performance -- performance tradeoffs with respect to accuracy and quality over instruction count or pipelining tend to be rooted in application-specific requirements.