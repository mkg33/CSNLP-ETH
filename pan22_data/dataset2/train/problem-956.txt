By inspection, the 2nd, 4th, 6th, 8th, and 10th digits must be even.  By elimination, the 1st, 3rd, 5th, 7th, and 9th digits must be odd. These constraints alone could reduce the search space by a factor of 1024.  Furthermore, the last digit must be 0, and the 5th digit must be 5.  If you hard-code those constraints as well, then the search space would be reduced by a factor of 25600.
Basically, you're testing a lot of paths you don't have to.  It would probably be more efficient to find a 1-digit number that is divisible by 1, then use that digit to find a 2-digit number that is divisible by 2, then use those two digits to find a 3-digit number that is divisible by 3, then recursively backtrack if you run out of options at one level.
The other answers give very big performance improvements but require very big efforts and code re-writing.
However, for one-shot problems like these, your solution is fine.  If you can't write a faster algorithm in less than 9 minutes (of your programmer time), you haven't actually saved any time.
I noted that (x `div` (10 ^ 0)) `mod` (10) == 0, is the same as x `mod` 10 == 0, so we can skip that condition and just go in steps of 10 in our range:
This solution is slow because it is the most brute-force approach possible. You're checking all 10-digit numbers, discarding those that fail the uniqueness and the divisibility criteria.  On the other hand, it is also the most straightforward code possible, and a more efficient solution could easily take more than 9 minutes to write. On the third hand, finding the answer by feeding the problem literally to the computer doesn't demonstrate any insight, and in my personal opinion takes the challenge out of the challenge.
Here's some code to illustrate.  It returns essentially instantly in my REPL.  You call it by pizza 1 0 initially.  