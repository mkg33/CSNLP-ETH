Note, we use the set-based handling in python. Convert the alphabet to a set, and then get the difference between the password set, and the alphabet. With that, if there are any characters left, then the password is not a match (there are characters in the password that are not in the alphabet).
What you are doing is reading files until you find one which has a password that is only letters a through z. How about code that does the negative of what you have:
Could this be considered a basic brute-force? Sure, for a limited use-case, but even then it is pretty inefficient.
In your case, you are just checking each letter 1-at-a-time, against the raw password. That's not a very realistic situation. Still... you are brute-forcing things.
Additionally, I found that your readFile method does not do decent end-of-line handling, so I had to create a file without a line-terminator to make the code work... is this intended?
You would normally have to generate many possible passwords, and hash the results, and then see if the hashed results match the known hash, and from that, deduce that the passwords must have been guessed.
To be clear, normally a brute-force system requires checking all combinations against some hashing function to see if the hashed result matches the hashed password. For example, imagine the password is "password", and the hashed version of that is: 286755fad04869ca523320acce0dc6a4 (that's the actual MD5-hash of "password"). What you normally have for a brute-force system, is the hashed version, not the original version.