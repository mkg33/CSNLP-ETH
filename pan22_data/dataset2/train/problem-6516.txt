The difference in one direction tells you which objects have been removed from the AoI set. The difference in the other direction tells you which objects to added to the AoI set.
You are asking roughly about Area of Interest: finding all objects within range of a player for which it should receive network updates.
Yet another trick is to add a delay to objects leaving the update set. This is another potential solution for objects sitting near the AoI range, as well as avoiding frequent add/forget messages if using a Cone of Interest and the player is looking around a lot.
Note that you really don't just want a single range like this. You want two ranges: a closer "add to AoI" range and a larger "remove from AoI" range. Otherwise, you easily get into a case where objects ping-pong between being in AoI as they move along the edge of the AoI range, which can lead to excessive amounts of network traffic for add/forget packets, along with whatever client-side work those packets trigger (like loading/unloading resources). Using two separate ranges with a suitable distance between them avoids this from happening in every case except where an object is just moving back and forth, close and far.
Note also that this all applies pretty much equally to other range-based systems like chunk loading in an open world game.
You can also apply other AoI schemes on top of this. For instance, you might have an Explicit Object of Interest system that ensures a particular object stays in a client's update set independent of range. This can be useful for enemies that are attacking the player or have recently been attacked by the player. You might also use AoI schemes that aren't just simple ranges, such as using the player's look direction to form a Cone of Interest.
The simple algorithm for a range-based test like illustrated would be to gather all objects within range (use your game's bounding volume hierarchy for this), and then calculate a set difference with the previous update's AOI set (just about every programming language has a standard library function for doing this efficiently; std::set_difference in C++ for example).
The short answer to your direct question: generate your list of visible entities in a container (sorted by id or the like) and use std::set_difference with the previous sorted list of visible entities.