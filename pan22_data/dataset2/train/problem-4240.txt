Using a tagged union would ensure only the size of the largest element is allocated plus any needed padding to raise the length to an alignment boundary (Ref: C: A Reference Manual, 5th Ed., Sec. 5.7.2, p.162). Using the corresponding enum, appropriate data can be accessed when traversing the linked list. Searching can be implemented with separate functions for each supported type.
Below are the source files and the CMakeLists file (which includes many runtime Clang sanitizers enabled). Alternatively, the code can be easily compiled with the following: cc *.c -o linkedlist && ./linkedlist
I have abstracted the design to practice the use of "opaque pointers", and have thoroughly commented and described each function in the code. Tests for all functions are in main.c
Instead of using void* or function pointers, I would say a tagged union would also offer a safe way to allow for more flexible node data. 
I have been learning data structures and dynamic memory allocation in C. As a learning experience, I have written this linked list implementation. I really appreciate the feedback I've received on the previous code I've posted here and would love to hear any suggestions you all have on improvements I can make to this.