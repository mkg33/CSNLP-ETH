Many of my peers will cling to an ArrayList no matter what the problem presents.  They are just comfortable with using it and prefer it over any other structure, even when that means a lot of extra code they have to write.
Rather than trying to motivate the students, or the reluctant ones, to progress into using your new tool (foreach after for), and finding a new motivating example every time, try to motivate them to be self-interested, lazy coders.
Begin at the beginning, with things that could not be simpler or more obvious. Add one thing at a time, and show how it solves problems. Steam engine, gasoline engine, gas turbine, rocket. You just will never get to space with Jules Verne's coal-powered "rocket train".
If you start with the most absolutely bone-simple programming concepts at the start, then as you introduce each more complex concept, it is obvious why it solves a problem that just could not be solved using the simpler stuff they already know: No number of separate variables will solve a problem that calls for arrays. No fixed size array will solve a problem that calls for expandable arrays, and so on.
Preferably contrasted against a functioning but god-awful student submission from the previous term. Show them how its an order of magnitude simpler than their shotgun-formatted needlessly complex mess. Show them what compactness and elegance look like. In freshman?sophmore? CS prof assigned us to write a CLI memory card game. I like many of my peers did this big elaborate class hierarchy and/or held the "cards" in nested data structures with nested loops. The prof's code was IIRC < 20 LoC: he used a flat array of structs with the modulus operator to determine the "row". I learned that day what Torvald's meant by "taste", namely the ability to know when to use "industry best practices" and when to just write simple code even if it's less flexible.
If someone wants to stick to older concepts that won't solve a new problem, they plain old won't solve the new problem. They can't stick, they either go forward with either new concept, or they fail out. This is why we reproduce the development of programming as it occurred: no one ever gets lost trudging along in the well-worn path. They never ask why something is better than something else: they know. 
I'm not sure the following will work for all students, but I remember this being a transformative "aha" moment in my own education:
The key is that the new concept is not presented as better programming, better presentation, or even easier to maintain, update, or fix later. Rather it's presented as a real solution, to a real problem, right now that makes less work right now for them. Less time on coding, now, means more time, now, to be with their friends, or do other fun stuff. After a couple rounds of that, once the light bulb goes on, they'll start actively looking for pre-baked solutions, and libraries will be their next target. That outlook will carry them well into the future, and could even encourage them to look at new languages, either new to them, or new to the world, for an easy solution to a problem.
I guess this kind of approach is very appreciated but the teacher has to give a huge amount of time in order for that approach to succeed.
As a student, I can say the appeal to my free time is pretty powerful motivation.  I have spent hours implementing features already present in a language only to feel foolish when I realized my folly. 
When I used to be a student learning C++, my teacher gave us a very open subject with only a subject : Star Wars (it was for the year of the release of the new series). The only consign was to use at least several C++ functions. We had a minimal list of the functions and structure we had to use, and could add any specific function we would have liked. 
Elegant solutions are appealing to some students due to their brevity, which can be seen as clever or almost getting away with something.  That may motivate some, especially the lazy ones.  Others may just appreciate how elegant the solution is for it's open merit.
We had two different delivery of the project, first one was for the teacher to point out some place where we could have coded better (using more C++ built in function) and the second was for the final delivery with proper coding. 
I realize that's almost the opposite point than the one you're driving at (i.e. getting them to use the more advanced constructs) but show in your code that they exist for a reason. If you can replace 50 lines of tedious, error-prone buffer manipulation with a built-in collection and an iterator/forEach that takes less than 10, believe me the smarter ones will notice. And when they collaborate with their peers on group projects peer pressure will help with the slower ones.
I have found online interview prep sites have done the best at nudging me to use constructs I would have otherwise ignored.  Maybe sell them on the idea of interview prep? Can't use an Array for all of those, just flat won't work and that is a time you definitely want something to work!
For example I had an assignment where I spent a good chunk of time implementing my own (very flawed) version of a HashMap.  I have some the same thing for a TreeSet as well. 
The same approach can be used to step-up to any progression you choose. Under the hood in any chosen language the new tool might not be implemented using the old one. At least not now. Still, that's how they came to be created in the first place - refinement on a common problem and its solution creates the shiny new practice which becomes a tool. That's how we got structured programming to begin with.
Borrowing from the world of sales, show the problem first, and the solution second. To progress from a bounded for towards a foreach, as an example, use the bounded version in a manner already natural to them that is possible, but problematic, against a collection that can be foreach-ed. Legitimately work out the checks and error traps and actually make it work. Once they've experience doing it that way, then you can present the "package" where someone did all that work, and more, when they created the foreach. All the traps, special conditions, etc., are handled, and all the work has been done, and debugged, for them.
Now that I'm under the tar and feathers, I'll explain. People like to find the easiest way, not the best way. Earlier postings reveal that you're in the teen-age world with your students, and they are no exception, if not the rule, to that thinking. Knowing that your students will have that natural preference for easy, use it as the motivation. "Quality is job one" makes a good slogan for a company, but isn't so good for motivation of students.
Honestly this was a very challenging way of giving us a project, every body get deeply into it and we ended up with very pretty and satisfactory programs. 
I think some students will stick with Array and ArrayList until they are basically forced to not use them.  No matter how clever or elegant they could potentially be.  Fostering a culture that embraces failure may help overcome that.