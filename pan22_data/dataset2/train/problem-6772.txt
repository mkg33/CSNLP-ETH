However, I've found out that this doesn't seem to be the case. For instance, in this docker-compose file, there's only 1 service with the VIRTUAL_HOST specified and that is the "web" service. And when I tested the system that uses this docker-compose file and checked Wireshark, I noticed that Nginx manages to communicate with the "jobs" service, despite it not having the VIRTUAL_HOST variable. How is this possible?
Here, Nginx running on your system would forward requests to a Docker container that exposes port 3000. Depending on how you set this up, you can of course proxy to multiple containers at the same time.
When using Nginx outside a Docker environment, you'd configure it to listen to a particular hostname, then forward the requests coming in to the port that is exposed by a running Docker container. For example, your server block could look like this:
That means, instead of explicitly specifying an IP address and port (like 3000 above), you you can instead directly link the nginx-proxy container to the application container. For more, read this README.
The other variant is running Nginx inside a Docker environment, typically within Docker Compose, such that Nginx knows about the presence of other Docker containers, which it infers from the VIRTUAL_HOST variable. As mentioned in the second link you added:
In almost every Nginx related webpage I've visited, it says that if a docker container is to be reachable from the Nginx reverse proxy, then it requires the VIRTUAL_HOST environment variable.
First of all, there is no concept of "virtual hosts" in Nginx. These are called "server" blocks, as you can specify different servers listening on different hostnames. The VIRTURAL_HOST environment variable is a Docker-specific conceptâ€”actually, it's only part of the nginx-proxy Docker service.