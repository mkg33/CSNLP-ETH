So it basically does a background check for the object you right clicked on and ran that blocks code.
It's been a while since I have looked at the minecraft source code but I think the block extended a container handler. Whenever you right clicked it will search if the right click happened on the block and if it had a functionality it will run that code.
Not exactly what vanilla does, but close enough. Vanilla essentially says "hey, open the Chest UI" and the server goes "cool, I know what bits I need (player, world, and position) and I also need to send a packet to that player's client and then the client will do what it needs to." Forge adds a similar method for mod code that includes what mod is making the call so Forge knows where to find the right classes to invoke.
For blocks like the chest, there are two additional classes involved: a Container class and a GuiContainer class (thought that name is a bit misleading as the TE may not actually store items). The container holds information about the inventory of the block (TE) and one deals with actually displaying that information to the player. As such there are two instances of the Container present: one on the server (to track changes coming from the client and apply them to the TE) and one on the client (in order to know how to display the TE's data and send any changes to the server). How these classes work is incredibly complicated and I don't even know all of it. Even some of the functions like "player shift-clicks an item stack" is a convoluted mess that I don't fully understand. I just know that it's needed and that those 60 lines work correctly (and don't know why it isn't in the vanilla parent class, but instead implanted new in each of the Container subclasses that deals with inventories).
From here we have everything we need: as Mark said, blocks do a sort of "background check" when their functions are run (bullet 2) although what that logic is varies from block to block. For blocks like Chests (Crafting Table, Hoppers, Enchanting Table and so on) when they are right clicked the code says, "Hey, we need to open a UI" and that's all that's in the block code. Essentially:
I guess normal blocks are ids in simple array, but how does it store and references blocks with special behaviour?
The hidden underlying background code that gets called some were along the way is world.getTileEntity(world, pos) and this is what converts from a "location in the world" to "that specific tile entity that is stored at that location." Blocks are stored in a massive array-of-arrays-of-arrays-of-arrays of integers (exact implementation varies by Minecraft version), which is why worlds can be so huge without actually taking up that much ram/hard drive space. TileEntities by contrast are stored in a hashtable (for each chunk) mapping position to TE instance as relatively few block positions contain a TE (and things go really really bad when they do! I've done it by accident).
So when a Block (a singleton) has a method called that needs to interact with the extended data held in a TE, that block can get that TE from the world and position parameters it gets from its own function call. If a UI is involved, then the player parameter comes into play, and from there network communication gets triggered in order to display the GUI on the client.
When the chunk gets loaded or the block placed the id of the block maps to a class that knows whether it needs that special data and will load and parse it.
There is a separate "TileEntity" list per chunk which store the data for blocks that don't have enough with the id+metadata that is available for all blocks in the chunk.
And that should give you at least a broad understanding of how it works in general and how incomplete even my answer is.