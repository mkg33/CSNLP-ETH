Also remember that this table is a running year.  That means that when the column was added presumably it wasn't filled in for any of the old rows.  As the year goes by and old records are dropped off and new records come in a higher and higher percentage of the rows will have that column filled.  Not to mention the possibility of additional information being added over time.  (New comments, additional requirements when putting data in the column, whatever).  This means that the table will grow over time, but should stabilize somewhat.
Note how we are given the number of rows, the total size of the table, how much is used for data and how much for the index.  And in this particular case most importantly how much is unused.
There is a memory leak when dealing with heaps (no clustered index).  Multiple deletes/updates causes space to be "lost".  It can easily be fixed by either adding a clustered index or rebuilding the table.
I've dealt with this for years.  Deleted data from LOB data types isn't always cleaned up.  SQL2008 and earlier never reclaimed the space in my experience.  Was supposed to be fixed in SQL2008 R2, but I found it was partially fixed.  Two fixes for it; 1 - Defrag using 'reorganize' (Rebuild isn't suppose to reclaim the space), or perform a database shrink.
Every table is going to have some unused space, but if you start seeing that number climb then that would be a warning sign.  I've never seen it happen on a non-heap but of course I haven't seen everything either.
However in this case the table is stated as having a clustered index and the same problems don't apply.  Using Occam's Razor I'm going to guess that this is because of the varchar(max) column that was added.  Remember that when you add a varchar column very little space is added to each row until data is actually added to the column.  So in this case my guess is that as the varchar(max) column has been filled in the table size has grown.