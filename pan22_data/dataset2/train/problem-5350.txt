In theory, I would expect both to always end up with the same results, as there are no external factors to the client influencing his position. In practice, though, I think I understand the problem.
This sort of technique is used in conjunction with correction and interpolation in order to make the game feel responsive on the local client and look smooth for remote clients.
The client needs to extend from just sending "I jumped" messages to sending "I jumped from X,Y at time T" messages.  The server then checks that the location is within close proximity to what it thinks the player was at at time T (which you can limit to a reasonably small time in the past) to protect against cheating, then simulate the jump from the position the client sent.  The server only corrects the client when it is far out of whack (usually due to lag or the like).
Right now, I only want to have a single player synced with the server. Theoretically, I assumed a player by himself with client-side prediction would not require server corrections, since there are no external factors that influence his movement. Therefore, my prototype currently only has one player synced with a server without server corrections being sent.
I am currently working on a rather simple multiplayer platformer. I read quite a bit of articles on the techniques used to hide latency, but I still fail to get my head around certain of the concepts. I find the topic very interesting and like to try ideas by myself, but I think asking gamedev stackexchange will be more efficient for my question. I will try my best to describe my current situation and what question arose along the way.
This long context finally leads to my question (thank you for reading this far): Is it normal to require server corrections even when there is only one player synced with the server, or should I use certain techniques to avoid desynchronization on time-sensitive situations?
Since jumping around an obstacle like that is very dependant on the timing of the player, small variations of when the velocity is applied to the position will have repercutions on the outcome (e.g. the client could move away just in time to avoid a collision with the obstacle, while the server would do it as it receives the whole action package later on and stay stuck on the obstacle for a small amount of time, changing the final result). The difference between how the client and server handle it is mainly that the client does all of its actions as they happen, while the server does them all in bulks as it receives them.
I am just starting out in the world of game networking, so please feel free to correct/criticize/insult any of the concepts above or give ideas/resources that could help me along my journey in the Wonderful World of Networking. Pardon me if I could have found my answer elsewhere, I have failed at that.
However, I'm getting sync errors after doing time sensitive movements, such as jumping and moving close to an isolated obstacle:
I'm skipping a few specific details about the physics and other sections because I feel they are not required for the question, but feel free to let me know if they would be relevant to the question.
If you are familiar with game networking, I think you may skip the context sections, though I may have done something wrong along the way as well.
In such cases, you may be better off letting the client be slightly authoritative.  For such precise controls you're extremely unlikely to get good behavior even with really advanced correction and prediction.
Please ignore the prototype graphics. White rectangle = player, Red rectangles = obstacles, Blue = background
The current system works fine under simple circumstances, and I was happily surprised to see that it gave very similar results with simple horizontal movements(the inaccuracies are due to floating point precision errors, I believe):