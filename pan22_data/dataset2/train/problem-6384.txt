The second issue is that you're creating a single, global SqlConnection object, which is generally considered a bad practice. Instead, create a new connection for each query and dispose of it immediately after usage. Connection pooling will keep the actual network connection alive for performance gains.
How about creating a(n abstract) UserMenu superclass that your AdminMenu, PlannerMenu and OperatorMenu inherit from, and creating a defaultMenu as well (maybe containg a text that urges the user to contact you to assign a role)?
This shows two issues. One is that the connection string is hardcoded into the application. It's a good practice to store it externally, so that any DB changee doesn't require a recompilation. I would suggest for example reading it in the constructor or Load event (from a file, configuration setting or something else):
This is fine, but when you detect an error you should exit the method with a return. Right now, it shows all the errors and can in some cases algo create the user anyway. As an alternative, you can run all the validations and show all the messages together, then exit the method.
Here, the parameter name must be "@Name" instead of "[Name]", which is the column name actually. This probably will cause the query to fail.
And nothing else. This has the problem that, if the login is incorrect (wrong user or password) nothing at all happens, the user is not notified of failure, just presses a button and nothing changes. At the very least, I think you should show a message to the user:
Another problem is the usage of AddWithValue, which is a bad practice. Instead explicitly declare the data type according to the types in the database.
You have three nearly identical pieces of code, inside a switch-statement. That seems to be a code-smell. Apart from that, I'm missing a default case. What happens if a user logs in before you have assigned a role? He gets an empty screen, or an ugly error message?
Instead, rely on the database to perform the validation. Add an UNIQUE constraint. Just insert the user directly, and catch the possible constraint violation to know if the user is already there. This solves both problems:
If you ever want to add a role, you just create the appropriate menu and add a one-line extra case to the switch in your UserMenu class.
The last problem would be, what happens after a correct login? Here I have my doubts, normally I would just login the new user into the system, in the same way that after a correct login, but here we have the role. What role would be the default? If there is one, just assign it when creating the user and login according to it. If not, you can't use the user until a role is assigned, in which case returning to the login form as you're doing seems appropriate.
When the login is successful you call this.Hide() to get rid of the login form. Instead, I suggest to use this.Close(), so that the form is removed from the system and its resources are freed. Hiding it just removes from the screen, but the window is otherwise alive under the hood.
It is very important to keep a handle on resources like Sql Connections to ensure they are closed and cleaned up. 
That's why in the previous code block I've just recorded the connection string instead of creating the connection already.
To validate if the user exist, you run a query asking for it, then insert. I think this is a bad practice, because it does two roundtrips to the server and has a race condition (the user can be inserted after the SELECT but before the INSERT).