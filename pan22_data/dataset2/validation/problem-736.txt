I'd rethink things a bit. At any point the state contains (among other things) the PC's target location and the PC's target item.
If the player interrupts the action by clicking elsewhere, the old actions for that character would be removed (or you could block the user from performing more actions until the current one has finished).
Then your game loop will include a move() which checks whether the PC can move towards the target location and if so does, and an interact() which interacts with objects near the PC. Among the interactions are items checking "Am I the target item and within a certain distance of the PC?" If so, they call a pick-me-up routine.
In your walkToAndPickUp example, I would enqueue an action object containing the character and the target location. Each frame I would move the character closer to the target location. On the frame that the location is reached, pick up the item and finish the action by removing it from the list.
Look at animation systems for inspiration. Don't spawn a thread for every item that needs animating! Consider what happens if the user clicks on a different item while your character is still moving towards another item. Then you'll have two threads simultaneously trying to change the same object.
All characters, NPCs, projectiles, basically anything in the game, should use this system to update and animate their actions.
To make things simpler, you can compose complex actions out of primitive actions, using an action sequence object. For example, you could make your first example by combining a walkTo action and a pickUp action. Your other example could be combining a wait action followed by an attack action. Then you can easily make new actions, like walkToThenAttack or waitThenWalkTo, without duplicating lots of code.
Instead, put actions in a list. Each frame you update each action in the list. When an action is finished or cancelled remove it from the list.