Keep in mind that AI/effects that happen on a boundary between regions.  You may need to save those updates as a "resolve all boundary" update loop. Since you want each region to interact with another you will have to play around with the most appropriate way to propagate effects from one region to another.
Each of those calls generates a new object, even if that object is identical to a million others already in the game.
Additionally, your code will be a fair bit faster, since iterating over the List will be much quicker as you're no longer suffering indirection overhead and poor cache utilization you get when you allocate 5000x5000 individual objects spread all over memory.
Now, for all area outside of the player region will be called non-visible space.  Since the player can't see this area, updates don't need to be instant, but as per the requirements, we do need to keep updating this region.  Since we can't fit all of it into memory, the usual trick is to break it up into chunks and load what you need.  So we break the rest of the 90x90 region into equal sized chunks for convenient loading.  These chunks are then rotated into a single (or multiple if you have mutliple threads) buffer.  The trick here is to now fully/partially simulate this region up to the current game tick so as to keep the region relevant to changing AI/physics. Once the region is simulated, just write (compress as needed) the region back to disk.
For simplicity, I assume a 100x100 grid.  Assume the player can reasonably see an area of 10x10.  Since this area easily fits into memory we will fully simulate this region, which I will call the player region.
You could also watch the player behavior.  If they are moving close to an edge region, maybe you will alter now often those other regions get updated to avoid having the player wait while the game simulates up to the current tick.
This is a difficult problem because you have a large world which you want to update and have AI running around, regardless of where the player is.  Since you need to lower memory while keeping the above true you will have to either raise your memory requirement, or cut some corners.  I will explain how to cut those corners.
Use a struct.  It allows you to store any custom fields you want, has no additional object space overhead, and is allocated in-place in the List's memory buffer so it has no additional memory manager overhead.
However, this approach is only necessary because you have a very computationally difficult requirement of a large area that always needs to be updated with potentially complex AI/effects.  I would look into how important that requirement is for core-gameplay and reevaluate what a more realistic requirement would be. As this approach opens a lots of cans of worms.
Note that the other suggestions you received to spatially subdivide your world and perform logic level-of-detail filtering are also good, and you should do that in addition to converting MapCell to a struct.
Classes are allocate on the heap.  Every MapCell hence has overhead associate with memory management (bookkeeping of the allocations, padding, etc.).  There's also the overhead of all the internal data that every object instance has like the "vtable" handle (which isn't much but it adds up) and you don't need the featurs those provide.
What you can use to alleviate the problem is called the "Flyweight Pattern." In this case, your MapCell instances become immutable (similar to, for example, String instances), so you'll have to store the changeable state - like entities - in some other data structure. Similarly, if you want to define some behaviour in your MapCell instances, only the behaviour which is common to all of them can be defined as its class methods.
Store the tilemap with byte arrays. If byte is not enough for you, use more byte arrays or short/int arrays. Each object has such a big memory overhead in C# (and Java) that you should use primitive arrays for large sizes. Store the objects in other data structures, not per tile.
An example using a static Factory and a private constructor; this makes your MapCell class essentially sealed, aside from hard-coded exceptions.
An alternative, which allows for extending the MapCell class with your own and creating new terrain types at runtime (for example from configuration files) would have them register themselves in their constructor. You use them essentially the same way as above, though MapCell.ForTerrain(...) can now return null, which you have to deal with somehow (assuming that tile is empty, creating a new tile terrain type on the fly and so on).
This works great so long as the player doesn't move to those regions.  What if he does? A  hierarchical approach may be needed.  Instead, we want to update non-visible regions close to the player more often than those which are further away.  You may have to play with this a bit, but maybe we choose to update a close non-visible region two or three times for every further away non-visible region.  This way if the player moves into a previously non-visible region, little extra work is needed to bring that region up to sync.