In this case, you could have a method countPrimesUnder that would iterate over the data structure and count the primes.  
The only even prime is 2.  If we eliminate that first, then we can check for numbers less than 2 or divisible by 2 at the same time.  
If you can multiply two factors to get a product, at least one of the factors must be less than or equal to the square root of the number.  You can see this by trying to multiply two numbers greater than the square root together.  If everything is positive, the product will be greater than the target number.  So once we've checked the square root, we don't need to keep going.  If there was a pair, we'd already have found half of it.  
Putting comments on separate lines makes it easier to see that they exist when quickly scanning the code.  And in this case, it avoids unnecessary scrolling.  
We could tweak the isPrime method a little more and likely make it a little faster.  However, we have other options that don't require isPrime at all.  
If you know the maximum number that you have to check and need to check many numbers, consider using the Sieve of Eratosthenes or similar.  That's the most efficient way to find all the primes in a range.  So you'd first find all the primes and then just query a data structure thereafter.  
We don't need the prim variable, as we can return false as soon as we find a reason.  If we get to the end, we can return true.  This has the same effect as your code with less scaffolding.  