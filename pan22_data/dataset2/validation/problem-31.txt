Method 1 (Look-ups) would be that the DrawComponent knows it needs to check state before drawing. It calls "GetComponentWithType(Type t)" to get the StateComponent (or more likely an IState interface), checks the state, then draws.  Ditto position, rotation, etc.
A lot of people are still getting used to component systems, and there can be debate on the good or bad ways of doing this. But why not use a reference to PlayerEntity?
Instead of having a reference to the Drawable in the Entity, I'd have a reference to the Entity in the Drawable. I'd also make the Drawables observe the Entity so that when the Entity changes, the Drawable is notified and can pull any relevant changes.
If the PlayerEntity has state that controls entirely how it is drawn, pass the PlayerEntity state into the SpriteDrawables draw function. That does mean that there's a coupling between PlayerEntity state and SpriteDrawable. Note that the PlayerEntity state could be a separate class (e.g. PlayerEntityState). If don't want this coupling, or you want to control arbitrarily how it is drawn depending on other state in your game then have the object that aggregates PlayerEntity directly aggregate the  Drawable so you can control it there.
I would suggest giving all components a reference to their parent Entity. Your player entity does have a base class, right? And that class should also have a method for adding components, where it sets the component.Parent = this. The property setter for the component can handle all the subscriptions. If you need, you can have a method on the entity that fetches any desired component. Myself, I used a generic method and stored a dictionary from types to components:
I suggest you have a look at the Mediator pattern and messaging. This is a nice way to avoid coupling.
One thing is for sure: whatever is responsible it must know about the specific type of Drawable it is operating on, you can't change the texture without knowing it has a texture. You did this in CreatePlayerEntity, because at that point the type of drawable is known. If you want to do it elsewhere  then you may need to rethink your design.
I think I've mostly come into agreement with Gerold Meisinger though, and have been looking into F# as an alternative.  Because I think a post he made on StackOverflow is very accurate: the more componentized I've tried to make the design, the smaller and more function-like each component becomes until I've just got a messy bag of states and chained functions trying to pass the states around.
According to Gerold Meisinger in a blog post, there are basically two ways to address the problem of inter-component communication: looking it up on the parent, and message/event passing.  A third would be reference holding, which is what you were debating.  My own attempts to implement such a system basically showed the same thing.  
I've been researching component-based designs pretty heavily myself, and while I'm still in some pretty heavy confusion, I think I can offer some thoughts on this.
But that is to say that there's a spectrum: at present you've only got 1 entity containing some state and one component.  I'd probably opt to have the drawable component receive packets of "DrawableInfo" through events.  But just keep an eye on the complexity or pretty soon you too will be wondering if switching to a functional language might not be better.
The basic foundation is that you have an Entity class whose only job is to hold parts and manage them.  If you wanted to change the animation (say the player's state changed) then you'd have a StateComponent or maybe a PlayerState component, and it would need to communicate "My state has changed" to any other parts that need to know that.
You could also use the parent Entity as a kind of message board, holding a log of posted messages that each component checks for interesting messages. This is a slight optimization since it makes both the sender and the receiver "lazy."  Each sender only posts one message (to the host) and each receiver only asks for messages when it needs them to update, and then only gets the latest message, ignoring any irrelevant in-between states.
DyingComponent -> {send message via Entity/Mediator} -> DrawableComponent {receive message and switch to death animation}.
You'll note that each method has complexities and problems that would have to be worked around.  If you stick with OOP though, I would say that's just part of what you have to pay for flexibility though.  I was very confused about the whole thing until I realized that the Factory pattern is essential because the factory is the only thing that actually knows how to hook it all up in the first place.
Method 3 (Reference) is an optimization of method 1.  Instead of asking for a reference to the component, it just has one already.  Either the factory gave it one, or it stored the reference after it asked for it the first time.
eg. Your entity changes action, so it notifies all observers that something has changed. The Drawable calls entity.getAction() to find out what action is underway, and sets its own animation accordingly.
Method 2 (Events) would be that the StateComponent emits a message when it changes, and any subscribers to that event get alerted.  Typically the factory would wire that up, adding a DrawComponent, then setting it to have message handlers to watch StateComponent for changes.  