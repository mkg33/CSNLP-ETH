Please notice that I did not select a religious choice for you in the question about handling the middle initial and that I did NOT attempt to address the general case of having a blank slate designing a model with columns unlikely to need nulls.
If your perspective is "from relational theory", as you claim in that comment, then the answer is simple : null is not a value, and a thing that contains a null is not a relation, and a database that can contain a null is not a relational database.  From the perspective of relational theory, there just is no "best" choice, because there is no choice at all.
IMO the decision to make your attribute a new table has more to do with normalisation design than NULLs.
1 is a more traditional and natural representation IMO, however 2 has the benefit that inner joins are guaranteed, and also can ease code which uses the DB as you no longer need to check for nulls (although undoubtedly you will need business logic to check for your 'dummy value' in places).
I don't see any 'relation theory' why you would make a table to store an attribute, just because that attribute can be null.
Now moving on to a particular implementation case, perhaps involving an entity with more than 254 columns and using an Oracle database, it is likely that overall performance will be improved if the columns are ordered by likelihood of having a non-null value, breaking ties by perhaps the columns of your primary key in order and then it is largely up to you although you might put index component columns leftish just because it is easier to grok when considering a narrow bit of a wide listing. Following on, if many uses of the table don't inquire on the value of the likely to be null columns and the ones beyond column 254 end up in another table with a one-for-one key, you can usually devise a physical structure and access plan that ends up being easy to use, sensible and fast.
Next, the question is not clear about whether you have a blank slate for relational design or not, and whether you are targeting a particular RDBMS or not.
(Note that this does not mean that at the physical (implementation) level, there could not be constructs such as null.  But these constructs should not be exposed to the database user, because the DBMS is precisely supposed to insulate its users from implementation stuff, leaving him to interact with the DBMS exclusively at the logical level, which cannot involve nulls.)
If you have a wide existing table containing lots of frequently null columns, it is likely you can make it more efficient if you re-arrange the physical table so that most of the nulls are contiguous to the right hand side of the table. If the table is over 254 columns in certain RDBMSes, you may profit from breaking the table into two pieces such that the overflow is less often referenced and when you need the whole it is via a view sliciing the two physical tables together one-for-one.
As for null values, that is a religious war which side of you are on you can most succinctly answer by reflecting on what your implementation choice is if you want to have an option to store someone's middle initial (and you know that some folks don't have a middle initial).