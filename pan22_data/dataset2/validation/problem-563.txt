I can think of a couple ways to break the explicit dependency between these two classes, but I think this one is the least complex and still achieves good decoupling:
I agree, it does seem a little gross for each state to hold a reference to the Game just so the state can request a state change. But, in a way it makes sense: the Game class is acting as the state manager -- it keeps track of the current state and it knows how to change states.
Bonus is that if you later change the state implementation, an example would be to add hierarchical states, then all the changes are internal to the state classes and not spread all over outside files.
I'm creating a game engine which utilizes a state machine following this GameDevGeek tutorial.  My concern is the use of circular dependency which I've heard is bad.  The game engine has the game state but the game state needs access to the game engine for a state to be able to transition to a new state.  Is this a proper way of doing it?  Namely my implementation, includes, and forward declarations.  On another note, why does syntax highlighting randomly turn off after two files have #included each other?  Here's my code:
Any GameState::changeState calls that used to pass an instance of Game will still work, since Game would be a sub-class of IStateChanger; so why is this any better if we're still passing the Game instance around?
Add static members and methods to the class GameState to handle the responsibilities that you've forced into the main Game class.
Down in the GameState.cpp source file you are invoking functions of Game, so you need the signature there. Simply add #include "Game.h" heere and you should be good to go.
Basically, this won't change your current code that much, except instead of the GameState referring to an object of type Game, it would refer to an interface/abstract class type that declares a function for changing state. So something like this:
Each instance of GameState will then have access to one, shared state environment like they do now, and Game doesn't have to carry around the baggage.
Your issue can be solved by moving some includes about. The inclusion of file containing the declaration of another class is only needed when specific details are required (which functions are publicly available, how much space should I reserve for a field of that type, etc.). 
Since your GameState header only ever uses pointers (references might be better suited here so others don't mistake it for an array and whatnot) to a Game object, you can get away with a forward declaration there. This is because the size of a pointer and reference is independent of the size of the data they point to; the compiler only needs to know about the existance of the class/struct at this moment.