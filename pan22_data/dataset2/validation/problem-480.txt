In your case I can also imagine that you process the message already in the on_message_received(...) method without needing a buffer and the get_message_noblock(...) method. You can stop the notifier thread with 
Notifier is a class in can package. It starts a thread that listens for can messages. If a can message is received every Listener (in my case only one Listener, the FilteredBufferedReader) is informed about the message and the method 'on_message_received(self, msg)' is called with the received message. In my example I check, if the msg has a specified arbitration ID, and if so, I put the message into a buffer. With 'msg = fbr.get_message_noblock()' I can take a message out of the buffer for further use. 
Use the python-can module with pip3 install python-can, documentation is listed here https://python-can.readthedocs.io/en/stable/installation.html
But be careful, this are python relevant methods, if it is necessary for you, to have fully realtime connection to the bus, i think itÂ´s better to develop the can modules in C/C++. There are a lot of examples on github, like the candump, which is programmed in c
You can start a BufferedReader that calls a message everytime you receive a message. Or you adapt the BufferedReader class in a way that it filters for the message(s) you want.
you write your own socketcan Client with the python-can package. I prefer this method, because you can send, receive and filter CAN message depending on your Project.
Look at the socketcan_native.py and the socketcan_constants.py and the message.py which is located at: 