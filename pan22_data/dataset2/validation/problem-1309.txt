Additionally, you might get partition elimination but your query patterns would need to fit a very specific and repeatable pattern within your system - the partitioning key and clustering key and any unique keys become interconnected and very important. If this balance isn't treated acknowledged and designed around, you end up with performance nightmares.
As far as performance is concerned, you can change lock escalation to AUTO (default is TABLE) like so:
So, at what point should a table be partitioned? That depends on your query workload, the profile of your data, but most importantly, it depends on which of the management features of partitioning you absolutely must leverage. Partitioning isn't for query performance, it's primarily for data management and administration.
As noted in the linked article, the primary benefit of partitioning is that you can quickly move data by using partition switching. For example, you can archive "cooler" data to slower storage and keep your "hot" data on fast storage. At regularly-scheduled intervals, you can quickly archive data by rolling it to archive partition(s) without having to go through the process of waiting for an ETL to perform the transfer. As noted in one of the early comments to your question, though, this will take some careful thought and planning before implementing it. Also, depending on the SQL Server edition that you use (Enterprise), you can leverage data compression to compress individual partitions. 
I'm going to take a different approach and note that partitioning (in SQL Server) is primarily a data management feature with query performance being a possible secondary outcome, depending on how you manage it.1 
With the advent of SQL Server 2014, you can also take advantage of incremental statistics which is very handy if you proactively monitor and update/create statitsics on large tables. 