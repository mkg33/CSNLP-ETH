One idea to make this scale you can make a bitmap of the same resolution as the user is drawing the polygon in and in each pixel store the ID of the event that was rendered on that pixel (or a list of events if you have collisions). Then simply raster the polygon and find all events inside the polygon. However as you still need to go through all the points of the data set and then raster the polygon the run time is now \$O(n + A)\$ where \$A\$ is the area of the polygon. 
Then when the user draws a gate, compute the bounding box of the polygon and then construct a quadtree for the polygon where each node is either "inside" or "outside" going down to pixel level. 
I don't do JS so I can't claim I understand fully what it is you do. However I gather that you are having performance problems with determining which points are in the gate polygon.
If I understood correctly you are checking each point against the polygon which gives you \$O(np)\$ run time where \$n\$ is the number of points and \$p\$ is the number of corners on the polygon. 
This way of doing it allows your users to scale their datasets massively as the only dependence on \$n\$  is in \$log(n)\$ which grows very slowly. You can consider \$k\$ as a design parameter that is constant so you can remove it from the above expression if you want. Then the circumference of the gate is what dominates the run time (note, not the area but the circumference).
Then start at the root of the point quadtree, test each child if it intersects the bounding box of the gate, if not you can skip that child. Next you test the child against the gate quadtree. Is the child contained in a node that is "outside"? Skip the child and it's children. Is the child contained in a node that is "inside" mark all the children as being in the gate and continue without recursing. If the child isn't contained in either an outside or inside node in the gate quadtree, recurse into the children of the child and repeat until you reach a leaf node in the point quadtree. If the leaf is still not strictly contained in an "inside" or "outside" of node in the gate quadtree, test each of the \$k\$ points against the gate quadtree. 
Lets arrange the points in the data set into a quadtree in a pre-processing step when the user uploads, this is \$O(n\log(n))\$ work.
Computing the run time is a bit hard but lets try... assume that along each pixel of the circumference of the gate, you have to test all of the \$k\$ points in the leaf that covers that bit of the periphery. This bit is \$O(kc)\$ where \$c\$ is the circumference of the gate (note \$c<A\$  typically). To get down to each of the leafs we need to traverse \$O(log(n))\$ nodes in the point quadtree and each of those needs to be tested against \$O(log(A))\$ nodes of the gate quadtree. 