Now S can be anything. It could be an X coordinate, it could be a Y coordinate, it could be the distance between the objects, it could be an angle.
I'll call the path of the target over time the function S(t) where S is the position and t is the current time and the approximation to the path is A(f) and f is the date in the future one is approximating.
One way to do dynamic path finding is have the entity predict where the target is going and go there.
Calculate where B will be in 'T' time (if B continues at the same speed / angle) and go there instead.
If the terrain is reasonably open and the target isn't too far from the pursuer, then you could use the intercept steering behavior. Essentially, you take the position and velocity of the target to calculate a position out in front of the target that isn't too far, and not too close, and you steer the pursuer towards that point (calculated each at regular intervals). 
I am working on a 2D RTS like game, basic A* works perfectly for moving a unit from point A to point B.
Also there's probable better methods of predicting the future path of an object so I'd look around a bit.
I know this can be rephrased in terms of change in time which is probably more convenient for a game.
To do better than that is very difficult. Unless you actually have knowledge about the unwavering path of the target, you're heading into the land of quite hard AI because you'll have AI's second guessing or simulating the target behaviour in order to guess where they will be and path towards that. This kind of AI is a real-time AB-game from game theory, an area that's not standard in any 3D game AI toolkit.
This is not the perfect way as the distance changes but much simpler than making a perfect solution and much better than just trying to get to 'B'.
But now I facing the continuous path-finding problem, like A attack a moving object B, call A* at each frame once Object B's position changed seems inefficient.
One method I have seen work was to assume the target continues moving in the same direction and change the goal position as you run through your path finding algorithm. This does mean you have to hold two metrics in your A* nodes (cost and time as opposed to just cost).