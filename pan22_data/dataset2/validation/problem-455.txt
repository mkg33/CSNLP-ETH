I got around this by intercepting the WM_QUIT (IIRC) message and sending a command to the thread to shut things down. The thread then informed the main window when it is time to actually close, after all cleanup had been completed.
And therein lies your problem: your "message loop thread" should be your "render loop thread". They should be the same thread.
Attempting to do rendering outside of the main thread is a recipe for disaster. Especially when it comes to closing the window.
I've run into something sort of similar, and the quick answer is that once windows starts processing the quit, you don't have a lot of time. Controls and resources start getting destroyed immediately, and it is entirely possible that by the time your thread gets around to referencing the resource, it's already extinct.
The render loop and windows message loop run on separate threads. The way the program exits is that after PostQuitMessage is called in WM_DESTROY the message loop thread signals the render loop thread to exit. As far as I can tell before the render loop thread can even process the signal it tries SwapBuffers and that fails.
My question, is there something about how Windows processes WM_DESTROY and WM_QUIT, in maybe DefWindowProc that causes various objects associated with rendering to go away even though I haven't explicitly deleted anything? And that would explain why the rendering thread is making bad calls at exit?
When the main thread signals the rendering thread to terminate, you can use a mutex and condition to wait for the rendering thread to exit before allowing the main thread to proceed. You need to make sure this is the first thing you do on shutdown - before you delete anything related to rendering.