The primary question I have is one of usage. By the name sparse_array, it sounds like you want to expose an interface that is similar to an array. Perhaps it needs dynamic sizing, or perhaps not, but in particular I expect to be able to iterate over its elements with code like this:
Today, I tried to create a really simple sparse_array container adapter. I did not provide all the STL-like functions, only the elementary ones as a proof of concept. I also trimmed the class from its copy constructor and all the unecessary things for this review actually. Here is the code:
It needs to be clear what the output from that would be. Would it include the default values in most indices? Or is this usage prohibited (perhaps due to that unclarity), as currently there are no iterator related methods? Maybe this is just part of what you intentionally excluded from the review, but it leaves so much unanswered, including things that probably come back to your proxy class, such as how *std::begin(sp) = 3 will work.
Do you think there are obvious design flaws in this code? I bet there are some in the proxy mechanism, and it would be great if you could hilight some of them.
The one definite gap I see has to do with operator&. Will you support code that looks like normal array-style addressing? Right now the following code will certainly not work correctly; should it fail to compile, or should it modify sp[5]?
What I tried to do is to have a sparse array whose number of elements is strictly equal to the number of elements that are different from default_value, hence the elements that are deleted when default_value is assigned to them. Here comes a small example: