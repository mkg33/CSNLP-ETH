No similar statement holds if i is congruent to 1 or 5 modulo 6.  So as long as you have checked for divisibility y 2 and 3 and you count up instead of down, you know that no new information can be revealed by is that are not congruent to 1 or 5 modulo 6.
where the increments continue alternating between +2 and +4.  Unroll your loop (once) to do both of these per pass.
For such small numbers, you are overwhelmingly more likely to find small factors by counting up from 2 in fewer steps than finding the largest factor counting down (which you will find before the largest prime factor, in general).  Consider that every factor greater than the square root has a cofactor less than the square root, so the density of factors is much lower among the integers greater than the square root.  You really should start at two and count up.  Every time you find a factor, since the number has no smaller factors, you know the factor you found was prime.  (This makes your IsPrime() superfluous.)  It's traditional to divide this prime out of your number and continue testing the same (and then larger) trial factors from the reduced number.  (You test the same prime again because one of its powers may divide the original number.)
Since you're now counting up, you can skip about one third of the candidate factors you would check in your current code.  Other that 2 and 3 all prime numbers are congruent to 1 and 5 modulo 6.  Consequently, you would test the list 
Of one wants to unroll a little more and skip about 20% of the remaining candidate factors, one tests 2, 3, and 5, and then only 