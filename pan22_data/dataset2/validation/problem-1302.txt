Side note: This is actually a veiled peak at RAII, or the concept that resource life times should be tied to object life times (over simplified, but yeah). It's probably a bit early at this point to go reading into that too much, but once you're deeper into C++ (perhaps when you find yourself becoming fairly comfortable with the object model), make sure you look it up at some point.
This has already been said before by someone else, but just to reiterate, don't use globals. Just don't. At least not until you come across your first situation where you truly cannot do anything else (and it's possible to go years in between those situations). To be a bit dramatic, globals go against pretty much every software design principle there is.
That's a lie. If close() fails, it sets the failbit but otherwise does nothing. It's completely possible that flushing out some cached stuff failed and the the full content of the file didn't make it to disk.
Your program can very easily eliminate globals by using local variables in main and passing parameters to functions as needed. I know in an example program this simple and small it doesn't seem like it really makes a difference (it might even seem more cumbersome), but it really is a habit you should get out of. In large or complex systems, globals can quickly turn into a a testability killer and become Petri dishes for weird, hard to find bugs.
You have basically no error checking. File opening, stream token extraction, and file closing can all fail. 
strings has no reason to be global, and it should be called line, especially since it's a single string, not a collection of them.
Or, better yet, there's no point to read the stream line by line just to output it line by line again. You can just copy the stream to std::cout with std::cout << inputFile.rdbuf();. (Note that this does have very slightly different semantics since it's a binary copy instead of a character stream.)
Functions should be responsible for one discrete responsibility, but this is broken in a few places. For example, read(): 1) prompts for user input, 2) opens a file, 3) copies the file to cout, 4) closes the file, 5) terminates the program.
inputFile should not be global. It's not necessary for it to global since every function that uses it immediately closes it. Even better, since you're not actually explicitly checking if the file closes successfully (and really, it'd be fairly overkill to do that unless you're making a very robust program), if you use a local variable, it will close itself automatically.
That's a lot of things for one function to be doing. Main should handle the exiting (since it's responsibility is to oversee the flow of the program execution), and instead of opening and closing a file, read should be passed an already open file.
(Note: immutable globals [usually called constants] don't have nearly as big of set of problems [though they still have their own set of problems]. If you actually heed my end-of-the-world-warning about globals, just know that you can chill out a bit towards constants as long as you're sure to be mindful of if/when they become determinant to the quality of the application.)
This is wrong. It will actually 'read' an extra line erroneously since eof() doesn't return true until an attempt has been made to read past the end of the stream. The idiomatic way to do this would be: