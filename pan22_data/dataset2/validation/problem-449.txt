SAC compared with partial evaluation: As Rob Simmons says above, dependencies in SAC need not be separated a priori into two categories (static and dynamic); moreover, even in the case that all data has the potential to change, assuming that the changes to this data are incremental (and that the underlying program enjoys "stability" across such changes), the SAC approach can still deliver significant time savings.
The important thing to note about SAC specializing a computation is that, after a change occurs, the computation itself is updated to reflect this (via a mechanism I mentioned above, called "change propagation").  This is in contrast to PE, where the specialization only occurs once, up front.  Hence, SAC is more "dynamic"/"online" (like FRP), whereas PE is (usually?) more of a offline process.  (Perhaps someone that knows more about run-time specialization of code can extend this comparison to PE when it occurs at run-time.)
Let me try to extend the description of SAC given above: Self-adjusting computation is a paradigm where computational decisions depend on data, which is assumed to change over time.  The computation itself produces more data, which may be consumed by other (self-adjusting) computation.  When any input data is changed, the technique provides a general-purpose mechanism by which the computation is updated to reflect the changes.  (When I say "computation", I mean a dynamic structure, like an execution trace, that reflects the operational steps used to produce the output from the input.) By updating the computation, the update mechanism also updates the output of the computation.  
[Disclaimer: I have very little knowledge of automatic differentiation. I have some passing knowledge of partial evaluation and FRP, but haven't used or researched either directly. I'm very familiar with self-adjusting computation; I do research in that area.]
As with FRP, SAC enjoys nice compositional reasoning: one can compose two functions and get the composition of their (self-adjusting or reactive) behavior.  There may be a subsumption relationship there, where some flavor of SAC perhaps subsumes some flavor of FRP, but that's a topic of future research.  It's certainly not obvious that this relationship exists between current approaches of SAC and FRP.
If I had to make them comparable, I might say something like "PE statically specializes programs based on a fixed part of the input, and SAC dynamically specializes a computation based on the prior input".
This is because SAC is largely a dynamic technique, unlike partial evaluation, which is largely a static (compilation-time) technique.  Because of these phasing differences, I do not think that it's useful to think of one subsuming the other.  They are just different (mostly orthogonal?) approaches.
I definitely agree with the decision tree laid out by Rob Simmons above; I also agree with his conclusion: they are all different, and probably not in some subsumption hierarchy.