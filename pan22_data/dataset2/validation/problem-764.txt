If you use an enum, how will you describe the other differences between a Robot and a Zombie? Will you have a variable to hold a reference to the graphics representation and another to hold a reference to the behaviour? If so, do you really need an enum and hard code all your enemies?
Your question shows lack of experience. Which is not a bad thing, because we've all been there and you're taking steps to improve your situation by asking around and trying stuff. Kudos on that!
Let's say we make a game. The game has items, enemies, allies, etc and there are multiple of them, like zombies and robots as enemies. Do you think it would be better to make one parent class called "Enemy" (and the corresponding cpp/hpp files) and making a class for each enemy (zombie or robot in this example) and making 2 files per enemy or would it be better to make an enumcalled "type" in the Enemy class and having all child objects in that one class?
Plan a bit more what you want from your game, with all the edge cases, then try to implement it with what you're most comfortable at first. Then take a look at what went wrong with the way you chose, and figure out a way to improve it for your next game. 
If you use a parent class and inheritance, what is so common to them now that there is the need for a parent class? And if you use that, and you turn out needing a friend Zombie, how will you hack your way to avoid code duplication and have your zombie act as a friend and as a zombie? And if you decide to have a hoover enemy Zombie, will it inherit from Enemy <- Zombie? If so, how many inheritance levels are you ready to have before you consider you're really entangled in your architecture?
And after you're done with your first implementation, you should take a look at the concepts of entity-component design. Maybe you don't need all of what's in there, but it could help you figure out ways to design your next game!
When programming, there is rarely a single best way to do something. It always depends on the situation, on the requirements and and the implementation. 