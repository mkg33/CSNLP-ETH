Part of the "teach OOP" problem is that OOP (and modularity, and top-down design, and variable-naming discipline, and consistent code layout, and...) is practically useful for large programs with a long life, and in the time allotted you write tiny throwaway programs.
On the other hand, if you are looking for a more practical use-case, then you can use lists. There is the Node, which in its simplest form is nothing more than a data encapsulation, and the List which implements the process of accessing the nodes. The List and Node can both be inherited as you expand from array-based lists to linked lists, and into doubly linked lists. Then you can switch to stacks and queues, maybe even moving into binary, and n-ary, trees.
With inheritance, we eliminate the need for all these ifs, and allow future programmers to add their own saving method:
I'm not sure why you don't like the person/employee/manager hierarchy; it is just an example for a whole class of object hierarchies which represent specializations of data with a common subset and are often stored in databases. Other examples would be non-human inventory (every physical item a company owns has a value and a location etc.), or financial assets (they all have some proof of ownership, a value, a date of acquisition etc.). 
BlockDiamondOre checks harvest and fortune, putting a different number of diamond items into the list, even determining how many based on the Random supplied. 
Now, if new developers want to add their own way of saving, they can write a new class the implements Saver, and just pass it to the SaveTheGame method.
1Well, except Minecraft Forge, who maintain the official unofficial mod API. But Forge is a special kind of magic that isn't important here
The chest let's the player store items in it. The furnace smelts some blocks into other blocks. Grass, when broken, drops a completely different block. Stone doesn't drop anything at all unless dug out with a pickaxe.
The same goes for items, some of which (like sticks) don't even have a derived class of their own because they do nothing special. They just exist and do everything any item can.
If you haven't, I suggest taking a few minutes to find some introductory "Lets Play" videos on YouTube first. 
Imagine you were making a super-awesome video game, and you needed to write a function that saves the game.
There are roughly 100 different methods in the block class to handle all of the possible functionality. Update ticks (crops), neighbor updates (observer, torches), interaction (doors, chest, furnace, crafting bench), whether or not a block has a tile entity (chest, furnace), and on and on and on. Most of them are blank and do nothing, entirely up to the derived class to add to, if it needs it.
I'm not as familiar with Python as I am with other languages, but I'm sure your students have played Minecraft.
This is why the are so many mods for Minecraft that add so many new things: no one1 has to implement anything special in order for everything to Just Work. 
Perhaps a way around that is reading (good!), hopefully modifying/extending, programs written in OOP style. Open source is a godsend...
If the students are still needing real "objects" to connect metally with the concept of object you could resort to using transportation as a system. Another user, G. Ann - SonarSource Team, gave a good break down you could follow in answer to another question.
What if youâ€™re writing code for other developers, and you want to allow them to add their very own ways of saving?
All blocks can be broken, picked up, placed, stacked, stored in chests, and crafted together. But not all blocks do just those things. 
If you are looking for something which can be implemented and played with in a class I have two suggestions: