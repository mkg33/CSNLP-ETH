This is a really general question, so you're probably only going to get overly-general answers until you post a new, more specific question.
Alpha-beta pruning is probably the most common search technique for most of the class of board games you're thinking of (at least as far as I know, but I'm admittedly not terribly familiar with AI). There's also Negascout and whatever this is (these last two links aren't that great, if you spend more time sifting through the Google search results you can probably find better since you presumably have a more detailed idea of what you're really looking for).
Most likely it will not be a small program. I would suggest to start from preparing a very general idea and a very basic principle how moves will be determined. Most likely it will appear not good enough at first and you will need to add more and more code to compensate bad decisions. At some point you will reach what you want. At least this is how I did it in my TicTacToe website. Try yourself - http://www.xo-play.com.
It's also going to differ pretty significantly depending on the style of game. For example, the algorithms used to implement Sudoku solvers differ from those used to solve tic-tac-toe, chess, or Go (game trees / alpha-beta pruning). And I'm not sure what kind of AI is necessary for Snake -- generally it tends to be mostly random.
I would suggest trying to write down how you yourself would think step-by-step when considering what move to make in a game. Once you define small-enough steps, all you need to do is put them into algorithm.
What you could do is do like the old computers did when solving board game: Have the computer play through the game many times (> a couple thousand, not so hard to do if you remove player input). Each time it gets to a decision, choose randomly, but have it mark that it made that decision. Then have it analyze based on the other games where that same exact decision was made, and compare the results of those to the ones where the opposite choice was made.