I'd like to use the ruby_block to determine the url for the remote_file to download from, so the order is important.
The first output we see is "in remote_file", as the puts statement is executed when Chef compiles the remote_file resource.  On the next line, we set the source parameter to the value of node.default['test']['foo'], which is apparently {}.  That's not a valid value for source, so the Chef run terminates at that point - before the code in the ruby_block ever runs.
Chef has a compile and a run phase. I assume that the code inside the ruby_block is not executed during compile phase, because it is inside the block statement (which would then be executed during the run phase). The puts inside the remote_file block however is at the "attribute level" inside the resource definition, which is really executed by chef (in fact, afaik the source node.default... is a function call).
Hopefully that helps you to understand the behaviour you're seeing, but we still have a problem to solve.
As with the first example, we don't expect anything to be printed while the ruby_block is compiled - the whole "block" is saved, and its contents won't run until that resource is converged.
As we've seen above, resources aren't "run", they're first "compiled" and then "converged".  With that in mind, what you need is for the the remote_file resource to use some data that is not known when it is compiled, but will be known when it is converged.  In other words, something like the "block" parameter in the ruby_block - a piece of code that doesn't run until later.  Something like this:
Also mention that I don't read the attribute through node.default[], but directly through node[]. Otherwise the attribute precedence feature of chef would not make sense. 
If it wasn't for my puts() statements I'd assume that these are getting run in the expected order, because the log says:
As StephenKing wrote in his response, the first thing to understand is that recipes are compiled (to produce a set of resources), and then resources are converged (to effect changes to your system).  These two phases are often interleaved - some of your resources might be converged before Chef has finished compiling all of your recipes.  Erik Hollensbe covers this in some detail in his post "The Chef Resource Run Queue".
Good question - both of your examples work the way that I would expect, but it isn't immediately obvious why.
Although you asked "how can I force the ruby_block to run first?", your comment to StephenKing suggests this isn't really what you want - if you really wanted that block to run first, you could put it directly into your recipe code.  Alternatively, you could use the .run_action() method to force the resource to be converged as soon as it is compiled - but you say that there are still more resources that need to converge before the ruby_block can be useful.
Fortunately, such a thing does exist - it's called Lazy Attribute Evaluation.  Using that feature, your second example would look like this: