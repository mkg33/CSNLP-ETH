2) If you find that your missile is at a right angle to your target, this could be the point where the lock 'breaks', and the missile just moves straight unless the target gets 'in front of' the missile again.
As the other answers by Martin and Nicol point out, you probably want to guide your missile not directly at the target, but in a way which will make it collide with the target later on. However, the method described by Martin is complicated and the one described by Nicol is inefficient.
Here is a worked example I implemented this morning, in my case for a player AI in a sports simulation game, where the player is trying to chase their opponent. The movement is governed by a standard 'kick-drift' model where accelerations are applied at the start of a timestep to update velocities and then objects drift at that velocity for the duration of the timestep.
I know this is an oldish question, but I think there is something that has been missed in the answers given so far. In the original question, the missile (or whatever) was told to accelerate towards the position of the target. Several answers pointed out that this was wrong, and you should accelerate towards where you think the target will be at some later time. This is better but still wrong.
LOS Rate can be easily derived by measuring the LOS vector (target position - missile position), and storing its variable.  The LOS vector from the new frame (LOS1) is subtracted by LOS vector from the old frame (LOS0) to generate a delta of LOS -- now you have a primitive LOS rotation rate.
N is the navigation constant -- in the real world, it is typically set between 3 to 5, but the actual workable figure in game is somewhat dependent upon the sampling rate at which you're deriving the LOS rate/delta.  Try a random number (start from 3) and increase up to 1500, 2000, etc until you see desired leading effect in game.  Note that higher the navigation constant, the faster the missile will react to LOS rate changes early on in the flight.  If your homing rocket simulation model is somewhat realistic, excessive navigation constant could overload your missile's aerodynamic capability, so you should use a balanced number based on trial and error.
However, I disagree with his solution to the problem.  Instead, I would program the missiles thusly:
What you really want to do is not accelerate towards the target but move towards the target. The way to think about this is to set your desired velocity pointed at the target (or a projection of the targets location) and then figure out what acceleration you could best apply (given whatever restrictions you have, i.e. a missile probably can't accelerated directly in reverse) to achieve your desired velocity (remembering that velocity is a vector).
The most simplest and advanced method to use for this in games (and real life) is Proportional Navigation.
A couple of simple options that have been found to be 'good enough' for games I've worked on in the past:
Under Proportional Navigation (PN), missile accelerates "N" times faster than the LOS Rotation Rate.  This will force the missile to lead the target until LOS Rotation Rate becomes zero -- that is, the missile and target appear frozen in state as sightline no longer changes -- they are now on collision course.  The variable "N" is known as Navigation Constant (a constant multiplier).
A simpler way - but still pretty efficient - to guide a missile is by adjusting its angle according to the angle change between the missile and the target. On every tick you calculate the angle from the missile to the target, and compare it with the angle from the previous tick. The difference is the exact difference you want to make on the missile's angle. So if the angle was 0.77 in one tick and 0.75 in the next, you want to adjust the missile's angle by -0.02. This method is simple, and as long as the target is "in front" of the missile, it's very efficient in terms of route chosen. It also applies to any number of dimensions, not just in 2d.
I would post the derivation of this, but I've found there is no math markup supported on this site. Boo! You will just have to trust that this is the optimal solution, bearing in my that I have no restrictions on the acceleration direction, which is not the case for a missile type object, so that would require some extra constraints.
As has been said you should aim the missile for where the target is expected to be when you get there rather than for where the target is right now.  This will stop MOST missiles from going into orbit but an orbit is still possible if the target evades just right.  This is a legitimate tactic used by aircraft pilots to dodge incoming missiles--since the missile is going much faster than you it will have a larger turning radius and a sharp jink at the right instant causes it to go on by.  (Although you could still be at risk from a proximity detonation.)
Since we are dealing with a missile that can still track and still has thrust you get an orbit situation if the target evades into one of the zones that FxIII's post talks about.
I also check the new speed against a player dependent max speed and cap it at that. In the case of a missile, car or something with a maximum turning rate (in degrees per tick) you could simply look at the current angle of motion versus the calculated ideal and if this change is greater than allowed, just change the angle by as much as possible towards the ideal.
Sightline, or Line of Sight (LOS) is imaginary line between missile and the target -- the vector between missile position and target position.  The rate of angular change of this LOS is the LOS Rotation Rate.
When LOS Rotation Rate becomes zero, then the sightline no longer changes -- the two objects are now on a collision course.  Think of yourself as chasing someone whilst playing football/soccer.  If you lead him in a way that his body looks "frozen" in your field of vision (sightline between you and him no longer change), you will collide with him as long as you maintain your running acceleration to keep his body appear frozen in your view.
If your end goal in your solution is simply to make sure your missile hits the target, then I am all for just Making it hit the target. Again, this will just depend on how the solution looks.
Code is in python, but should be readable with any language background. For simplicity, I assume each time step has a length of 1 and express the velocity and acceleration in appropriate units to reflect that.
Under the Constant Bearing Decreasing Range (CBDR) logic, when two objects (missile and target) are traveling in same direction without change in sightline between each other, they will collide.
if the missile has been thrusting at 90 degrees to it's line of motion for 360 degrees of movement you are in orbit.  Adjust the thrust to 120 degrees from the line of motion.  The missile's orbit will widen as it's not turning as hard but the missile will also slow, thus allowing it to maneuver better.  When the range to target opens to 1.25x the diameter of the dead zone (note that this diameter is based simply and only on the missile's speed, no complex calculation is required at runtime) the missile returns to it's normal tracking behavior.
For anyone interested in the derivation of this, I wrote down the distance between the player and target after the timstep, in terms of the initial position, velocity, acceleration rate and acceleration angle, then took the derivative with respect to the acceleration angle. Setting that to zero finds the minima of the player-target distance after the timestep as a function of the acceleration angle, which is exactly what we want to know. Interestingly, even though the acceleration rate was originally in the equations, it cancels out making the optimal direction independent of how much you are actually able to accelerate.
Note that the atan2(a,b) function computes the inverse tan of a/b, but ensures the angles sits in the correct quadrant of a circle, which requires knowing the sign of both a and b.
1) If the resolution of the scene you are looking at allows it, then the object can explode when it is Near the target (Which is how I believe most common day homing missiles actually work in any case). If your orbiting range is about twice the size of the object away then this will likely not work for you as it would just end up looking bad.
I always prefer simple solutions whenever possible. If you are making a game where the homing missile is just one of the weapons being used then  you can likely get away with these as players are likely to fire off a salvo and then swap back to their constant engagement weapons as soon as possible. If you are making a missile simulation however, then clearly one of the other answers is the better choice.