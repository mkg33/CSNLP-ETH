Declaring the cookie httpOnly would certainly make it harder for any potential exploits to be successful. 
Even if there isn't an injection at the time, I could imagine that you will extend your code in the future. For example, currently, there can only ever be one login cookie, so I'm assuming you only allow one user. But this might change in the future, in which case $cookie_name will not be the static string GETIN, but some kind of identifier send via cookie. These changes would not be made in getSalt and getCookieID, so it would be very easy to forget to secure the queries.
How an actual malicious user would exploit the cookie is beyond my knowledge, but I believe that you should always be a healthy bit of paranoid when dealing with security and seek to implement security in depth (multiple layers) rather than a single layer.
The documentation of uniqid says: Warning: This function does not create random nor unpredictable strings. This function must not be used for security purposes, this is because it's based on the time it is created. It's not so bad because your salt is actually random, but still. If you are afraid of collisions for the token, you could generate a truly random string and prefix it with the username. 
If your site one day runs over SSL you should consider changing the configurations for the remember-me cookie. The $secure parameter from the script above indicates that the cookie can be sent over insecure connections (its value is false). Setting this to true would make so that a potential man-in-the-middle attacker would have a very difficult time (maybe even impossible) reading the value of the cookie and generating his own remember-me cookie and through that bypass your login routine, while impersonating another user (ouch!).
It's not all that clear, but how I understand it, you do not use a session for login check at all. It would be better to add code that handles the normal session checking, and only use the cookie based authentication if no session is set, and then set a session (so All the times but not the first would become Only the first time, and you would not have any queries on subsequent requests). 
There is one thing I would like to add to tim's answer regarding security. I assume the cookie should only ever be read by the server side. Therefore I would use the last parameter in the native PHP setcookie() function called httpOnly. If you set this to true you indicate that the browser must never make the cookie and its value available to client-side scripts such as javascript.
In order to further increase your security you should have your entire site running over SSL (https). This may be overkill for a local development or learning site. I mention it so you are aware that this is always a good practice to use SSL when dealing with sensitive/login-required sites. So I would strongly recommend developing your application to that a change to SSL in the future is as painless as possible.
If UserID is user controller, you have a second order SQL injection in storeCookie. Either way, I would use prepared statements for all variable content just to make sure.
As your code is executed on every request, it's best to optimize it. First of all, you perform two queries when one would be enough. You could join your getSalt and getCookieID method to a getSaltAndCookie method which returns both values in an array.