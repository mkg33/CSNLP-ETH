This structure is not magical; it simply explains how to read vertex data from its associated buffers.
In version 4.3 (or with extension ARB_separate_attrib_format) there is a new way to bind the vertex attributes where the vao holds the format separately from the buffer binding to help exactly the above mentioned hardware: 
This means a lot less calls and the driver can do some optimizations because it knows which vertex formats will be used. (some hardware has to do software vertex pulling so suddenly having a new format will require a patch of the vertex shader).
Note that VertexBufferBinding stores a buffer object. That's where that binding point reads its data.
VAOs are essentially 'plumbing' objects that help get data from your buffers into your vertex shader ready for drawing. On the GPU this is handled by the vertex fetch stage, so a VAO is basically just a bundle of vertex fetch state corresponding to a particular model.
You can render without a VAO in legacy OpenGL, but this is generally more of a PITA, since you need to bind each vertex attribute separately each time you draw the object. Encapsulating all these bindings in a VAO lets you set them up once, then you have a 'plug and play' object that simply needs to be bound before a draw call, and all your vertex data will be ready to go.
Before I get downvoted. I am not asking how to use them, I know how to use them. I am trying to understand what they are. For example, an array is actually a contiguous section of memory, a linked list is actually just a clever way of using memory addresses, a 3D array is actually just a 1D array being used in a clever fashion...
The fields of VertexFormat are specified by the glVertexAttrib*Format or glVertexAttrib*Pointer functions. In the case of the latter, it also specifies the corresponding VertexBufferBinding data.
Buffer objects contain your vertex data. Vertex array objects tell OpenGL how to interpret that data. Without the VAO, OpenGL just knows that you suck some bytes into some buffers. The VAO says that "in this buffer, at byte offset X, is an array of 4-vector floats, and that data will be fed to attribute index Y."
Under that logic, VBO's are sections of GPU RAM that contain rendering data. They are thus "arrays". But then what is a VAO? My current understanding is that they are magical "boxes" that somehow store machine state information for a set of VBO's, but what are they actually?
Because for example, as far as I know, you MUST bind the VBO's under a VAO to get rendering output, if you just bind the VAO you won't get outpt, so what is their purpouse?
Every call to glVertexAttribPointer, glEnableVertexAttribArray and the binding of gl_Element_Array will store the parameters into the currently bound vao. In the case of glVertexAttribPointer it will also store the current binding to GL_VERTEX_ARRAY in the vao.
You can think of it as a bundle of pointers, but with somewhat more complexity than CPU-side pointers. Since OpenGL buffers are just a blob of untyped bytes by default (that's why you get a void* when you map them), the VAO handles type-casting (to vec3 or whatever) when fetching the data. It also deals with the size of the data not necessarily matching the stride between consecutive elements, and makes sure that each data item (position, normal, uv, etc.) is transmitted to the correct 'channel' in the vertex shader input.