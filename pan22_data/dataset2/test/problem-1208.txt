It is a small library designed to be LD_PRELOAD-ed before starting a given executable, basically works by chroot()ing into a given directory, then removing all capabilities (except ones based on a whitelist) then setuid()-ing to a given user, preventing the given executable from doing nasty things.
I think running executables in a VM is your best bet.  For example, there's a bot on the #bash IRC channel that allows for the execution of arbitrary shell code...by running it inside a qemu based VM and then capturing the stdout of that process.  UML is probably a reasonably good solution.
Does it have to be an executable file? Could you restrict uploaded programs to be for example source code in some scripting language (python, ruby) which have some kind of sandbox executing environment. Or bytecode for something like C# or Java? At least C# and Java have built in security mechanism for allowing and disallowing operations. 
The new lguest stuff (http://lguest.ozlabs.org/) is probably better; this is "container" mechanism, rather than a full-on "virtualization" solution; something like Solaris Zones.  I don't know what the state of this project is right now.
You're taking a massive, massive risk running untrusted code.  I would completely rethink both what I wanted to do and the fundamental assumptions of my project if the answer to my problem I came up with was "run untrusted code from arbitrary users on my server".
One of the beauties of this program is that it chroot()s after the system has loaded all the necessary libraries, therefore if you are lucky (it does not want to dl() some other libs) you can use it with an empty directory, as a chroot() environment.