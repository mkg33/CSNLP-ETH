The language of the books is aimed at college-level students, and the equations and explanations seem to assume the student has a prior understanding of the "language" used in the mathematical analysis. Therefore, I couldn't recommend using that as the textbook for the class, or even for that segment of class. I can, however, recommend it as an excellent starting point for your lesson plan. Using the progression of his explanations for finding the growth rate of an algorithm, you can rework the examples, and the application of mathematical concepts so that it better fits the knowledge of your students, and carry it forward in a manner consistent with your style in the class so far. The method used to show, and find, growth rates, and the Big $\Bbb O$, Big $\Omega$, and Big $\Theta$ are decidedly non-math in their application, and adjusting the material for the students you see in your classroom should be reasonably simple.
I learned to program a long time before I'd ever heard of "Big O Notation" or any other formal analysis of algorithms, asymptotic or otherwise. Three plus decades into my programming, I read a book  by Clifford A. Shaffer of Virginia Tech, A Practical Introduction to Data Structures and Algorithm Analysis. It has since been republished as Data Structures and Algorithm Analysis with version in C++ and Java.
When I first read chapter 3, Algorithm Analysis, I basically said to myself, "Yeah, I got that." After all, I'd been programming for a while, and I had a good sense about how complex an algorithm was, and didn't need any formal notation, or explanation for it. Later, after it had percolated through my brain for a while, I realized that it was rather handy to have a way to explain to others, including customers and managers, why doing it this way would take more time, even if it saved disk space, or, on the other hand, why that way was doing the job fast, but the disk access was the bottleneck in program speed. All I could remember from the first breeze through the chapter was that it had a lot of mathematics involved, including things like $O(n log n)$, $T(n)=O(f(n))$, and such. I knew I'd seen at least one $\sum_{i=0}^n = yada + yada$ type expression in there somewhere as well.
Both the C++ version and Java version are available online along with lots all of the resources, assignments, and C++ and Java source codes for using the books in class.
I agree that you should give your students the exposure to the subject, and deepen that exposure as much as the curriculum will allow. I've found, after learning from that chapter, that I am equipped to explain my analysis of a routine, and its possible optimizations, much better to other programmers - whether they know Big $\Bbb O$ notation or not. If someone does know Big $\Bbb O$, it is an excellent shortcut to explaining why a routine is slow, and if they do not know Big $\Bbb O$, I am now able to quantify and explain what I used to intuit and couldn't explain.
Again, the mathematics is more for explaining the results than for finding them. Understanding what the graph looks like helps a lot, by orders of magnitude. The online graphing calculator mentioned by Buffy in another answer is an excellent way to deal with the math involved in understanding the growth rate that Big $\Bbb O$ notation signifies. I once made a similar, if much simpler, tool for explaining the concepts of linear, logarithmic, and quadratic to GED students. What they couldn't grasp with words and text, the readily apprehended with interactive visuals.
Never having studied Calculus I was rather intimidated by the thought of all that math. (I like math pretty well, and I also know what I don't know.) Still, I had the book and I had the time, so it couldn't hurt to go back and study that chapter again. On the second reading I realized that while there was math involved, there wasn't really any math performed. Rather the concepts of math were used to explain what was being analyzed and how that affected teh growth rate. The concepts were important, but never once did an equation need to be solved. Furthermore, just in case the student did not understand the relationships between $10n$, $n log n$, $n^2$, $2^n$, and $n!$ the author included graphs and tables.
As this will be the introduction to Big $\Bbb O$ notation, and at that only a "dip your toe in the water" type exposure, testing on the subject probably shouldn't be very intense. If you covered the complexity of heap sort and can write a heap sort in a manner they have not seen, then use that and ask them to find the Big $\Bbb O$ of the new version. It's still a heap sort, and they should be able to reach the same results as for the one they've already seen. Additionally, with some short code fragments, have them classify the fragments, or use pairs or fragments, and ask for the one with the better Big $\Bbb O$ for a significantly large value of $n$. The idea is to reinforce the usefulness of the analysis, and that Big $\Bbb O$ notation is only a simple, common, way of expressing the complexity that allows for comparing algorithms and selecting which one to use in a new situation. Leave the finer details for later courses when, and if, they pursue a CS curriculum.