I think what you're probably use to in the business world is separating abstraction and implementation. 
Entity - just an id, like a long.  The entity is what groups a set of components instances together into an 'entity'.
It's updated frequently by an extremely knowledgable guy.  It's also the only entity system discussion with concrete code examples.
Having each class implement some sort of Collidable interface and then having a high-level bit of code that just loops over all Collidable objects in the update phase of your game and handles collisions, setting the object positions as needed.
So, one natural way of solving the problem here is to have every object take every other object as some sort of parameter for checking collisions. This scales poorly, and can have weird results.
I recently made a simple Space Invadors game using an 'entity system'.  It's a pattern that separates attributes and behaviours extremely well.  It took me a few iterations to fully understand it, but once you get a few components designed it becomes extremely simples to compose new objects using your existing components.
EntitySystem - Each system is essentially just a method which operates on a set of entites.  Each system will use component x,y and z of an entity to get it's work done.  So you would query the manager for entities with components x,y and z then pass that result to the system.
In the game dev world, you usually want to think in terms of speed. The more objects you have the more context switches will occur which may slow things down depending on the current load.
EntityManager - acts as the component "database", which can be queried for entities which contain certain types of components.  This can even be backed by an in-memory database for speedy access...see t-machine part 5 for more info.
See the above for an exploration of this. If you are in a language that supports interfaces easily (i.e., Java, C#), this is easy. If you are in C++, this can be... interesting. I'm a favor of using messaging to solve these issues (classes handle messages they can, ignore others), some other folks like component composition.
So, a more generalized idiom for what you have there is handleMessages/update/draw. In systems that make heavy use of messages (which has pros and cons as you would expect) a game entity grabs whatever messages it cares about, performs logic on those messages, and then draws itself.
Note that that draw() call might not actually mean that the entity calls putPixel or whatever inside itself; in some cases, it could just mean updating data that is later polled by the code responsible for drawing. In more advanced cases, it "draws" itself by calling methods exposed by a renderer. In the tech I'm working on right now, the object would draw itself using renderer calls and then every frame the rendering thread organizes all calls made by all objects, optimizes for things like state changes, and then draws the entire thing out (all of this happening on a thread separate from the game logic, so we get asynchronous rendering).
Component - a set of fields....no behaviours!  when you start adding behaviours it starts to get messy...even in a simple Space Invadors game.
So, I went back and re-read T-machines blog.  There is a lot of information in the comment threads- and in them he really emphasizes that components do not have behaviours- behaviours are provided by the entity systems.  In this way you do not need to pass messages between components and order component updates because the ordering is determined by the global order of system execution.  Ok.  Maybe that's too abstract.
It looks a little weird at first, but it's incredibly flexible.  It's also very easy to optimize; for different component types you can have different backing datastores to make retrieval faster.  For the 'form' class you can have it backed with a quadtree to speed access for collision detection.
The first iteration had an "EntitySystem" object which was as Adam describes; however my components still had methods- my 'renderable' component had a paint() method, and my position component had a move() method and etc.  When I began to flesh out the entities I realized that I needed to start passing message between components and ordering the execution of components updates....way too messy.
I'm like you; I'm a seasoned developer but had no experience writing games.  I spent a some time researching gave dev patterns, and this one caught my eye.  It is in no way the only way to do things, but I've found it very intuitive and robust.  I believe the pattern was officially discussed in book 6 of the series "Game Programming Gems" - http://www.amazon.com/Game-Programming-Gems/dp/1584500492.  I haven't read any of the books myself but I hear they are the de-facto reference for game programming.
Again, you just have to develop a sense (or make up your mind) on how responsibility for different things in your game needs to be delegated. Rendering is a solitary activity and can be handled by an object in a vacuum; collision and physics generally can't.
The delegation of responsibility is up to the programmer; for a simple pong game, it makes sense that each object handles its own drawing (complete with low-level calls) completely. It's a matter of style and wisdom.