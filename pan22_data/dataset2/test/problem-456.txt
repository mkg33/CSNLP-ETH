Write a program to "fold" long input lines into two or more shorter lines after the last non-blank character that occurs before the n-th column of input. Make sure your program does something intelligent with very long lines, and if there are no blanks or tabs before the specified column.
I wanted to make the folding non-destructive and possibly reversible, so the program doesn't delete anything, and adds a \ when we break individual "words". The output can be reversed by deleting (?<=\ )\n|(?<=\t)\n|\\\n pattern matches (obviously if original had some matches, they'll get deleted too). Would you say this design approach is good?
In the spirit of writing reusable code, should I move appending the '\n' and '\' to the main routine and make the function just split the string at breakpoint? Or even, make one to find the breakpoint, and other to split the string?
The solution attempts to reuse functions coded in the previous exercises (getline & copy) and make the solution reusable as well. In that spirit, a new function size_t foldline(char * restrict ins, char * restrict outs, size_t fcol, size_t tw); is coded to solve the problem. However, it requires a full buffer to be able to determine the break-point, so I coded size_t fillbuf(char s[], size_t sz); to top-up the buffer.
I'm going through the K&R book (2nd edition, ANSI C ver.) and want to get the most from it: learn (outdated) C and practice problem-solving at the same time. I believe that the author's intention was to give the reader a good exercise, to make him think hard about what he can do with the tools introduced, so I'm sticking to program features introduced so far and using "future" features and standards only if they don't change the program logic.