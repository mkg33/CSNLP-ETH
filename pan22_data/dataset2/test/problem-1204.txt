One thing the existing good answers don't mention yet: zero-based indexing works well together with modulo operations, which can therefore be combined to form cyclic list. Think for example about something like
If I recall correctly from my Programming Language Concepts class... languages being 0-indexed and others being 1-index had to do with historical reasons. Algol-68, the grand-daddy of programming languages was actually 1-indexed, as well as Fortran and a few other "business" languages like COBOL. In some of these languages however, you could actually specify explicitly what your starting index would be. There's a interesting table of this here.
Another thing to consider is the fact that it is pretty easy to not use the first element of a zero-based array. (This does not hold for foreach-style iteration and similar language constructs which treat the array as a whole.) Many programmers, myself included, might feel a bit awkward about the wasted space, but in most situations the amount is so tiny that these worries are unfounded. On the other hand, if languages are using one-based indexing, then there is no way to simulate an element at index zero without a lot of code. So given that in some situations zero-based indexing is better than one-based, choosing zero as the basis everywhere is the more flexible approach, as opposed to one-based everywhere, and it is also more consistent than configurable starting positions.
Another good example would be birthdays - we don't say someone's is one year old the day they are born, we say it's a year later.
The automatic modulo operations imposed by fixed size unsigned binary arithmetic with wrap-around are another example of why this makes sense.
Now if your question refers to why as far as why a computer (not a language) naturally starts to count from zero... well it's I guess inherent in the binary really:
It's practical to think like this when adding up distances (or indexes) - I advance one step, then zero steps, then two steps, where am I? I am at index 1 + 0 + 2 = 3. Skipping three steps, I end up at 49 in the array above.
which might give each object (indexed by i) a different color from the list colors, until all colors have been used, at which point it would start again from the beginning. Expressing the same in one-based indexing is pretty clumsy:
the distance from the start of the array to the 25 is 2 - you need to skip two steps to get there. The distance to the 4 is zero - you don't need to move from the start at all.
My point is, we "count" from zero all the time in the real world - "How many positions after [start of array] is the element you want" simply happens to be the question you are answering with a count-from-zero in many computer programs. You wouldn't say that the first element is one position after the start, would you? It is the start.
We say leap years or US presidential elections are every four years, even though if you count from one: 2000, 2001, 2002, 2003, 2004 is five years. (Incidentally, the Romans did screw this up for a while, and had leap years too close together)
Basically back in the "Ye Olde Days" mathematicians, scientists, and other "academics" usually used 0-indexed languages, while users of languages like COBOL found it of no use to start counting at 0, so in those languages it made more sense to start at 1 (it seemed less confusing). 