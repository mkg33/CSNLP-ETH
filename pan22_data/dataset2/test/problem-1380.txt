This will create an additional routing table registration with the name vpn, add a rule to use this routing table if a packet is originating from the 10.187.1.0/24 subnet and add a default route through tun0 (which is a point-to-point interface, so the route specification does not need a gateway address) for all traffic routed through the vpn table.
So, your first problem is running telnet google.com 80 -b 10.187.1.9 - you are instructing telnet to bind to a non-local address, which would not work. The second problem is that Linux is doing routing decisions by evaluating the destination address only by default. As google.com is resolving to something not local to your network and not covered by any other route, the packet is relayed through the default route, which would be 192.168.1.1 in your case and which probably knows nothing about the 10.187.1.0/24 subnet, so it effectively drops the packet. If you need this traffic to take the route through tun0, you should tell Linux explicitly:
OpenVPN uses an entre subnet to accommodate its virtual interfaces at the server side as well as the connecting clients. In your case, this subnet seems to be configured as 10.187.1.0/24. OpenVPN is assigning 10.187.1.1 for the server side and it is splitting the rest of the subnet up in smaller subnets for each client connection. By default it will use /30 with 2 usable addresses, one network address and one broadcast address for compatibility reasons and assign the first of the usable addresses to the server and the second to the connecting client. In your example this would be 10.187.1.9 (server) and presumably 10.187.1.10 (client).