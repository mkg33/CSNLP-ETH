I have working omnidirectional shadow maps for point lights. Rendering a shadow map for one point light consists of rendering the scene to 6 separate rendertargets, then send those render target textures (shaderresourceviews) to a pixel shader which will shadow the scene by projective texturing. Switching rendertargets 6 times for each point light however is quite costly, and so does sampling from those in the pixel shader later. 
My question is how would I access a face of the cubemap to render to? Now I am doing Id3d11devicecontext::omsetrendertargets(1,NULL,&depthtarget) . My depthtarget is a texture2d which is bound to a depthstencil view and a shaderresource which is set up to be a cubemap. Can I even set an individual face to render to or is the process completely different?
Use a geometry shader for this, writing to SV_RenderTargetArrayIndex to determine which cubemap face to write to.  See the CubeMapGS sample for D3D10 in the old DirectX SDK - the process is the very same with 11.