One thing you could do, is generate the 3D Voronoi diagram of the vertices of the simple mesh. This will partition space into a number of cells, where everything inside a cell is closer to the vertex corresponding to that cell, than to any other vertex. You can then compute a 3D equivalent of the Delaunay triangulation, which will give you a set of tetrahedrons. Every point inside such a tetrahedron can be expressed as a linear combination of the four vertices of the tetrahedron.
*By skin I mean I need an algorithm to determine the best control points for a vertex, and their weights.
Please note that this is not a simple way to skin the mesh. If you are looking for a simpler solution, I would suggest manually assigning weights to the vertices. (A package like Blender allows you to weight-paint vertices.)
For every vertex p in the high-resolution mesh, you can look up the tetrahedron that the point is in, which will give you four vertices of the simple mesh (call them v0, v1, v2, v3). If you translate every vector by -v0, it is possible to write the new point p' = p - v0 as a linear combination of v1', v2', and v3'. This gives you a new eqation for p', namely p' = u * v1' + v * v2' + w * v3', where u, v and w are the weights. Now you can write the point p as v0 + u * (v1 - v0) + v * (v2 - v0) + w * (v3 - v0). If the simple mesh is deformed, v0, v1, v2 and v3 will change, and p will change accordingly. This deformation will depend on at most fourr nearby simple vertices, and thus a deformation on one side of the simple mesh will have no effect on the other side of the high-resolution mesh (unlike the distance-based falloff, where every simple vertex still affects every high-resolution vertex).
The point of this is to preserve complex three dimensional features of the main mesh while using physics implementations which expect something far simpler, low resolution, single surface, etc.
Therefore, the vertices must deform linearly with their respective weighted control points (i.e. no falloff fields or all the mesh features will end up collapsed) - as if each vertex was linked to a point on the plane created by the attached control points and deformed with it.
I have tried implementing the weight computation algorithm in this paper (page 4) but it is not working as expected and I am wondering if it is really the best way to do what I want.
In effect, each vertex of the proxy/collision mesh will be a control point/bone, which should deform the vertices of the main mesh attached to it depending on weight, but where the weight is not dependant on the absolute distance from the control point but rather distance relative to the other affecting control points.