If you have "layers" of zone sizes, you can quickly isolate the location of an agent or player, then recursively traverse the relevant zones that are contained within each other, to find the player. This saves you traversing all zones in the environment to find them, and you can do checks in relation to what you need. If you need their rough location, find a "top layer" zone, one of the largest, but if you need their exact location, traverse down to the "bottom layer" zones, that pin point them in relation to objects.
In an external environment, you can register the players within zones and the players that are visible and of immediate effect to them. Once they enter this zone, the agents and players visible to the player are of high priority, so you prioritize the amount of data you process in relation to their actions over agents and players of a greater distance (or not at all if they are in a separate zone).
If you have an internal environment, you can make the building a parent zone, each room a zone and then create a portal in the doorway of each zone. Essentially, the portal checks to see if it is within your view volume and if so, renders the geometry on the other side of the portal. If you have several doorways in view, this means you can see each portal, and the contents of each room rendered visibly, but this is a local optimization, however this does relate.
Games like Minecraft use a form of fixed-size chunks that act somewhat like a spatial hash.  In Bukkit, presumably it limits checks to chunks - if you are in chunk (1,4) and a trigger covers chunks (19,45)-(21,47) then there is obviously no need to even consider testing your avatar against the trigger.  The game will only compare your avatar to triggers that it already knows coincide with the chunk you're in.  I think this is what you said your idea was, though it's hard to tell exactly what you meant.
A method I use for dividing scenes up, is to create a zone, which is essentially just an invisible cube, within this cube you can have sub-zones which are children to the parent zone. Depending on the environment you are rendering, you can optimize in relation to how you partition your world with these zones.
In Minecraft again, assuming we cared about triggers as small as a single block, the player is simple not capable of moving by a whole block or more in a single iteration of the game's physics cycle.  More generally, entities can only move at a smallish fraction of the block size per update cycle.  Mechanics like pistons can break these rules but then there are a lot of potential bugs with such mechanics.  The game can also special-case some updates or use a smaller update cycle than normal (e.g., if the player moves 1 whole block at a time, the game checks the player's original position, the ending position, and position halfway between).
More generally, especially for MMOS and even an increasing number of action games, the client does not send position updates to the server.  The client sends input commands to the server such as "move forward."  The server then calculates the player's new position, does whatever post-movement checks are necessary, and then sends the result back to the client.  The client may have also processed the move (to hide network latency and make the game feel smoother) so the client is then responsible for lag compensation and prediction correction, handling any discrepancies in its predicted movement and the server authoritative movement its received afterward. 
A quick method is a AABB collision detection with the zone, or use four points(like you're catching them in a net) and do your localized data streaming for that area as previously mentioned.
This is just another category of collision detection.  Your server needs to be able to tell if two bounding shapes are colliding for any number of reasons and this needs to be efficient; there are many ways to achieve this.  The world is then capable of having thousands of entities (including triggers) and information about which ones are currently in contact are cheaply calculated.  Then idea you mention is a very rudimentary form of spatial partitioning.  More complicated and dynamic methods such as kd-trees, bsp trees, octrees, spatial hashiing and dynamic bounding volume hierarchies are typically used in real games.
You do not need to fire an event constantly to check if they have left/entered a zone, as it is network based, you can check against child objects in the zone after so much movement has been detected, in relation to the size of the environment and then increase your checks as they draw closer to the zone limits, but this only works if zones are connected.
The case of a player entering and leaving a trigger area in one update cycle doesn't really happen.  The server uses discrete updates in most cases, meaning that it looks at the player's position at specific time intervals.  In the general case, it checks the position after each movement.  The player is simply not allowed to move fast enough - nor are triggers allowed to be small enough - that the player is able to enter and leave a trigger with a single position update.