To allow the game to get more complex, I would opt to use a state machine pattern to handle difficulty levels. All actions concerning changing game parameters that influence the difficulty are handled by each specific state. This allows for an object-oriented design, extensibility, and drastically decreasing the amount of boolean flags in the game.
Each state has actions on Enter and Exit. A Difficulty level state also handles OnScoreUpdated events.
As the game gets bigger, gets more parameters that are sensitive to the difficulty level, gets more difficulty levels and gets such features as skipping levels, decreasing score and levels, it will be hard to maintain the code.
Now, any time the score gets updated, the game asks the current difficulty state to handle the score. The current state might decide to keep the state as is, or to change the state to another difficulty level based on the current score. Whenever the difficulty state changes, its Enter actions change the difficulty parameters of the game. This pattern also allows to skip states (big score leaps) and decrease difficulty levels.
You don't talk about if the score can decrease or if it is possible for the score to jump over one of the difficulty ranges. If neither of these things are possible, the logic to set the difficulty can become very simple by using an enum.
Your Increase method is a black-box to us. Maybe it's linearly changing some difficulty parameters, or maybe it sets custom values to each of these parameters.
However, as you can see, this gets very repetitive very fast. An alternative would be to construct a table that defines the data points.
That's still encoding 3 difficulty levels into the identifiers, but at least the thresholds aren't part of the variables' names, so it's a start.
Each specific state implements a self-transition to avoid unnecessary state changes and actions on Enter to change the game's difficulty level. I haven't found a use for Exit, but I'll keep the method because the pattern provides it, and you might find a use case for it. Implement EasyState, NormalState, HardState and ExpertState.
If you wanted to change your levels, let alone making them configurable, then what's 100500 going to tell the maintainer?
Please, don't do that. I mean, yeah, private fields should be camelCase in the first place, but that chunk of numbers is fairly annoying, and it encodes your game logic into an identifier.