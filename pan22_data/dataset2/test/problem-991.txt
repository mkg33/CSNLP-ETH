But programmers (who are the ones spending the most face time with the CPU's innards) don't really care about the hardware interface between CPU and memory, they care about the interface presented via the CPU's instruction set, and this question becomes the most important:  What's the number of bits that registers and instructions deal with at once.
The old Motorola 68000 came in an 8-bit bus variant, the 68008, for example.  It was a 16-bit CPU however, though the argument could be made it was 32-bit.
It is a 32 Bit CPU - there is widespread consent, that the "Bitness" of a CPU is the width of a void *, which in this case would be 32
So how is that related to the bus?  It isn't.  As long as the bus gets the data from the CPU to the RAM, the programmer doesn't care.  Obviously a narrower bus is going to be slower, but it won't affect how the programmer tells the CPU to do things (other than maybe trying to make the program access memory more efficiently.)
The "long" mode aka "64-bit" mode, aka amd64 instruction set tacks on another 32 bits to these registers, but all the old instructions that address 32, 16, or 8 bit parts of registers are still there.
i386 instruction set prefers to deal with 32-bit quantities, if you need to do math on integer quantities greater than 32 bits, you need to add the lower 32 bits first, then carry over into a second 32 bits.  But i386 is flexible and lets you add 16 or 8 bit quantities as well, as well as split registers up into 16-bit or 8-bit sections.
It makes sense to have at least as many bus bits as CPU bits but this does not have to be the case.  The bus width doesn't have to have anything to do with the CPU instruction set or its registers.