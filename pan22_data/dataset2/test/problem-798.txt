The OS will see all enabled CPUs but should be able to separate core vs socket for example (eg SQL Server affinity). But no, you can't make a 4 cores appear as one to OS thats I know of.
Depending on the BIOS, you might be able to disable all but one of the cores, but you're going to lose a large part of the performance. You can also set programs to run on a single core.
Very surprised no hardware or software companies like VM Ware, Intel, or AMD, have tried to figure out how to do this, given the current state of affairs in the CPU market. Imagine not having to choose between a fast gaming CPU or a monster multi core CPU with all those extra PCIe lanes... you could then simple change the cpu's mode when you are using a program that does not utilize many threads of CPU. Then it takes the pressure off of developers back's, if CPU's can do this, there is less need to multi thread the application. VM's can already appear as more cores than your physical CPU at a heavy tax on IPC, we need something that can do the opposite, many programs performance would still benefit greatly if you could do what is asked in this thread.
I have been wondering about this very thing. I think it would be possible to achieve this on current multi core CPU's if a VM used emulated processor that could spread it's bit width across all physical CPU's in sync. For example you could make a 3 Ghz 8 core 16 thread chip appear to the OS and programs running in the VM as a 6 Ghz 4 Core 8 Thread chip, or a 12 Ghz 2 Core 4 Thread chip. I know of no such VM but it is likely possible that this can be done (with some IPC reductions from the physical CPU obviously).               
As for a chip designed to do this, there are none, but if a design allowed for physical connection of the bit width connecting the cores to accept instructions along the entire width per cycle, then you could do this without using a VM and a smaller hit on IPC.        
In short, no. Virtulization is able to work quickly only when it can execute the OS and applications instructions on the CPU natively. In theory, one possibly could rewrite incomming instructions to better utilitize multiple CPU's, but that would likely fail on all but very simple tasks. How do you know that you are not executing the insturctions to send data, but the calculations on that data are not finnised yet?
This is one reason applications have to be written and compiled specificly for multithreaded operation.
As was asked in a comment by the OP, what about running the OS and application in a VM? Would that essentially be the same as faking a single faster CPU?