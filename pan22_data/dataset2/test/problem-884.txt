As with all code, if there was a single rule that could be easily applied, we wouldn't need programmers, as computers already excel at applying basic rules. What makes a programmer valuable is that there are many tools/patterns that can be applied, and they always have various trade offs. Our job is to understand where the tools/patterns give good value and apply them intelligently.
You have your indices swapped: you define it as [8, 6] but you use it as [6, 8] which will lead to IndexOutOfRangeExceptions
Consider it is just an initializer and will only be used this once, there is no need to make it explicitly return the data when you can just set it directly.
I would pick the method where you return an array of objects, because that makes it easier to unit test that method should you feel the need.
Magic numbers: Instead of using 8 and 6 (and perhaps even 3) in the double-loop above, retreive the length of your array with myMonsterArray.GetLength(0) and myMonsterArray.GetLength(1).
Another advantage of the first one is that your field could be final (or readonly, I'm not too familiar with C# but I guess it has something like that). The following constructor code also does not compile in Java if the monsters field is final:
Furthermore, having the array return value makes the code easier to read. It's obvious from the signature what the method does, readers don't have to check the method body to figure out its side-effects. Finally, you could call createMonsters() from other methods without side-effects.
A maintainer easily could mix up the order of the called methods which breaks your class and might turn out only at runtime. It's not possible the following:
Instead of numbering your SpriteFactory.getMonster1Sprite() methods, use SpriteFactory.getMonsterSprite(1), this would allow you to write:
I would personally go with the first approach. As a general rule I prefer pure functions. While in this case I don't think it would make much difference, I have very rarely ever found that I was happier with a mutating function like this. I think pure functions are much easier to reason about, and reduce complexity. In general the creation of the object is best left to the function while the assignment should be left to the constructor.
Anyway, having the separate factory class (as a constructor parameter) looks even better, it's less coupled, +1 to Simon.
I personally find a method that returns it more flexible and more of a separation-of-concerns approach. And by doing so, you could even move the method into another class, such as a Factory class that perhaps can provide you with other monster arrays.