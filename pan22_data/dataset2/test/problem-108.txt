Why don't you just use normal A*, and model locked doors as impassable regions; once you pick up the key (walk on the key tile?), that changes that particular locked door into a passable region.
A very useful optimization is to precalculate the shortest paths from each door (actually, each side of each door) and item to every other reachable door/item, assuming that all doors are locked.  Once you have those paths, you can just treat each of them as a weighted edge in a graph connecting these significant locations to each other, and ignore all other locations.
You can extend this trick to include other state changes, such as switches that can open and/or close doors.  You could even allow the player to drop items, although this can get complicated since the state must then include the location of each dropped item, increasing the potential search space enormously.
The normal gut reaction to the words "shortest path" would obviously be A*. But A* would fail in such an environment, since I see many problems defining a reliable heuristic and, additionally, it is very likely, that a node has to be visited multiple times, which is also not possible in conventional A* and would also make the heuristic harder.
In each copy of the dungeon, the doors which are passable are exactly those that can be passed using the corresponding set of items.  The only way to pass from one dungeon copy to another is to stand on the location of an item and pick it up.
It is true, however, that these complications will move A* from the realms of 'very efficient' to 'will succeed, but probably not in the timescale I require'. What is the timescale you require? In fact, why do you need to do this - do you really need the shortest path, or would any reasonable path suffice?
The way to handle such a situation optimally using straightforward A* is to expand the search space.  That is, imagine that there exists a separate copy of the dungeon for each combination of items your character might be carrying.
Assume you had to find the shortest path through a dungeon, where certain passages are only opened to you after certain items were collected, like locked doors and keys, for instance.
What this means is that your path-finder will go for the shortest keyless route, and if it finds keys along the way, it will incorporate that into its path if that helps. 
A big problem I see with my solution is that after all the paths including the ones for item acquisition are found, the total distance travelled by the agent might not be the smallest possible, since there might be other blocked doors that are farther from the goal but have their appropriate key much more easily available. A* would have neglected these doors on the first pass where blocked doors are simply ignored.
What I thought about is simply looking for a path from the start of the dungeon to the end, ignoring any blocked doors. After this path is found, for each of the doors blocking our way, an additional path looking for the appropriate key and back to the door would be sought and traversed before the door is even reached. The very same system would be used to handle a situation, where the path to a key needed to open a door is again blocked by another door, which needs to be opened first.
I'm sure I'm not the first one to try to solve this and I would appreciate some input on the problem.
For example, assume that your dungeon has ten doors and five keys.  Then there will be 2 * 10 + 5 = 25 significant locations, and 2^5 = 32 possible item combinations, for a total of 25 * 32 = 800 nodes in the full search space.  This is a very modest number, especially given that much of the search space is likely to be unreachable.
Once I got that working, I'd consider some minor optimisations - eg. weighting the areas with keys in more leniently so that the low level pathing would be more likely to make small detours to collect keys.
It's easy to prove that such a system would be suboptimal. Where would you begin the additional path from? If from the start, then you've wasted your time plotting the original path to the door. If from the end, then placing a key near the start means the path traverses the map twice when once would suffice. If you try and calculate optimal merge points for the paths to and from the door and the original path, that will yield an optimal result but will be resource-intensive due to the number of permutations and difficulty forming a heuristic to simplify the search. If you add multiple keys into the problem then you have the Travelling Salesman problem which is not easy to efficiently solve.
Secondly, A* can visit a node as many times as you like. Remember that A* is not a path-finding algorithm but a search algorithm. It searches through states. In games we often equate a state with a position, because we don't care how you reached that state - just how short the path was to get there. However in a problem like this the state is a combination of the position plus any other relevant state such as keys held. 
Firstly, an admissible heuristic doesn't have to be perfect. It just has to be an underestimate and it has to be better than nothing. Given that you're working with actual distances, it seems likely that A* would at least be of some help, and even if the heuristic didn't improve the search much, it would probably still be better than a standard breadth-first search or similar.