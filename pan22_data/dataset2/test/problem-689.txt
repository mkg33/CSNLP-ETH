This time the Adjusted Jump Speed is being forced non-negative; If the player is already rising faster than they should be able to jump, they would attain a negative adjusted speed, which allows them to use the "jump" action as brakes. (to slow down to the intended jump speed instantly!)
Figure 3, in that illustration, is how my game works thus far; not Figure 4. This makes solving for the bounce + jump problem much more challenging, because I can't simply measure and set an exact force or velocity on the Y-axis. Doing so results in weird behaviour, which becomes dramatically more noticeable as the ball travels on steeper slopes.
For the answer, you could clamp your velocity when jumping, which would prevent you from reaching too high speeds when pressing the jump button. 
I'm a novice programmer, and I'm stumped here. Can anyone help me find a creative solution to this problem? As long as the player is able to continuously bounce and jump higher and higher, I can't design any levels, because they'll all just be able to be cheated through. I'd love to move onward -- this issue has been holding me back for a long time, so I'd greatly appreciate some advice!
The jumping, however, isn't as simple as just firing the ball straight upwards. In order to facilitate more complexity in the level design, I've programmed the jump angle to be relative to the surface that the ball is rolling on.
The "Existing Speed" is also forced non-negative here; When the player is falling, a negative existing jump speed will compensate for their falling, allowing them to bounce on thin air if they trigger the jump while falling.
Note: I believe your contact X and Y are already normalized as a pair. I included explicit detail for completeness sake though.
While I personally love bunny hopping... As a starting point we should know the intended "Jump Speed" as a delta velocity. This figure represents the velocity increase (in the line with the "Jump Normal") during the instant of jumping once.
So far, I've been able to conceive a solution to all the other design problems in this game and then find out how to program them, but this one has me stuck. I've attempted a number of different approaches, but none of them have worked.
Now that we know how much to reduce the delta velocity precisely, we can compute the effective "Jump Vector" by scaling the Jump Normal to the target delta velocity.
I'm building a fairly simple marble racing game in Unity3D. The ball is a 3D physics object that moves only on the X and Y axes. It has the ability to roll left and right, and to jump. Pretty basic stuff, except that I've hit a game-breaking problem: When falling and striking the ground, the ball's bounce magnitude can be combined with its jumping force to create an extra-high jump. This means that, with well-timed button presses, the player can cause the ball to bounce exponentially higher, reaching unintended heights. I can't properly design levels until this glitch is fixed. I've illustrated this example:
In order to measure your pre-existing Jump Speed, we can take the dot product of your normalized your Jump Vector, and your player's velocity:
First of all, i want to say that your question is very well written and it's a pleasure :), you would just need to remove what's not necessary in the code (audiosources, etc.) and it would be perfect. Cheers for that. 
My latest attempt was to try jump - rigidbody.velocity.magnitude * 50 , to reduce the jumping power by the speed that the ball is travelling. It almost solved the bounce + jump problem, by proportionally reducing the jump force down to zero as the ball's speed reached what seemed to be the equivalent in velocity.magnitude. It worked from a standstill, but the problem is, it also accounts for the magnitude while the ball is grounded, preventing the ball from rolling at full speed and jumping. I was close, but not quite there!
Any velocity the player already has in line with the Jump Normal can be seen as a pre-existing "Jump Energy". This leads to a straightforward solution: The instantaneous delta velocity can be limited such that it never results in the player being accelerated beyond the target velocity.