Here Author_Nickname would be a primary key for the author table, and a foreign key in the post table. Even if Author_Nickname appears in two table, it still corresponds to a single unit of information, ie. each column name corresponds to a single field.
Mostly it's to keep foreign keys from becoming a tremendous pain. Let's say you have two tables: Customer and CustomerAddress. The primary key for both is a column named id, which is an identity (int) column.
Typicaly if you have an identity field in a table it's your primary key.  How would you build a child table with a foreign key to a parent table if the primary key in both tables was id?
Here's a summary of all the answers about the advantages obtained from the convention to not use a common name for all primary keys:
This leads to a couple of issues. First, you have to consistently remember when to call the column "id", and when to call it "customer_id". And if you mess this up, it leads to the second problem. If you've got a large query with a dozen or so joins, and it's not returning any data, have fun playing Where's Waldo and hunting down this typo:
If you can think of any other advantages this naming convention has, let me know and I'll add it to the list.
However, nowadays, and with ORM layers readily available in many languages, databases are often designed as a persistance layer for OO languages, in which it is natural that variables that have the same role in different classes are called the same (part.name and client.name, not part.partname and client.clientname). In such a context, I tend to use 'ID' for my primary keys.
It's the same reason why you wouldn't name all of your varchar fields something like "UserText" and "UserText1", or why you wouldn't use "UserDate" and "UserDate1".
Granted, there are cases where this doesn't help, such as if you need multiple foreign key relationships from one table to another single table, but naming all the primary keys "id" doesn't help any there either.
In many cases there can't be a unique constraint on the original fields, so a numeric artificial field is used as primary key instead. This doesn't change the fact that each column name still represents a single field. In traditional database design, individual column names correspond to single fields even if they aren't keys. (eg, one would use part.partname and client.clientname rather than part.name and client.name). This is the reason for the existance of the INNER JOIN ... USING <key> and the NATURAL JOIN syntaxes.
Whoops, should have been ON c.id = ca.customer_id. Or better yet, name your identity columns descriptively, so it can be ON c.customer_id = ca.customer_id. Then if you accidentally use the wrong table alias somewhere, customer_id won't be a column in that table, and you'll get a nice compilation error, rather than empty results and subsequent code squinting.
After normalizing a database schema to limit redundancy, tables are divided in smaller tables with established relations (one to one, one to many, many to many). In the process single fields in the original table can appear in multiple normalized tables.
Now you need to have the customer ID referenced from CustomerAddress. You can't name the column id, obviously, so you go with customer_id.
Whether you choose to use unique or identical column names for identity fields is up to you, but regardless of what you choose, please be consistent :) 
Not everyone agrees with this methodolgoy, but in my databases I assign a unique abbreviation to each table.  The PK for that table would be named PK_[abbrv]ID.  IF that's used as an FK anywhere then I would use FK_[abbrv]ID.  Now I have zero guess work on figuring out what the table relationships are.
For instance a database for a blog could look like this in its unnormalized form, assuming a unique constraint on the Author_Nickname.