But we are talking about Romero here and there's probably a bit of exageration going on about the techniques.
To scroll the screen quickly, it was all in assembly language and I used a similar technique as I used with the Apple II version - quickly move bytes in video memory and draw a tile on the right side. In EGA it was trickier because to do anything quickly in EGA mode required the use of Latch Mode for memory moves. I remember teaching Todd Replogle how to do that so Duke Nukem 1 would be a fun game (a slow Duke Nukem would not have been cool).
I'd probably go with 1) as there's not much graphically going on, there may be some self-generated code to blit and clip images at the edges. One possible technique that a collegue of mine was working on back then was self-writing sprites, that is, the sprite data wasn't data, it was code. This meant there were no transparency checks and the data read of the blit was effectively free (this was on a 386 where each instruction was read and then decoded so instead of read code->read data->write data it was just read code->write data). It worked amazingly well - we got lots of huge sprites on multiple parallax layers running at 25fps+.
Moving the video RAM around with blitting to perform scrolling would have resulted in jerky scrolling.
The game code for Dangerous Dave PC was written in C, in the Borland C 3.0 IDE. Most debugging was done in Turbo Debugger on a 12" amber monitor plugged into a Hercules card.
EGA introduced the the vertical and horizontal pixel panning registers which could be used to set the screen origin (where in video memory the video card started displaying data from). Because there is no memory copying going on this is almost instant and can be used for very smooth and fast pixel by pixel scrolling on EGA and VGA if you have direct access to the hardware registers.
On the PC, the 1990 version, I wrote graphics code in 80x86 assembly language for all video modes at the time: CGA, EGA, VGA. Dangerous Dave PC is the only game I know of that has all 3 video modes in it and switchable at any time (F2), even in the middle of a jump!
Most scrollers in DOS would have used this, and this part of the code would probably have been written in assembly language to directly access the hardware registers.
The other method I can think of is using OpenGL or DirectX and rendering a texture to a quad twice the width of the screen and moving that.
My 1988 version of Dangerous Dave was the Apple II version. The scrolling was done by moving all the screen bytes over then drawing a new tile on the edge of the screen - repeat 20 times for a full screen shift. The Apple II version was written all in 6502 assembly language.
To achieve a similar effect now, I think on modern graphics hardware you could probably do it fast enough just redrawing the entire screen each frame.