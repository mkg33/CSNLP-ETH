The general rule of thumb is that if you are hardware-bound, you should split blocking tasks off into their own thread.  If you are computation-bound, you should split high computation tasks off into their own process.
The general consensus is that you should not optimize your code too early.  In other words, design your code as modular as possible, but do not add the extra complexity of threading until you realize that you must.
Second: Adding concurrent processes of any sort adds complexity because you are inherently creating an asynchronous condition that requires synchronization.  In other words, you must share data and time across the various tasks.  Unfortunately, the programmer must explicitly identify and create a design for these tasks to communicate with each other.
First: Threads and processes are different on different platforms, and there is an advantage to using processes on Linux and a disadvantage on Windows.  So your intended platform may drive which one you should use.
Third: Testing and especially debugging becomes much harder because the tasks run independently of each other and obtaining state information for each task and the system itself is much more complex.  This often means that you must increase your verbosity for logging and traces.