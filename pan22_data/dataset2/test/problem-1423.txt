Popular light-weight reverse proxies are varnish and pound. However, even apache can be configured to be a proxy thru mod_proxy. Ditto with lighttpd and nginx.
The great thing about this method is that you can mix technologies as well. We've got an IIS website that does a reverse proxy to Subversion and Apache, on two completely different boxes, but one public address space.
I bought a Slicehost VPS (the cheapest, 256MB one, running Ubuntu) because I'm interested in expanding my web development experience/understanding beyond the classroom.  I'm hoping to have the Slicehost run (1) a blog, (2) a wiki I can use for private organization purposes (myself and a few friends), and (3) development, in multiple languages (Ruby, PHP, python).  What I'm realizing is that there are a number of drawbacks to this.  First of all, I'd be launching one gigantic and ugly Apache process for each visitor (not that I expect any), and secondly, that would make configuration a nightmare.
A Reverse proxy is a plugin for the web server (in your case Apache) that translates URLs onto different servers, of your choosing.
For example, if a request comes in for /Wiki/, Apache will see it and forward your request to example.com:81 (or whatever you specify - you can use a RegEx to only forward parts or all of your request, re-arrange it, do whatever) and will forward on whatever it receives.
mod_proxy is the answer you seek. Although, you will need to setup a Apache process for each website. It may be more memory efficient if you simply load all needed modules and enable them as needed for each virtual host.
You want a reverse proxy, but keep in mind, since you're starting out, you shouldn't worry too much about a development server's apache processes, or how ugly the solution is, if your goal is to learn MT, Django, and RoR, you're probably better off doing separate vhosts, or having multiple instances running on different ports. Setting up a reverse proxy will work, but debugging issues will take longer as you won't know if the proxy is acting up, or you're actually sending a bad request.  With that disclaimer in mind, you need to do: 
Is there a way that I can run separate Apache processes to handle each program, but do so in a URL-transparent way?  I'd like to be able to have blog.mywebsite.com only load the relevant modules and configuration stuff for Movable Type, while having pydev.mywebsite.com load only the modules/config for an Apache running python, and railsdev.mywebsite.com run on Apache/Passenger or whatever.  I understand how to do this if I'm willing to have the URLs be mywebsite.com:8081/, mywebsite.com:8082/, etc., but is there a way to have one server listening to *.mywebsite.com:80 and have it pass requests along to the appropriate servers (which are listening on port 8081-8084 or so)?
What you want is a reverse proxy configuration. Yes, it is doable. Essentially, the reverse proxy pretends to be a web-server to the client. Then, based on the domain name requested, it can proxy the connection to specified back-end web-server(s).
So, you can have different web-servers listening on differen ports on 127.0.0.1 and have your reverse proxy redirect to them.