I'm implementing a Vehicle in unity without using Wheel Colliers because they don't have the level of control that I want, and their physics are extremely wonky. Being able to obtain a vector representing the z axis orientation makes it very easy to turn the car, since I only have to modify the Rigidbody.angularVelocity function to get it to turn.
It looks like you might just be confused about how to visualize the vectors. You're repeatedly visualizing the vector (0, 0, 10) with different start points, not visualizing the facing direction of transform.forward.
First is the simple Turning algorithm, which creates a triangle relationship with the front and back wheel of the car and the requested steering angle and then factors this relationship into a rate of change of angular velocity:
You can verify that the blue line drawn exactly tracks the blue z+ axis of the local transform gizmo for the GameObject to which this script is attached.
As you can see this driving algorithm would work fine on a completely flat surface, but would start to have wonky interactions with hills if the vehicle's pitch were to change.
rb.position and tf.position appear to be equivalent, while transform.forward and Vector3.forward are equivalent but are in the world's (x,y,z) 0 position. All four have the same orientation when I change the orientation of the Rigidbody via it's angular velocity property.
I've been trying to get the vector that represents the local rigid body's true forward pointing (z axis, or blue colored) vector. I've been using Debug.DrawLine(...) to try and find out which position vector to use.
With this in mind, you might want to consider re-evaluating Unity's built-in wheel collider. It's possible that the issues you had with it were a result of misinterpreting the vectors & math you were using. Physics libraries are strange and it's easy to make them behave badly, but the vast majority of troubles I've seen with them (including the majority of the problems I've had myself) turn out to be a result of using these tools incorrectly, and not an intrinsic flaw in the provided physics classes. They're just very easy to misconfigure.