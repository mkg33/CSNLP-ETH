I would suggest that the Perl script monitors the MySQL binary log and acts upon any change in size (which could indicate rows being added/deleted/updated anywhere in the database).
And if you hate DJB's distribution, consider Runit, which is a fork of DJB's daemontools, and provides much of the same functionality.
You could use the Time::HiRes module to sleep a quarter-second at a time, and check for a change in the log file size, and then run the appropriate SQL.
If you have many record insertions, triggering an external service for every insertion would kill your application. You will then want to batch process it according to time. However, for low number of insertions, you may not want to wait for the batch process to run. Then, the trigger may be good.
I would also suggest you do this in C if possible. If speed is required, you can't beat it. Check out:
In the case of daemontools, it also permits you to delegate logging to another dedicated program.  All your service needs to do is to print to stdout.  When you setup the logging service for your script, you can use multilog and keep a private log, or use /usr/bin/logger and output to the syslog, all w/o modifying your script.  (Upstart may provide this, but i dunno, my primary experience is with daemontools)
To prevent it crashing when it fails, you may want to configure it to respawn itself. There are a number of ways to do this including using daemontools as mentioned, spawn it as part of the inittab, or even wrapping with a shell script that does an infinite loop.
FWIW, I like the 'non-forking infinite loop' solution combined with a process supervisor like  DJB's daemontools.  I think ubuntu's Upstart also provides this.  The key feature is rigging your supervisor to automatically restart your service should it fail.
http://www.google.co.uk/search?rlz=1C1CHMA_en-GBGB359GB359&sourceid=chrome&ie=UTF-8&q=writing+a+linux+service+in+C
I am not 100% sure if it is such a good idea depending how the MySQL database is handled as you need to manage your database connection carefully, but it gets a lot easier for your admins. Also keep in mind to be careful with in and explicit locks as the database is used by another application which might not work with locked tables.