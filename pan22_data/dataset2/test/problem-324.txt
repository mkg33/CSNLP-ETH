That means that isPrime could be called with numbers on the order of 800.000.000.000.000.000. Trial division would need to run up to numbers on the order of 900.000.000. That's not entirely unreasonable on a modern desktop, but if you find that the program fails some test cases due to timeouts you may need to implement a more sophisticated primality test. That is quite a large subject.
I agree with the other existing answer (by R Sahu) that std:pow is not a great option here, but I disagree on the best option. In my opinion, since the only use of pow is to compute powers of ten, it would be best to simply compute an array of powers of ten from 10^0 = 1 to the largest one you'll actually need, which is the length of the input plus or minus one.
In fact, I don't see a reason for calling CountDigits more than once in the entire program. If you delete one digit from a prime with noDigits digits, you get a number with noDigits - 1 digits.
This confused me. Normally if a loop has a guard condition which compares the loop variable to another value, changing the other value is a "clever" way of doing break; sometimes it's genuinely clever as a way of maintaining a complex invariant (and should typically have a comment explaining what the invariant is). But when I looked to see why noDigits changes inside the loop, I couldn't find a reason.
I think there is a bug in the program in a corner case: if n is a one-digit prime, I think the output should be 1, but I think the code will output 0.