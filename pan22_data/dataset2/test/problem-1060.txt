Unity's component types are not natively tagged with the [System.Serializable] attribute, so your BinaryFormatter doesn't know how to serialize & deserialize them properly. (Which makes sense, because correctly deserializing a list of MonoBehaviour components would require knowing which GameObjects in the scene to attach them to, and how to work with Unity to update the scene hierarchy - a .Net standard method that doesn't know anything about Unity can't do that for you.
Remember when I suggested pulling out just the parts of the component you wanted to save, and putting them in a serializable struct? This is another reason why.
Defining your own serializable type lets you control exactly what gets saved/loaded and how, to make sure it does the right thing for your game. You can also make your save files more robust against minor changes to your game. Say you change the sprite used for Farm buildings in a recent update. If your save file contained the whole GameObject serialized, then when you load the old save in the new version it could still be referencing an old texture (or no texture at all if it's been removed from the build). By serializing just the information that it's a "Farm-type building, of level L, at position X, Y" lets the updated version of your game spawn a correct, modern, up-to-date version of the farm with those properties, rather than getting clogged with legacy data.