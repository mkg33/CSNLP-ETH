Another suggestion is instead of sampling the points, use the mean of the points you're skipping over.
The M is a command for Move to (followed by coordinates), the Ls are for Line to (with coordinates) and z is a command to close the path (i.e. draw a line back to the first location; that doesn't need coordinates).
A quadratic bezier curve does not go through the second point. If you want to go through the second point you need a different type of curve, such as a hermite curve. You may be able to convert the hermite curves into beziers so that you can use the Path class.
The internet has had this problem. The World Wide Web Consortium noticed. It has a recommended standard solution since 1999: Scalable Vector Graphics (SVG). It's an XML-based file format specifically designed for storing 2D shapes.
You can place with some interpolation samples here with only four points; and the results are quite good (my favourite is the Bezier for this case, although others might chime in about other effective solutions). 
The specification also gives instructions for converting most basic shapes into paths in case you want to.
Take a look at curve interpolation - there's a few different types you can implement that will help smooth your curve. The more points you can get on that circle, the better. Storage is pretty cheap - so if extracting 360 close nodes is cheap enough (even at 8 bytes for position; 360 nodes is hardly expensive to store).
Another suggestion is to use cubic beziers, with the tangent of one matching the tangent of the next. Otherwise (with quadratics) I think your curves won't match up smoothly.
Is there a reason for going for curves as opposed to straight lines? Straight lines are simpler to work with, and can be rendered efficiently in hardware.
SVG paths are "paths" in the sense that if you put a pencil to a paper, move it around and eventually raise it again, you have a path. They don't have to be closed, but they might be.
The other approach worth considering is to store a couple of bits per pixel, stating if it's inside, outside or on the outline of the shape. This should compress well, and might be more efficient than lines for complex selections.
They've written down exactly how basic shapes like circles or rectangles are to be stored. For example, rectangles have these properties: x, y, width, height, rx, ry. (The rx and ry can be used for rounded corners.)
As the specification says, you're free to leave out some of the properties if you don't need them. (For example, rx and ry attributes weren't used here.) Yes, there's a ton of cruft at the top about DOCTYPE which you won't need just for your game. They're are optional too.
The theory behind Bézier curves is covered well elsewhere (such as on Wikipedia), but here's the executive summary: Béziers have a start and end point, with possibly many control points that influence where the curve in between is going.
But if you do decide you want arbitrary shapes, SVG is the way to go: It has great tool support: You can find many libraries for XML parsing at the low level and SVG editor tools at the high level.
Each path has a d attribute (I like to think it stands for "draw"), containing path data, a sequence of commands for basically just putting a pen to a paper and moving it around.
Decide carefully if you want to go down this path (pun intended), because it's really quite complicated to represent any arbitrary 2D shape in text! You can make your life so much easier if you e.g. limit yourself to just paths made of (potentially really many) straight lines.
Another suggestion is instead of using an angle as a threshold, use the difference between the actual curve and the approximate curve. Angles aren't the real problem; the real problem is when the set of points doesn't fit a bezier curve.