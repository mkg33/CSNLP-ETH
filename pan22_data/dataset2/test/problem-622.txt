A renderer is a fundamental system and it probably supports creating and managing the lifetime of a bunch of renderable objects that correspond to visual things in your game (sprites or models, likely). Similarly, a physics engine likely has lifetime control over things that represent the entities that can move around in the physics simulation (rigid bodies). Each of those relevant systems should own, in some capacity, those objects and be responsible for updating them. 
The components you use in your game entity composition system should just be wrappers around the instances from those lower-level systems -- your position component could just wrap a rigid body, your visual component just wraps a renderable sprite or model, et cetera.
A singleton isn't really needed here, and so you should avoid it because it does carry the downsides you mentioned. Dependency injection isn't overkill -- the heart of the concept is that you pass things that an object needs to that object, ideally in the constructor. You don't need a heavyweight DI framework (like Ninject) for this -- just pass an extra parameter to a constructor somewhere.
This approach is occasionally known as the outboard component approach, if you're looking for more detail.
Then the system itself that owns the lower-level objects is responsible for updating them, and can do so in bulk and in a way that allows it to multithread that update if appropriate. Your main game loop controls the crude order in which those systems update (physics first, then renderer, or whatever). If you have a subsystem that doesn't have lifetime or update control over the instances it hands out, you can build a simple wrapper to handle the update of all the components relevant to that system in bulk as well, and decide where to place that update relative to the rest of your system updates (this often happens, I find, with "script" components).
This is the typical naive approach to component updates (and there's nothing necessarily wrong with it being naive, if it works for you). One of the big problems it has you actually touched on -- you're operating through the interface of the component (for example IComponent) so you know nothing about what it is you just updated. You likely also don't know anything about the ordering of components within the entity, so