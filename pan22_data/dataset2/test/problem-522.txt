But if constraints do not meet your needs, you can always use triggers to enforce your business rules.
Simplicity - Declaring a constraint is significantly simpler than declaring a constraint and writing the code that will enforce that declaration.
Accuracy - Code you didn't write will never have a bug that you created.  Database vendors spend time making sure their constraint code is accurate, so you don't have to.
If/when you have a database where any given table can be updated by one or more applications or code paths then placing the appropriate constraints in the database means that your applications won't be duplicating the "same" constraint code. This benefits you by simplifying maintenance (reducing the number of places to change if/when there is a data model change) and ensures that the constraints are consistently applied regardless of the application updating the data.
Speed - Your application can never have more distributions than the database it is based on.  Database vendors spend time making sure their constraint code is efficient, so you don't have to.  The database itself also has faster access to the data than an application could ever have no matter how efficient.
Re-use - You may start with one application on one platform, but it may not stay that way.  What if you need to access the data from a different OS, different hardware, or from a voice interface?  By having constraints in the database this code never has to be re-written for the new platform and never has to be debugged for accuracy or profiled for speed.
Users mostly retrieve data and are most concerned with fast access to unquestionably accurate information. They often need various counts, aggregations and listings that used to be generated in those iconic foot-thick stacks of greenbar-paper printouts but usually wind up on web pages today.
Editors mostly put data into the database and retrieve data one or a small number of records at a time. Their primary concerns are fast, accurate access to all the related pieces of data and fast, reliable storage of their changes.
The effort to produce any database is too valuable to ever throw it away. Like a house, the database will be extended, altered, and renovated many times. Even when it is completely replaced, all the data will be migrated to the new database while preserving all of the old business rules and relationships.
Completeness - Applications enforce constraints when data is entered into the database and would require additional effort to verify older data is accurate or to manipulate data already in the database. 
Also triggers are less likely to be portable, as they're usually written in vendor specific languages, such as PL/SQL.
Database development projects are almost always started at the behest of Users, but the design gets driven by the data-entry and record-at-a-time needs of Editors. As such, inexperienced developers often respond to the immediate need for speed (primarily, of development) by not putting constraints in the database.
In the case that you mention explicitly, where you are suddenly allowing something that wasn't previously allowed, this isn't really a problem - you remove whatever constraint enforced it, regardless of where that exists. In the opposite case, where suddenly teachers are no longer allowed to be students, you potentially have a bunch of data to clean up, again regardless of where the constraint existed previously.
This, by-the-way, is exactly what mainframe COBOL programmers have to do as those massive databases were often created before we had relational engines and constraints. Even if migrated to a modern system like IBM's DB2, constraints sometimes aren't fully implemented since the logic of the old rules, embodied perhaps in a series of COBOL "batch" programs, may be so convoluted as to not be practical to convert. Automated tools can instead be used to convert the old COBOL into a newer version with interfaces to the new relational engine and with a little tweaking, data integrity is preserved... until a new app is written that subtly corrupts everything and the company is hauled into court for, say, foreclosing on thousands of home-owners they shouldn't have.
Constraints implement those rules and relationships in a concise, declarative form in the database engine itself where they are easily accessed. Without them, subsequent developers would have to pour through the application programs to reverse-engineer those rules. Good Luck!
If the database is just storing a single-application's data for a single-user, such as in most Sqlite databases, it may not need constraints. In fact, they usually don't, so as to keep the access time so quick it's unmeasurable.
Personally, I think it's easier to create and alter constraints than it is to create triggers, for instance, which would be one way to enforce your business rule using source code.
If one and only one application is ever going to be used to make changes to the data for the entire life of the database, and that application is developed by one or a small number of well coordinated individuals, then it might be reasonable to rely on the application to insure data integrity.