second advantage is read performance. as you mentioned that new way of querying the data is any combination this f1 to f200 column in where clause. with key value pair design  f1 to f200 are present in one column lets say "FildName" and their values are present in second column lets say "FieldValue". 
if you see this design and assume that all 35M rows has values in all 200 columns then you current db will become 200*35M=700M rows in table right away. but it will not be much high in table space what you had with all columns in single table as we are just Transposing the Columns in to row. in this transpose operation actually we will not have rows where the values are NULL. so you can actually run query against this table and see how many nulls are there and estimate you target table size before you actually implement it.
coincidently I am also looking into one of the client support where we designed key-value pair structure for flexibility and currently table is over 1.5B rows and ETL is way too slow. well there are lot of other things in my case but have you thought about that design. you will have one row with all 200 columns present value, that row will convert in to 200 rows in Key-Value pair design. you will gain space advantage with this design depending on for a given AssetID and Date how many rows has actually all 200 f1 to f200 values present? if you say even 30% od columns have NULL value than that is your space saving. because in key-value pair design if value id NULL that row doesn't need to be in table. but in existing column structure design even NULL takes space.(I am not 100% sure but if you have more that 30 columns NULL in table then NULL take 4bytes).
In dealing with this kind of data where you need to insert lots of rows and you also need really good analytical query performance (I'm making an assumption that this is the case here), you might find that a columnar RDBMS is a good fit.  Take a look at Infobright CE and InfiniDB CE (both columnar storage engines plugged into MySQL), and Vertica CE as well (more PostgreSQL-like instead of MySQL-like)...all of these Community Editions are free (although Vertica is not open source, it does scale to 3 nodes and 1Tb of data for free).  Columnar RDBMS's typically offer "big query" response times that are 10-100X better than row-based, and load times that are 5-50X better. You have to use them correctly or they stink (don't do single-row operations...do all operations in a bulk approach), but used correctly they really rock. ;-)