In this solution, D2 is unnormalized vector from P0 to P which is either in same or opposite direction compared to D.
However, this code uses precision 1.0E-4, and recalculation of input point P. Is there a faster and numerically more stable way to do this?
Explanation is simple. d is distance between P and P0, and there are only two possible positions on a line where a point with distance d from point P0 can be on a line: in front, or behind point P0. Then I just check if positive point is same as input P.
Not sure if its relevant (Not 100% sure what your actually asking, but ill attempt my advice anyway) but use a raycast, this will then have a function that allows you to measure the "ray's" distance between the player and an object, or 2 objects if you prefer. 
For given input point P on a line defined as above, I want to test if P is in front of point P0. The code will be used in GLSL fragment shader.
c is cosine similarity between D and D2 multiplied by length of vector D2. It is either length of vector D2, or negated length of vector D2 depending on it's orientation.