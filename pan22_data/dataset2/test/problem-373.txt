In this answer I'll comment on things like style, robustness or API design, not analyzing your algorithm.
The uppercase package name Tree doesn't follow the Java naming conventions, and this will confuse any colleage that you might cooperate with. 99% of the Java folks follow these conventions, so any deviation irritates.
One hint on formatting: your formatting is somewhat inconsistent. You're probably formatting your code by hand. IDEs like Eclipse have automated formatting tools, e.g. Ctrl-I corrects the indentation of the block you marked in the source file, and Ctrl-Shift-F completely reformats the code. Very useful, makes formatting easy.
Documentation: for such a general-use class, you should write Javadocs for the public constructors and methods. Your IDE will create the boilerplate, and you have to write down what the methods and their arguments do (not how they do it). Have a look at the Java API specification to get an idea of rather good Javadocs.
You surely got a warning from your IDE about using a raw type. This declaration can benefit from generics, so the compiler already checks that the comparator is capable of comparing objects of type T:
Overall, there's nothing glaringly wrong with your logic, but your code is quite messy. You should practice making sure that your code is readable, for your own and other's sake. Have more consistent spacing after methods and if lines, ensure that your indentation is correct, and make sure your spacing around operators is less haphazard. Ideally, I should be able to glance at your code and "break it down" in my head easily using spacing alone. That's not as possible when there isn't a convention that can be relied on.
I'm using an early return nested inside the while and if constructs. Some developers don't like that, but I think it makes the code clearer. But it's a metter of taste.
And I added curly braces, which I highly recommend to always do. It's too easy to think you can add a second statement to dependent block, but without the braces it's just one conditional statement, and the next one will be executed unconditionally.
Java uses camelCasing. Every word after the first (or including the first if it's a class name) should be a capital. This make names easier to read, since it's clearer where the words start and end. All your names should follow this convention. For example: getSuccessor and getNode. You use proper camel casing in a couple places, but you're inconsistent.
You need a comparator that can compare objects of type T, e.g. if you want a BinarySearchTree<Double>, a Comparator<Double> or a Comparator<Number> will do, but a Comparator<String> won't. And that's what <? super T> says.
has a lot of inconsistent style that's making it harder to read than necessary. Putting spaces around operators is the cleanest way to go in my opinion. I also prefer to add spaces after commas:
In the add() method, you have numerous places where you create a new node for the new element: new Node<>(element). Especially the ones that you create just for the compare() call immediatelay after the comparison become garbage, and it happens repeatedly in the while loop. As all these nodes get exactly the same contents, it's enough to create one Node in the very beginning of the add() method, and use it in all the places instead of creation.
I'd delete this constructor. The T type argument has a confusing name (you have to pass a concrete instance of T and not a type like Double.class) and isn't used at all. Let the private BinarySearchTree(Comparator comparator) { ... } constructor directly do the work.
While your indentation for containsElement is poor, the idea behind the function is good. You've put most of the logic away in a general function contains that could be reused elsewhere if needed, then just delegate to it in containsElement. This is much better than the alternative of duplicating logic.
You use Objects.requireNonNull(e); quite often, probably to avoid getting a NullPointerException later, deep inside some method call stack. Of course, this also throws a NullPointerException, but from a controlled place (I'm typically too lazy to do that). It would be even better to always add a descriptive text which variable was null.