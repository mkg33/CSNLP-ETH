They may also be wanting to store text as UTF8, as suggested by Dan's answer, because that is usually more efficient space-wise than UCS2 or UTF16.
Another possibility is that the designers intended for it to be able to hold formats other than text, perhaps image data and so forth, and while this didn't make it into the final product support for it may not have been entirely refactored out from early prototypes.
N[VAR]CHAR types use UCS-2 which can only naturally work the Basic Multilingual Plane. It can store UTF16 using multiple characters for those on other planes (this can cause some confusion working directly in TSQL as string functions don't understand this may double-count or split such characters), but maybe your app's designers were not aware of this and were expecting non-BMP characters and were expecting UCS2 to be a problem for that.
It seems like there are several possible choices, but without going back to the original developers of your system, there's no way to be sure. Some of the possibilities include:
The only options to store data over 8000 bytes was text, ntext, or image back in the days of SQL Server 2000. The appropriate choice for long character data strings would be text or ntext, with text appropriate for single-byte characters tied to the column collations code page and ntext for Unicode (UCS-2).
It probably isn't that. as TEXT and NTEXT have existed since at least SQL Server 6.5, two versions prior to 2000. They were stored less efficiently back then, but so were IMAGE types (SQL Server 7 improved these matters and there have been further improvements since). My experience doesn't go further back than that and I can't quickly find any useful online reference for older versions.
I can only speculate as the why developers used the binary image type to store character data but it could be in order to store characters as UTF-8, which is more compact that ntext UCS-2. Although this method saves space, it does come with the cost of not being able to easily evaluate the character data in T-SQL; encoding/decoding of UTF-8 stored as binary needs would need to be done in the application code.
NTEXT (older and now deprecated though still supported in SQL2016) or NVARCHAR(MAX) (the preferred option since its introduction) should cover that for most purposes.