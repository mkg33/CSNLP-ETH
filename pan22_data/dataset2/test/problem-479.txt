In my opinion *), your biggest problem with Components is this: Components are NOT here to tell anyone else what to do. Components are here to DO things. You don't have a component just to hold the memory of some thing and then have other components operate on this. You want components that DO stuff with the data they got.
Messaging will help you with some aspects like triggering particles, powerups, and so on. For example, you could have a world object that subscribes to particle events and creates particles at the position described in the event.
It sounds like a lot of your problems could be solved with a messaging system and some additional attributes that allow you to specify some filters, and finally not worrying about being so strict with entities/components.
Filters will help you a lot in collisions. Filters can define if an object collides with another, and what response it will have. You add some attributes to your physics component  that defines what type of physics body it is, what other types of physics bodies it collides with and what the response should be. For example, a ball physics object collides with a paddle physics object and responds with reflection and particles.
By the way, these applies to all kinds of systems, not only Entity/Component systems, but also to classic inheritance with simple "GameObject"s or even library functions.
Finally, don't be so strict about your implementation. If you can find a way to make it work, but it's not really EC system, do it. Like in my example above, the particles to not need to be managed by a system or part of the EC system at all. It's more important to finish the game than it is to strictly follow a method that's already pretty poorly defined.
If you see yourself testing for the presence of other components (and then call functions there), then this is a clear sign, that either one of two things are true: