This iterates over both vectors simultaneously, extracting one component from each, and calling those components a and b respectively ... and multiplying them together and summing them as normal.  No need for the "vulgar" for x in range(len(v1)) antipattern.
The definition of (cross)dot_product(v1,v2) could be made a bit clearer and more consistent with span_orthogonal(vec):
Besides what @Reinderein and @AlexV already mentioned, you could have added the following to your code to deliver a complete runnable example:
This style is closer to what's possible with type hints in current versions of Python, as in that it's more structured. The idea behind numpydoc is to facilitate automated documentation generation using tools like Sphinx, but this goes a little bit beyond what I was trying to convey here.
The method span_orthogonal(vec) is not bulletproof, it  might result in a ZeroDivisionError exception when vec equals [1,0] and the random creation of orthogonal_vec happens to be [1] (or [2])
Your span_orthogonal(vec) function is doing stuff from your other functions, so rather than rewriting the code, you can just use those functions:
Also since @Reinderien also hinted you towards numpy, just let me tell you that there is also "special" documentation convention (aka numpydoc) often used in the scientific Python stack.
The reason is that only the first block of text is interpreted as documentation. Also the usual convention is to write documentation "the other way round", by which I mean first give a short summary on what your function does, than go on to provide details such as the expected input. Both aspects can also be found in the infamous official Style Guide for Python Code (aka PEP 8) in the section on documentation strings.
However, your method of giving all but the last coordinate random values, and then calculating the last coordinate's value based on that, gives an error when the sum for the rest of the components. So you should find a nonzero coordinate, exit the function if none such exists, then find the dot product of the remaining coordinates, then check whether that's zero.